<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="http://kforner.github.io/libraries/frameworks/qb_minimal/css/main.css"?>

<rss version="2.0"
 xmlns:blogChannel="http://backend.userland.com/blogChannelModule"
>

<channel>
<title>karl&#x27;s blog</title>
<link>http://kforner.github.io</link>
<description>R-related blog</description>
<lastBuildDate>2013-05-30T14:09:47</lastBuildDate>

<item>
<title>A dirty hack solution for packages using Depends</title>
<link>http://kforner.github.io/posts/package-depends-dirty-hack-solution.html</link>
<description>

&#x3C;link href=&#x22;/http://kforner.github.io/libraries/frameworks/qb_rss/css/main.css&#x22; rel=&#x22;stylesheet&#x22; /&#x3E;
&#x3C;link href=&#x22;/http://kforner.github.io/libraries/highlighters/prettify/css/twitter-bootstrap.css&#x22; rel=&#x22;stylesheet&#x22;&#x3E;

	&#x3C;ul id=&#x22;page_def&#x22;&#x3E;
		&#x3C;li id=&#x22;page_title&#x22;&#x3E;A dirty hack solution for packages using Depends&#x3C;/li&#x3E;
		&#x3C;li&#x3E;&#x3C;BR&#x3E;&#x3C;/li&#x3E;
		&#x3C;li id=&#x22;page_date&#x22;&#x3E;2013-05-27&#x3C;/li&#x3E;
		&#x3C;li&#x3E;&#x3C;a id=&#x27;source_link&#x27; href=&#x27;/package-depends-dirty-hack-solution.Rmd&#x27;&#x3E;Source&#x3C;/a&#x3E; 
		&#x3C;/li&#x3E;
	&#x3C;/ul&#x3E;

&#x3C;div id=&#x22;post_content&#x22;&#x3E;
&#x3C;h2&#x3E;Motivation&#x3C;/h2&#x3E;
&#x3C;p&#x3E;As stated in the the &#x26;quot;Writing R Extensions&#x26;quot;, the Software for Data Analysis book (aka the R bible), packages should
whenever possible use &#x3C;strong&#x3E;Imports&#x3C;/strong&#x3E; instead of &#x3C;strong&#x3E;Depends&#x3C;/strong&#x3E;, to avoid name collision (masking) and ensure trustworthy computations. 
See &#x3C;a href=&#x22;http://stackoverflow.com/questions/8637993/better-explanation-of-when-to-use-imports-depends&#x22;&#x3E;this discussion on Stackoverflow&#x3C;/a&#x3E;.&#x3C;/p&#x3E;

&#x3C;h2&#x3E;The problem&#x3C;/h2&#x3E;

&#x3C;p&#x3E;So after adopting best practices, and only using &#x3C;strong&#x3E;Imports&#x3C;/strong&#x3E; in my packages, the problem is that some &#x3C;em&#x3E;imported&#x3C;/em&#x3E; packages 
do not follow those best practices and rely on &#x3C;strong&#x3E;Depends&#x3C;/strong&#x3E; for their dependencies, and consequently will not find 
their dependencies unless hacked.  &#x3C;/p&#x3E;

&#x3C;p&#x3E;Say we are writing a package &#x3C;strong&#x3E;MyPkg&#x3C;/strong&#x3E;, that uses some functions from a CRAN package &#x3C;strong&#x3E;A&#x3C;/strong&#x3E;, which lists a CRAN 
package &#x3C;strong&#x3E;B&#x3C;/strong&#x3E; in its Depends.&#x3C;/p&#x3E;

&#x3C;p&#x3E;&#x3C;em&#x3E;MyPkg::f&#x3C;/em&#x3E;&#x3C;/p&#x3E;

&#x3C;pre&#x3E;&#x3C;code&#x3E;f &#x26;lt;- function() a()
&#x3C;/code&#x3E;&#x3C;/pre&#x3E;

&#x3C;p&#x3E;&#x3C;em&#x3E;A::a&#x3C;/em&#x3E;&#x3C;/p&#x3E;

&#x3C;pre&#x3E;&#x3C;code&#x3E;a &#x26;lt;- function() b()
&#x3C;/code&#x3E;&#x3C;/pre&#x3E;

&#x3C;p&#x3E;Executing &#x3C;code&#x3E;f()&#x3C;/code&#x3E; will find the function &#x3C;code&#x3E;a&#x3C;/code&#x3E;, explicitly imported from package A. But executing &#x3C;code&#x3E;a()&#x3C;/code&#x3E; will die because 
function &#x3C;code&#x3E;b&#x3C;/code&#x3E; can not be found.&#x3C;/p&#x3E;

&#x3C;h2&#x3E;analysis&#x3C;/h2&#x3E;

&#x3C;p&#x3E;Because B is in A Depends, &#x3C;code&#x3E;b()&#x3C;/code&#x3E; is normally found in the search path, where namespace &#x3C;strong&#x3E;B&#x3C;/strong&#x3E; is attached. 
What can we do to work around this problem ?&#x3C;br&#x3E;
Sadly, there is nothing we can do at the  &#x3C;strong&#x3E;MyPkg&#x3C;/strong&#x3E; package level, since the problem sits in the &#x3C;strong&#x3E;A&#x3C;/strong&#x3E; namespace.
We could of course lists B in the &#x3C;strong&#x3E;MyPkg&#x3C;/strong&#x3E; Depends, but that is precisely what we want to avoid.&#x3C;/p&#x3E;

&#x3C;h2&#x3E;the dirty hack solution&#x3C;/h2&#x3E;

&#x3C;h3&#x3E;the idea&#x3C;/h3&#x3E;

&#x3C;p&#x3E;I suggest that you first have a look at this very good blog 
&#x3C;a href=&#x22;http://obeautifulcode.com/R/How-R-Searches-And-Finds-Stuff/&#x22;&#x3E;How R Searches and Finds Stuff&#x3C;/a&#x3E; if you need some 
clarification about namespaces and imports.  &#x3C;/p&#x3E;

&#x3C;p&#x3E;Here is a diagram of the current state of the problem:&#x3C;/p&#x3E;

&#x3C;p&#x3E;&#x3C;img src=&#x22;http://kforner.github.io/posts/assets/fig/unnamed-chunk-1.png&#x22; alt=&#x22;plot of chunk unnamed-chunk-1&#x22;&#x3E; &#x3C;/p&#x3E;

&#x3C;p&#x3E;We want the &#x3C;code&#x3E;a()&#x3C;/code&#x3E; call, which is executed in namespace &#x3C;strong&#x3E;A&#x3C;/strong&#x3E;, to find the &#x3C;strong&#x3E;b&#x3C;/strong&#x3E; symbol in namespace &#x3C;strong&#x3E;B&#x3C;/strong&#x3E;. 
To achieve this, we will re-route the namespace &#x3C;strong&#x3E;A&#x3C;/strong&#x3E; (actually its Imports namespace) to the &#x3C;strong&#x3E;B&#x3C;/strong&#x3E; namespace:&#x3C;/p&#x3E;

&#x3C;pre&#x3E;&#x3C;code&#x3E;nsa &#x26;lt;- getNamespace(&#x26;#39;A&#x26;#39;)
nsa_imp &#x26;lt;- parent.env(nsa)
parent.env(nsa_imp) &#x26;lt;- getNamespace(&#x26;#39;B&#x26;#39;)
&#x3C;/code&#x3E;&#x3C;/pre&#x3E;

&#x3C;p&#x3E;Now our namespaces should look like this:  &#x3C;/p&#x3E;

&#x3C;p&#x3E;&#x3C;img src=&#x22;http://kforner.github.io/posts/assets/fig/unnamed-chunk-2.png&#x22; alt=&#x22;plot of chunk unnamed-chunk-2&#x22;&#x3E; &#x3C;/p&#x3E;

&#x3C;h2&#x3E;Example&#x3C;/h2&#x3E;

&#x3C;p&#x3E;The above code is not straightforward to test because you need to write a package.  &#x3C;/p&#x3E;

&#x3C;p&#x3E;Here is some reproducible code that illustrates how the hack works, using package &#x3C;strong&#x3E;multcomp&#x3C;/strong&#x3E; that &#x3C;em&#x3E;Depends&#x3C;/em&#x3E; on &#x3C;strong&#x3E;mvtnorm&#x3C;/strong&#x3E;&#x3C;/p&#x3E;

&#x3C;pre&#x3E;&#x3C;code class=&#x22;r&#x22;&#x3E;l &#x26;lt;- loadNamespace(&#x26;quot;multcomp&#x26;quot;)  # assignment to avoid annoying print

amod &#x26;lt;- aov(breaks ~ wool + tension, data = warpbreaks)
wht &#x26;lt;- multcomp::glht(amod, linfct = multcomp::mcp(tension = &#x26;quot;Tukey&#x26;quot;))
ci &#x26;lt;- confint(wht)  # mvtnorm::qmvt is not found
&#x3C;/code&#x3E;&#x3C;/pre&#x3E;

&#x3C;pre&#x3E;&#x3C;code&#x3E;## Error: could not find function &#x26;quot;qmvt&#x26;quot;
&#x3C;/code&#x3E;&#x3C;/pre&#x3E;

&#x3C;pre&#x3E;&#x3C;code class=&#x22;r&#x22;&#x3E;
# let&#x26;#39;s load the mvtnorm namespace
l &#x26;lt;- loadNamespace(&#x26;quot;mvtnorm&#x26;quot;)
ci &#x26;lt;- confint(wht)  # mvtnorm::qmvt still not found
&#x3C;/code&#x3E;&#x3C;/pre&#x3E;

&#x3C;pre&#x3E;&#x3C;code&#x3E;## Error: could not find function &#x26;quot;qmvt&#x26;quot;
&#x3C;/code&#x3E;&#x3C;/pre&#x3E;

&#x3C;pre&#x3E;&#x3C;code class=&#x22;r&#x22;&#x3E;
# hack hack hack
ns1 &#x26;lt;- getNamespace(&#x26;quot;multcomp&#x26;quot;)
ns1_imp &#x26;lt;- parent.env(ns1)
parent.env(ns1_imp) &#x26;lt;- getNamespace(&#x26;quot;mvtnorm&#x26;quot;)

ci &#x26;lt;- confint(wht)  # now should work
print(ci)
&#x3C;/code&#x3E;&#x3C;/pre&#x3E;

&#x3C;pre&#x3E;&#x3C;code&#x3E;## 
##   Simultaneous Confidence Intervals
## 
## Multiple Comparisons of Means: Tukey Contrasts
## 
## 
## Fit: aov(formula = breaks ~ wool + tension, data = warpbreaks)
## 
## Quantile = 2.416
## 95% family-wise confidence level
##  
## 
## Linear Hypotheses:
##            Estimate lwr     upr    
## M - L == 0 -10.000  -19.354  -0.646
## H - L == 0 -14.722  -24.076  -5.368
## H - M == 0  -4.722  -14.076   4.632
&#x3C;/code&#x3E;&#x3C;/pre&#x3E;

&#x3C;h2&#x3E;implementation of the hack in MyPkg&#x3C;/h2&#x3E;

&#x3C;p&#x3E;Just put the re-routing code in your MyPkg &#x3C;strong&#x3E;.onLoad&#x3C;/strong&#x3E; function, defined usually in &#x3C;code&#x3E;R/zzz.R&#x3C;/code&#x3E;:&#x3C;/p&#x3E;

&#x3C;pre&#x3E;&#x3C;code&#x3E;.onLoad &#x26;lt;- function(libname, pkgname) {
    nsa &#x26;lt;- getNamespace(&#x26;#39;A&#x26;#39;)
    nsa_imp &#x26;lt;- parent.env(nsa)
    parent.env(nsa_imp) &#x26;lt;- getNamespace(&#x26;#39;B&#x26;#39;)    
}
&#x3C;/code&#x3E;&#x3C;/pre&#x3E;

&#x3C;h3&#x3E;why dirty ?&#x3C;/h3&#x3E;

&#x3C;p&#x3E;First of all, it uses &#x3C;code&#x3E;parent.env&#x26;lt;-&#x3C;/code&#x3E;, and according to the documentation:&#x3C;/p&#x3E;

&#x3C;blockquote&#x3E;
&#x3C;p&#x3E;The replacement function parent.env&#x26;lt;- is extremely dangerous as it can be used to destructively change environments in ways &#x26;gt;that violate assumptions made by the internal C code. It may be removed in the near future.&#x3C;/p&#x3E;
&#x3C;/blockquote&#x3E;

&#x3C;p&#x3E;It is a pity because it can be extremely useful.&#x3C;/p&#x3E;

&#x3C;h3&#x3E;why a hack ?&#x3C;/h3&#x3E;

&#x3C;p&#x3E;Unfortunately it does not work in the general case. 
Suppose you need two packages A and D, that both depend on B and C, but with different rules:&#x3C;/p&#x3E;

&#x3C;pre&#x3E;&#x3C;code&#x3E;A -&#x26;gt; B -&#x26;gt; C
D -&#x26;gt; C -&#x26;gt; B
&#x3C;/code&#x3E;&#x3C;/pre&#x3E;

&#x3C;p&#x3E;In that case, we would re-route A to B, then B to C. And this is incompatible with the way D is designed, resulting in
wrong symbol picks if symbols with same name are both defined by B and C.&#x3C;/p&#x3E;

&#x3C;h3&#x3E;so what ?&#x3C;/h3&#x3E;

&#x3C;p&#x3E;We&#x26;#39;ll see in a future post a probably much better solution.&#x3C;/p&#x3E;

&#x3C;p&#x3E;&#x3C;em&#x3E;Karl Forner @ Quartz Bio&#x3C;/em&#x3E;&#x3C;/p&#x3E;

&#x3C;/div&#x3E;
</description>
</item>
</channel>
</rss>
