{"site":{"title":"Karl's Blog","logo":"assets/img/quartzbio_square_logo.png","background":"assets/img/bgr-numerique.jpg","feed_img":"assets/img/rss2.png","owner":"Karl Forner","author":{"email":"karl.forner@gmail.com","github":"kforner","firstname":"Karl","lastname":"Forner"},"url":"/","rawurl":"/","navigation":[{"item":"Home","href":"index.html"},{"item":"About","href":"about.html"}],"google_search_engine_id":"016732723349564622635:1pee01gdpao","google_analytics_id":"UA-41262764-1"},"pages":[{"url":{"assets":"../assets","lib":"../libraries"},"framework":"qb_rss","theme":"","highlighter":"prettify","hitheme":"twitter-bootstrap","copy_libraries":true,"mode":"selfcontained","widgets":[],"prettify":{"linenums":true},"title":"Combine car, multcomp and phia to perform smarter linear modeling","author":"Marc Lamarine","license":"GPL (>= 2)","tags":"linear model, univariate","summary":"How to combine functions of several linear modelling packages and benefit from all","date":15852,"slides":[{"html":"<pre><code class=\"r\">library(multcomp)\nlibrary(car)\nlibrary(effects)\nlibrary(phia)\n</code></pre>\n\n<h1>Combine car, multcomp and phia to perform smarter linear modeling.</h1>\n\n<p>These examples have been largely inpired by Helios De Rosario-Martinez <helios.derosario at ibv.upv.es> <a href=\"http://cran.r-project.org/web/packages/phia/vignettes/phia.pdf\">vignette</a> from the <a href=\"http://cran.r-project.org/web/packages/phia/index.html\">phia</a>. I recommend as well as the reading of <a href=\"http://cran.r-project.org/web/packages/multcomp/\">mutlcomp</a> textbook: <a href=\"http://www.amazon.co.uk/gp/product/1584885742/\">Multiple Comparisons Using R</a> from Multiple Comparisons from Torsten Hothorn, Frank Bretz and Peter Westfall. The <a href=\"http://socserv.socsci.mcmaster.ca/jfox/Books/Companion/index.html%20ressource%20is%20obviously%20a%20place%20to%20be%20:-\">car</a>.</p>\n\n<p>.The Boik data set from <strong>phia</strong> is based on the hypothetical example used by R.J. Boik (1979) to explain the analysis of interaction contrasts. It represents the electrodermal response of 72 students complaining of hemophobia, treated with different fear reduction therapies and doses of antianxiety medication, in a balanced factorial design. The response variable <strong>edr</strong> is modeled with two factors <strong>therapy</strong>, with levels control, T1, and \nT2 and <strong>medication</strong>, with levels placebo, D1, D2, and D3 in interaction.</p>\n\n<h2>Introduction</h2>\n\n<pre><code class=\"r\">some(Boik)\n</code></pre>\n\n<pre><code>##    therapy medication   edr\n## 7  control         D1 45.59\n## 12 control         D1 44.75\n## 13 control         D2 47.64\n## 16 control         D2 44.86\n## 20 control         D3 50.92\n## 36      T1         D1 44.24\n## 44      T1         D3 11.61\n## 50      T2    placebo 40.25\n## 53      T2    placebo 45.22\n## 56      T2         D1 40.49\n</code></pre>\n\n<pre><code class=\"r\">table(Boik[, 1:2])\n</code></pre>\n\n<pre><code>##          medication\n## therapy   placebo D1 D2 D3\n##   control       6  6  6  6\n##   T1            6  6  6  6\n##   T2            6  6  6  6\n</code></pre>\n\n<p>I chose to tweak a bit this data set to avoid using the medication as an ordered factor to ease my interpretation \nof linear models outputs.</p>\n\n<pre><code class=\"r\">Boik$medF &lt;- factor(as.character(Boik$medication), levels = c(&quot;placebo&quot;, &quot;D1&quot;, &quot;D2&quot;, &quot;D3&quot;))\nlevels(Boik$medF)\n</code></pre>\n\n<pre><code>## [1] &quot;placebo&quot; &quot;D1&quot;      &quot;D2&quot;      &quot;D3&quot;\n</code></pre>\n\n<h2>Fit two models with interaction and main effects only</h2>\n\n<pre><code class=\"r\">mod.boik &lt;- lm(edr ~ therapy * medF, data = Boik)\nmod.boik.M &lt;- lm(edr ~ therapy + medF, data = Boik)\nsummary(mod.boik)\n</code></pre>\n\n<pre><code>## \n## Call:\n## lm(formula = edr ~ therapy * medF, data = Boik)\n## \n## Residuals:\n##     Min      1Q  Median      3Q     Max \n## -11.358  -1.857   0.307   2.717   7.714 \n## \n## Coefficients:\n##                  Estimate Std. Error t value Pr(&gt;|t|)    \n## (Intercept)        50.200      1.787   28.10  &lt; 2e-16 ***\n## therapyT1          -0.301      2.527   -0.12    0.906    \n## therapyT2          -4.501      2.527   -1.78    0.080 .  \n## medFD1             -2.701      2.527   -1.07    0.289    \n## medFD2             -4.201      2.527   -1.66    0.102    \n## medFD3             -2.301      2.527   -0.91    0.366    \n## therapyT1:medFD1   -8.998      3.573   -2.52    0.014 *  \n## therapyT2:medFD1   -3.899      3.573   -1.09    0.280    \n## therapyT1:medFD2  -17.199      3.573   -4.81  1.0e-05 ***\n## therapyT2:medFD2   -4.998      3.573   -1.40    0.167    \n## therapyT1:medFD3  -28.599      3.573   -8.00  4.8e-11 ***\n## therapyT2:medFD3  -10.699      3.573   -2.99    0.004 ** \n## ---\n## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 \n## \n## Residual standard error: 4.38 on 60 degrees of freedom\n## Multiple R-squared: 0.843,   Adjusted R-squared: 0.815 \n## F-statistic: 29.4 on 11 and 60 DF,  p-value: &lt;2e-16\n</code></pre>\n\n<pre><code class=\"r\">Anova(mod.boik)\n</code></pre>\n\n<pre><code>## Anova Table (Type II tests)\n## \n## Response: edr\n##              Sum Sq Df F value  Pr(&gt;F)    \n## therapy        2444  2    63.8 1.4e-15 ***\n## medF           2371  3    41.3 1.3e-14 ***\n## therapy:medF   1376  6    12.0 8.5e-09 ***\n## Residuals      1149 60                    \n## ---\n## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1\n</code></pre>\n\n<h2>Use allEffects(), and interactionMeans() to compute cells and marginal means</h2>\n\n<pre><code class=\"r\">boik.means &lt;- interactionMeans(mod.boik)\nboik.means\n</code></pre>\n\n<pre><code>##    therapy    medF adjusted mean\n## 1  control placebo          50.2\n## 2       T1 placebo          49.9\n## 3       T2 placebo          45.7\n## 4  control      D1          47.5\n## 5       T1      D1          38.2\n## 6       T2      D1          39.1\n## 7  control      D2          46.0\n## 8       T1      D2          28.5\n## 9       T2      D2          36.5\n## 10 control      D3          47.9\n## 11      T1      D3          19.0\n## 12      T2      D3          32.7\n</code></pre>\n\n<pre><code class=\"r\">interactionMeans(mod.boik, factors = &quot;therapy&quot;)\n</code></pre>\n\n<pre><code>##   therapy adjusted mean\n## 1 control          47.9\n## 2      T1          33.9\n## 3      T2          38.5\n</code></pre>\n\n<pre><code class=\"r\">\ninteractionMeans(mod.boik, factors = &quot;medF&quot;)\n</code></pre>\n\n<pre><code>##      medF adjusted mean\n## 1 placebo          48.6\n## 2      D1          41.6\n## 3      D2          37.0\n## 4      D3          33.2\n</code></pre>\n\n<p>Several type of interaction plots  are available to visualise the &#39;interaction effect&#39;</p>\n\n<pre><code class=\"r\">plot(boik.means, multiple = TRUE)\n\n\nplot(allEffects(mod.boik))\n</code></pre>\n\n<p><img src=\"assets/fig/unnamed-chunk-6.png\" alt=\"plot of chunk unnamed-chunk-6\"> </p>\n\n<h2>The phia package is remarkebly designed to compute  various contrasts of interests using testInteractions() function.</h2>\n\n<p>The columns medication1, . . . medication3 in the resulting table contain the value of the three\northogonal contrasts across the levels of medication, for each level of therapy (the only fixed factor\nin this example). In addition a F test (actually a global F test) is performed for each level of therapy</p>\n\n<pre><code class=\"r\">testInteractions(mod.boik, fixed = &quot;therapy&quot;, across = &quot;medF&quot;, adjustment = &quot;none&quot;)\n</code></pre>\n\n<pre><code>## F Test: \n## P-value adjustment method: none\n##           medF1 medF2 medF3 Df Sum of Sq     F  Pr(&gt;F)    \n## control     2.3  -0.4  -1.9  3        54  0.95    0.42    \n##      T1    30.9  19.2   9.5  3      3154 54.90 &lt; 2e-16 ***\n##      T2    13.0   6.4   3.8  3       539  9.38 3.6e-05 ***\n## Residuals                   60      1149                  \n## ---\n## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1\n</code></pre>\n\n<p>Behind the scene, <strong>testInteractions()</strong> calls <strong>testFactors()</strong>. The ones corresponding to the one above are detailed below.</p>\n\n<pre><code class=\"r\">con.therapy &lt;- testFactors(mod.boik, levels = list(therapy = c(&quot;control&quot;)), \n    terms.formula = ~medF, adjustment = &quot;none&quot;)\n</code></pre>\n\n<pre><code class=\"r\">testFactors(mod.boik, levels = list(therapy = c(&quot;T1&quot;)), terms.formula = ~medF, \n    adjustment = &quot;none&quot;)\ntestFactors(mod.boik, levels = list(therapy = c(&quot;T2&quot;)), terms.formula = ~medF, \n    adjustment = &quot;none&quot;)\n</code></pre>\n\n<p>The cont.therapy ob</p>\n\n<pre><code class=\"r\">con.therapy\n</code></pre>\n\n<pre><code>## \n## Call: blogify(model = &quot;.&quot;) \n## \n## Term (Intercept) \n## \n## Adjusted mean:\n##      \n## 47.9 \n## \n## Linear hypothesis test\n## \n## Hypothesis:\n## (Intercept)  + 0.25 medFD1  + 0.25 medFD2  + 0.25 medFD3 = 0\n## \n## Model 1: restricted model\n## Model 2: edr ~ therapy * medF\n## \n##   Res.Df   RSS Df Sum of Sq    F Pr(&gt;F)    \n## 1     61 56214                             \n## 2     60  1149  1     55065 2875 &lt;2e-16 ***\n## ---\n## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 \n## ------\n## \n## Term medF \n## \n## Adjusted mean at contrasts of medF:\n##   medF1   medF2   medF3 \n##  2.3006 -0.4008 -1.8999 \n## \n## Linear hypothesis test\n## \n## Hypothesis:\n## - medFD3 = 0\n## medFD1 - medFD3 = 0\n## medFD2 - medFD3 = 0\n## \n## Model 1: restricted model\n## Model 2: edr ~ therapy * medF\n## \n##   Res.Df  RSS Df Sum of Sq     F Pr(&gt;F)\n## 1     63 1203                          \n## 2     60 1149  3     54.38 0.947  0.424\n## ------\n</code></pre>\n\n<pre><code class=\"r\">names(con.therapy)\n</code></pre>\n\n<pre><code>## [1] &quot;call&quot;             &quot;model.call&quot;       &quot;levels&quot;          \n## [4] &quot;factor.contrasts&quot; &quot;covariates&quot;       &quot;terms&quot;\n</code></pre>\n\n<p>It contains notably the hypothesis matrix done for a <strong>global F test</strong> that test the non equality of the edr value for the designated therapy level across levels of medication. </p>\n\n<pre><code class=\"r\">con.therapy$terms$`(Intercept)`$adjusted.values\n</code></pre>\n\n<pre><code>##      [,1]\n## [1,] 47.9\n</code></pre>\n\n<pre><code class=\"r\">con.therapy$terms$medF$adjusted.values\n</code></pre>\n\n<pre><code>##          [,1]\n## medF1  2.3006\n## medF2 -0.4008\n## medF3 -1.8999\n</code></pre>\n\n<pre><code class=\"r\">con.therapy$terms$medF$hypothesis.matrix\n</code></pre>\n\n<pre><code>##       (Intercept) therapyT1 therapyT2 medFD1 medFD2 medFD3\n## medF1           0         0         0      0      0     -1\n## medF2           0         0         0      1      0     -1\n## medF3           0         0         0      0      1     -1\n##       therapyT1:medFD1 therapyT2:medFD1 therapyT1:medFD2 therapyT2:medFD2\n## medF1                0                0                0                0\n## medF2                0                0                0                0\n## medF3                0                0                0                0\n##       therapyT1:medFD3 therapyT2:medFD3\n## medF1                0                0\n## medF2                0                0\n## medF3                0                0\n</code></pre>\n\n<p>The default contrasts definition used in the testInteractions() and testFactors() are takken from their default.contrasts=c(&quot;contr.sum&quot;,&quot;contr.poly&quot;), which is usually not the ones that were used by default in R (see below and the <strong>mod.boik</strong> model).\nThis is very  <strong>important</strong> as it ensures that F tests and global F tests are meaningfull.</p>\n\n<pre><code class=\"r\">options(&quot;contrasts&quot;)\n</code></pre>\n\n<pre><code>## $contrasts\n##         unordered           ordered \n## &quot;contr.treatment&quot;      &quot;contr.poly&quot;\n</code></pre>\n\n<pre><code class=\"r\">contr.sum(levels(Boik$medF))\n</code></pre>\n\n<pre><code>##         [,1] [,2] [,3]\n## placebo    1    0    0\n## D1         0    1    0\n## D2         0    0    1\n## D3        -1   -1   -1\n</code></pre>\n\n<pre><code class=\"r\">contr.treatment(levels(Boik$medF))\n</code></pre>\n\n<pre><code>##         D1 D2 D3\n## placebo  0  0  0\n## D1       1  0  0\n## D2       0  1  0\n## D3       0  0  1\n</code></pre>\n\n<p>The therapy adjusted.values are computed using the folowing algebra.</p>\n\n<pre><code class=\"r\"># using the hypothesis matrix\ncon.therapy$terms$medF$hypothesis.matrix %*% coef(mod.boik)\n</code></pre>\n\n<pre><code>##          [,1]\n## medF1  2.3006\n## medF2 -0.4008\n## medF3 -1.8999\n</code></pre>\n\n<pre><code class=\"r\"># which correponds to a contrasts sum options\nt(contr.sum(levels(Boik$medF))[-c(1), ]) %*% coef(mod.boik)[c(4:6)]\n</code></pre>\n\n<pre><code>##         [,1]\n## [1,]  2.3006\n## [2,] -0.4008\n## [3,] -1.8999\n</code></pre>\n\n<pre><code class=\"r\"># the default contrast (the one used in the model and summary output) are\n# reprouced below\nt(contr.treatment(levels(Boik$medF))[-c(1), ]) %*% coef(mod.boik)[c(2:4)]\n</code></pre>\n\n<pre><code>##       [,1]\n## D1 -0.3008\n## D2 -4.5012\n## D3 -2.7014\n</code></pre>\n\n<h1>How to obtain the same results with different functions</h1>\n\n<p>Especially, how to reproduce classic univariates results.</p>\n\n<h2>Obtain Anova global F interaction test with <strong>linearHypothesis()</strong>.</h2>\n\n<pre><code class=\"r\">coefs &lt;- coefficients(mod.boik)\ncoefs\n</code></pre>\n\n<pre><code>##      (Intercept)        therapyT1        therapyT2           medFD1 \n##          50.2004          -0.3008          -4.5012          -2.7014 \n##           medFD2           medFD3 therapyT1:medFD1 therapyT2:medFD1 \n##          -4.2005          -2.3006          -8.9975          -3.8985 \n## therapyT1:medFD2 therapyT2:medFD2 therapyT1:medFD3 therapyT2:medFD3 \n##         -17.1985          -4.9984         -28.5994         -10.6990\n</code></pre>\n\n<pre><code class=\"r\">linearHypothesis(mod.boik, names(coefs)[7:12], verbose = TRUE)\n</code></pre>\n\n<pre><code>## \n## Hypothesis matrix:\n##                  (Intercept) therapyT1 therapyT2 medFD1 medFD2 medFD3\n## therapyT1:medFD1           0         0         0      0      0      0\n## therapyT2:medFD1           0         0         0      0      0      0\n## therapyT1:medFD2           0         0         0      0      0      0\n## therapyT2:medFD2           0         0         0      0      0      0\n## therapyT1:medFD3           0         0         0      0      0      0\n## therapyT2:medFD3           0         0         0      0      0      0\n##                  therapyT1:medFD1 therapyT2:medFD1 therapyT1:medFD2\n## therapyT1:medFD1                1                0                0\n## therapyT2:medFD1                0                1                0\n## therapyT1:medFD2                0                0                1\n## therapyT2:medFD2                0                0                0\n## therapyT1:medFD3                0                0                0\n## therapyT2:medFD3                0                0                0\n##                  therapyT2:medFD2 therapyT1:medFD3 therapyT2:medFD3\n## therapyT1:medFD1                0                0                0\n## therapyT2:medFD1                0                0                0\n## therapyT1:medFD2                0                0                0\n## therapyT2:medFD2                1                0                0\n## therapyT1:medFD3                0                1                0\n## therapyT2:medFD3                0                0                1\n## \n## Right-hand-side vector:\n## [1] 0 0 0 0 0 0\n## \n## Estimated linear function (hypothesis.matrix %*% coef - rhs)\n## therapyT1:medFD1 therapyT2:medFD1 therapyT1:medFD2 therapyT2:medFD2 \n##           -8.998           -3.899          -17.199           -4.998 \n## therapyT1:medFD3 therapyT2:medFD3 \n##          -28.599          -10.699\n</code></pre>\n\n<pre><code>## Linear hypothesis test\n## \n## Hypothesis:\n## therapyT1:medFD1 = 0\n## therapyT2:medFD1 = 0\n## therapyT1:medFD2 = 0\n## therapyT2:medFD2 = 0\n## therapyT1:medFD3 = 0\n## therapyT2:medFD3 = 0\n## \n## Model 1: restricted model\n## Model 2: edr ~ therapy * medF\n## \n##   Res.Df  RSS Df Sum of Sq  F  Pr(&gt;F)    \n## 1     66 2525                            \n## 2     60 1149  6      1376 12 8.5e-09 ***\n## ---\n## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1\n</code></pre>\n\n<h2>Obtain univariate linear model coefficients statistics done with <strong>summary()</strong> with <strong>testFactors()</strong></h2>\n\n<pre><code class=\"r\">summary(mod.boik)\n</code></pre>\n\n<pre><code>## \n## Call:\n## lm(formula = edr ~ therapy * medF, data = Boik)\n## \n## Residuals:\n##     Min      1Q  Median      3Q     Max \n## -11.358  -1.857   0.307   2.717   7.714 \n## \n## Coefficients:\n##                  Estimate Std. Error t value Pr(&gt;|t|)    \n## (Intercept)        50.200      1.787   28.10  &lt; 2e-16 ***\n## therapyT1          -0.301      2.527   -0.12    0.906    \n## therapyT2          -4.501      2.527   -1.78    0.080 .  \n## medFD1             -2.701      2.527   -1.07    0.289    \n## medFD2             -4.201      2.527   -1.66    0.102    \n## medFD3             -2.301      2.527   -0.91    0.366    \n## therapyT1:medFD1   -8.998      3.573   -2.52    0.014 *  \n## therapyT2:medFD1   -3.899      3.573   -1.09    0.280    \n## therapyT1:medFD2  -17.199      3.573   -4.81  1.0e-05 ***\n## therapyT2:medFD2   -4.998      3.573   -1.40    0.167    \n## therapyT1:medFD3  -28.599      3.573   -8.00  4.8e-11 ***\n## therapyT2:medFD3  -10.699      3.573   -2.99    0.004 ** \n## ---\n## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 \n## \n## Residual standard error: 4.38 on 60 degrees of freedom\n## Multiple R-squared: 0.843,   Adjusted R-squared: 0.815 \n## F-statistic: 29.4 on 11 and 60 DF,  p-value: &lt;2e-16\n</code></pre>\n\n<pre><code class=\"r\">testFactors(mod.boik, levels = list(therapy = c(&quot;T1&quot;, &quot;control&quot;), medF = &quot;placebo&quot;), \n    adjustment = &quot;none&quot;)$terms[[&quot;(Intercept)&quot;]]$test\n</code></pre>\n\n<pre><code>## Linear hypothesis test\n## \n## Hypothesis:\n## therapyT1 = 0\n## \n## Model 1: restricted model\n## Model 2: edr ~ therapy * medF\n## \n##   Res.Df  RSS Df Sum of Sq    F Pr(&gt;F)\n## 1     61 1149                         \n## 2     60 1149  1     0.272 0.01   0.91\n</code></pre>\n\n<pre><code class=\"r\">testFactors(mod.boik, levels = list(therapy = c(&quot;T2&quot;, &quot;control&quot;), medF = &quot;placebo&quot;), \n    adjustment = &quot;none&quot;)$terms[[&quot;(Intercept)&quot;]]$test\n</code></pre>\n\n<pre><code>## Linear hypothesis test\n## \n## Hypothesis:\n## therapyT2 = 0\n## \n## Model 1: restricted model\n## Model 2: edr ~ therapy * medF\n## \n##   Res.Df  RSS Df Sum of Sq    F Pr(&gt;F)  \n## 1     61 1210                           \n## 2     60 1149  1      60.8 3.17   0.08 .\n## ---\n## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1\n</code></pre>\n\n<pre><code class=\"r\">testFactors(mod.boik, levels = list(medF = c(&quot;D1&quot;, &quot;placebo&quot;), therapy = &quot;control&quot;), \n    adjustment = &quot;none&quot;)$terms[[&quot;(Intercept)&quot;]]$test\n</code></pre>\n\n<pre><code>## Linear hypothesis test\n## \n## Hypothesis:\n## medFD1 = 0\n## \n## Model 1: restricted model\n## Model 2: edr ~ therapy * medF\n## \n##   Res.Df  RSS Df Sum of Sq    F Pr(&gt;F)\n## 1     61 1171                         \n## 2     60 1149  1      21.9 1.14   0.29\n</code></pre>\n\n<pre><code class=\"r\">testFactors(mod.boik, levels = list(medF = c(&quot;D2&quot;, &quot;placebo&quot;), therapy = &quot;control&quot;), \n    adjustment = &quot;none&quot;)$terms[[&quot;(Intercept)&quot;]]$test\n</code></pre>\n\n<pre><code>## Linear hypothesis test\n## \n## Hypothesis:\n## medFD2 = 0\n## \n## Model 1: restricted model\n## Model 2: edr ~ therapy * medF\n## \n##   Res.Df  RSS Df Sum of Sq    F Pr(&gt;F)\n## 1     61 1202                         \n## 2     60 1149  1      52.9 2.76    0.1\n</code></pre>\n\n<pre><code class=\"r\"># D3 versus placebo in control group.\ntestFactors(mod.boik, levels = list(medF = c(&quot;D3&quot;, &quot;placebo&quot;), therapy = &quot;control&quot;), \n    adjustment = &quot;none&quot;)$terms[[&quot;(Intercept)&quot;]]$adjusted.values\n</code></pre>\n\n<pre><code>##        [,1]\n## [1,] -2.301\n</code></pre>\n\n<pre><code class=\"r\">testFactors(mod.boik, levels = list(medF = c(&quot;D3&quot;, &quot;placebo&quot;), therapy = &quot;control&quot;), \n    adjustment = &quot;none&quot;)$terms[[&quot;(Intercept)&quot;]]$test\n</code></pre>\n\n<pre><code>## Linear hypothesis test\n## \n## Hypothesis:\n## medFD3 = 0\n## \n## Model 1: restricted model\n## Model 2: edr ~ therapy * medF\n## \n##   Res.Df  RSS Df Sum of Sq    F Pr(&gt;F)\n## 1     61 1165                         \n## 2     60 1149  1      15.9 0.83   0.37\n</code></pre>\n\n<pre><code class=\"r\"># match the meanInteractions data.frame\nboik.means[10, 3] - boik.means[1, 3]\n</code></pre>\n\n<pre><code>## [1] -2.301\n</code></pre>\n\n<h2><strong>testInteractions()</strong> can compute pairwise contrasts very fluidly <strong>BUT</strong></h2>\n\n<p>First remember that the testInteraction must used orthonomal contrasts (default.contrasts=c(&quot;contr.sum&quot;,&quot;contr.poly&quot;)).\nBelow, despites the fact that all pairwise combinations were performed, the adjusted means don&#39;t correspond \nstraightforwardly  to the &#39;classic&#39; all pairwise group differences</p>\n\n<pre><code class=\"r\">testInteractions(mod.boik, pairwise = &quot;therapy&quot;, across = &quot;medF&quot;, adjustment = &quot;none&quot;)\n</code></pre>\n\n<pre><code>## F Test: \n## P-value adjustment method: none\n##            medF1 medF2 medF3 Df Sum of Sq     F  Pr(&gt;F)    \n## control-T1 -28.6 -19.6 -11.4  3      1332 23.19 4.3e-10 ***\n## control-T2 -10.7  -6.8  -5.7  3       176  3.06   0.035 *  \n##      T1-T2  17.9  12.8   5.7  3       557  9.69 2.6e-05 ***\n## Residuals                    60      1149                  \n## ---\n## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1\n</code></pre>\n\n<p>It you&#39;re in hurry, you could tweak the call, by changing the default contrasts, <strong>BUT THEN THE F GLOBAL TEST ARE NOT MEANINGFUL ANYMORE</strong>\nSo don&#39;t do that except if you know what you are doing.</p>\n\n<pre><code class=\"r\"># !!! THE F TEST IN EACH ROW ARE NOT MEANINGFUL\n# -----------------------------------------------------------------------------------------------\ntestInteractions(mod.boik, pairwise = &quot;therapy&quot;, across = &quot;medF&quot;, adjustment = &quot;none&quot;, \n    default.contrasts = c(&quot;contr.treatment&quot;, &quot;contr.poly&quot;))\n</code></pre>\n\n<pre><code>## Warning: Contrasts are not orthogonal for factor(s): therapy\n</code></pre>\n\n<pre><code>## Warning: Contrasts are not orthogonal for factor(s): therapy\n</code></pre>\n\n<pre><code>## Warning: Contrasts are not orthogonal for factor(s): therapy\n</code></pre>\n\n<pre><code>## F Test: \n## P-value adjustment method: none\n##            medF1 medF2 medF3 Df Sum of Sq    F Pr(&gt;F)    \n## control-T1   9.3  17.5  28.9  3      3684 64.1 &lt;2e-16 ***\n## control-T2   8.4   9.5  15.2  3      1176 20.5  3e-09 ***\n##      T1-T2  -0.9  -8.0 -13.7  3       757 13.2  1e-06 ***\n## Residuals                    60      1149                \n## ---\n## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1\n</code></pre>\n\n<pre><code class=\"r\">\ntestFactors(mod.boik, levels = list(therapy = c(&quot;T1&quot;, &quot;T2&quot;), medF = &quot;D1&quot;), adjustment = &quot;none&quot;)$terms[[&quot;(Intercept)&quot;]]$adjusted.values\n</code></pre>\n\n<pre><code>##         [,1]\n## [1,] -0.8987\n</code></pre>\n\n<pre><code class=\"r\">testFactors(mod.boik, levels = list(therapy = c(&quot;T1&quot;, &quot;T2&quot;), medF = &quot;D2&quot;), adjustment = &quot;none&quot;)$terms[[&quot;(Intercept)&quot;]]$adjusted.values\n</code></pre>\n\n<pre><code>##      [,1]\n## [1,]   -8\n</code></pre>\n\n<h2>testInteractions() and the <strong>custom</strong> argument.</h2>\n\n<p>First, as ususal testInteractions() makes calls to testFactors. Without any arguments specified, it does the folowing default comparisons.</p>\n\n<pre><code class=\"r\">testInteractions(mod.boik, adjustment = &quot;none&quot;)\n</code></pre>\n\n<pre><code>## F Test: \n## P-value adjustment method: none\n##                         Value Df Sum of Sq     F  Pr(&gt;F)    \n## control-T1 : placebo-D1  -9.0  1       121  6.34 0.01448 *  \n## control-T2 : placebo-D1  -3.9  1        23  1.19 0.27960    \n##      T1-T2 : placebo-D1   5.1  1        39  2.04 0.15874    \n## control-T1 : placebo-D2 -17.2  1       444 23.17 1.0e-05 ***\n## control-T2 : placebo-D2  -5.0  1        37  1.96 0.16699    \n##      T1-T2 : placebo-D2  12.2  1       223 11.66 0.00115 ** \n## control-T1 : placebo-D3 -28.6  1      1227 64.07 4.8e-11 ***\n## control-T2 : placebo-D3 -10.7  1       172  8.97 0.00399 ** \n##      T1-T2 : placebo-D3  17.9  1       481 25.10 5.1e-06 ***\n## control-T1 :      D1-D2  -8.2  1       101  5.27 0.02523 *  \n## control-T2 :      D1-D2  -1.1  1         2  0.09 0.75929    \n##      T1-T2 :      D1-D2   7.1  1        76  3.95 0.05145 .  \n## control-T1 :      D1-D3 -19.6  1       576 30.10 8.7e-07 ***\n## control-T2 :      D1-D3  -6.8  1        69  3.62 0.06181 .  \n##      T1-T2 :      D1-D3  12.8  1       246 12.84 0.00068 ***\n## control-T1 :      D2-D3 -11.4  1       195 10.18 0.00226 ** \n## control-T2 :      D2-D3  -5.7  1        49  2.55 0.11587    \n##      T1-T2 :      D2-D3   5.7  1        49  2.55 0.11590    \n## Residuals                     60      1149                  \n## ---\n## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1\n</code></pre>\n\n<pre><code class=\"r\">testFactors(mod.boik, levels = list(therapy = c(&quot;T1&quot;, &quot;T2&quot;), medF = c(&quot;D1&quot;, \n    &quot;D2&quot;)), adjustment = &quot;none&quot;)$terms[[&quot;(Intercept)&quot;]]\n</code></pre>\n\n<pre><code>## $numeric.variables\n## [1] &quot;(Intercept)&quot;\n## \n## $factor.variables\n## character(0)\n## \n## $hypothesis.matrix\n##      (Intercept) therapyT1 therapyT2 medFD1 medFD2 medFD3 therapyT1:medFD1\n## [1,]           0         0         0      0      0      0                1\n##      therapyT2:medFD1 therapyT1:medFD2 therapyT2:medFD2 therapyT1:medFD3\n## [1,]               -1               -1                1                0\n##      therapyT2:medFD3\n## [1,]                0\n## \n## $adjusted.values\n##       [,1]\n## [1,] 7.101\n## \n## $test\n## Linear hypothesis test\n## \n## Hypothesis:\n## therapyT1:medFD1 - therapyT2:medFD1 - therapyT1:medFD2  + therapyT2:medFD2 = 0\n## \n## Model 1: restricted model\n## Model 2: edr ~ therapy * medF\n## \n##   Res.Df  RSS Df Sum of Sq    F Pr(&gt;F)  \n## 1     61 1225                           \n## 2     60 1149  1      75.6 3.95  0.051 .\n## ---\n## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1\n</code></pre>\n\n<pre><code class=\"r\"># But We can compare the calculations and see how testInteraction calls\n# testFactors()\ntestInteractions(mod.boik, adjustment = &quot;none&quot;)[12, ]\n</code></pre>\n\n<pre><code>## F Test: \n## P-value adjustment method: none\n##                         Value Df Sum of Sq    F Pr(&gt;F)  \n##      T1-T2 :      D1-D2   7.1  1      75.6 3.95  0.051 .\n## ---\n## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1\n</code></pre>\n\n<pre><code class=\"r\">testFactors(mod.boik, levels = list(therapy = c(&quot;T1&quot;, &quot;T2&quot;), medF = c(&quot;D1&quot;, \n    &quot;D2&quot;)), adjustment = &quot;none&quot;)$terms[[&quot;(Intercept)&quot;]]$adjusted.values\n</code></pre>\n\n<pre><code>##       [,1]\n## [1,] 7.101\n</code></pre>\n\n<pre><code class=\"r\">testFactors(mod.boik, levels = list(therapy = c(&quot;T1&quot;, &quot;T2&quot;), medF = c(&quot;D1&quot;, \n    &quot;D2&quot;)), adjustment = &quot;none&quot;)$terms[[&quot;(Intercept)&quot;]]$test[&quot;Pr(&gt;F)&quot;]\n</code></pre>\n\n<pre><code>##   Pr(&gt;F)  \n## 1         \n## 2  0.051 .\n## ---\n## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1\n</code></pre>\n\n<p>We can build custom contrast matrices. The code is directly inspired from testFactors() one.</p>\n\n<pre><code class=\"r\">faclist &lt;- lapply(Boik[, 1:2], levels)\nfaclist\n</code></pre>\n\n<pre><code>## $therapy\n## [1] &quot;control&quot; &quot;T1&quot;      &quot;T2&quot;     \n## \n## $medication\n## [1] &quot;placebo&quot; &quot;D1&quot;      &quot;D2&quot;      &quot;D3&quot;\n</code></pre>\n\n<pre><code class=\"r\">facmat.sum &lt;- lapply(faclist, contr.sum)  # default contr.sum matrices used by testFactors()\nfacmat.sum\n</code></pre>\n\n<pre><code>## $therapy\n##         [,1] [,2]\n## control    1    0\n## T1         0    1\n## T2        -1   -1\n## \n## $medication\n##         [,1] [,2] [,3]\n## placebo    1    0    0\n## D1         0    1    0\n## D2         0    0    1\n## D3        -1   -1   -1\n</code></pre>\n\n<pre><code class=\"r\">T1.T2.vs.Placebo.D3 &lt;- list(therapy = facmat.sum$therapy[, 2, drop = F], medF = facmat.sum$medication[, \n    1, drop = F])\nT1.T2.vs.Placebo.D3\n</code></pre>\n\n<pre><code>## $therapy\n##         [,1]\n## control    0\n## T1         1\n## T2        -1\n## \n## $medF\n##         [,1]\n## placebo    1\n## D1         0\n## D2         0\n## D3        -1\n</code></pre>\n\n<pre><code class=\"r\">testInteractions(mod.boik, custom = T1.T2.vs.Placebo.D3, adjustment = &quot;none&quot;)\n</code></pre>\n\n<pre><code>## F Test: \n## P-value adjustment method: none\n##                  Value Df Sum of Sq    F  Pr(&gt;F)    \n## therapy1 : medF1  17.9  1       481 25.1 5.1e-06 ***\n## Residuals              60      1149                 \n## ---\n## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1\n</code></pre>\n\n<pre><code class=\"r\">testInteractions(mod.boik, custom = T1.T2.vs.Placebo.D3, adjustment = &quot;none&quot;)$Value\n</code></pre>\n\n<pre><code>## [1] 17.9   NA\n</code></pre>\n\n<pre><code class=\"r\">testInteractions(mod.boik, custom = T1.T2.vs.Placebo.D3, adjustment = &quot;none&quot;)[[&quot;Pr(&gt;F)&quot;]]\n</code></pre>\n\n<pre><code>## [1] 5.102e-06        NA\n</code></pre>\n\n<h2>Hypothesis matrix  (from testFactors() calls) can be reinjected  in the glht framework.</h2>\n\n<pre><code class=\"r\">K1 &lt;- summary(testFactors(mod.boik, levels = list(therapy = c(&quot;T1&quot;, &quot;T2&quot;), medF = &quot;D2&quot;), \n    adjustment = &quot;none&quot;))\nK2 &lt;- summary(testFactors(mod.boik, levels = list(therapy = c(&quot;T1&quot;, &quot;control&quot;), \n    medF = &quot;placebo&quot;), adjustment = &quot;none&quot;))  # This is a default contrast (compute in summary.lm and confint.lm)\nK &lt;- rbind(K1$hypothesis.matrix, lfinfct = K2$hypothesis.matrix)\nrow.names(K) &lt;- c(&quot;T1.vs.T2.in.D2&quot;, &quot;T1.vs.control.in.placebo&quot;)\nset.seed(1)\n# The contrast matrix extracted from the testFactors result can be used in\n# place\nset.seed(1)\nglht.2 &lt;- glht(mod.boik, linfct = as.matrix(K))\n# use glht to compute user defined contrasts with the benefit of joint\n# confidence interval estimates and multiple testing correction.\nsummary(glht.2)\n</code></pre>\n\n<pre><code>## \n##   Simultaneous Tests for General Linear Hypotheses\n## \n## Fit: lm(formula = edr ~ therapy * medF, data = Boik)\n## \n## Linear Hypotheses:\n##                               Estimate Std. Error t value Pr(&gt;|t|)   \n## T1.vs.T2.in.D2 == 0             -8.000      2.527   -3.17   0.0048 **\n## T1.vs.control.in.placebo == 0   -0.301      2.527   -0.12   0.9910   \n## ---\n## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 \n## (Adjusted p values reported -- single-step method)\n</code></pre>\n\n<pre><code class=\"r\">confint(glht.2)\n</code></pre>\n\n<pre><code>## \n##   Simultaneous Confidence Intervals\n## \n## Fit: lm(formula = edr ~ therapy * medF, data = Boik)\n## \n## Quantile = 2.292\n## 95% family-wise confidence level\n##  \n## \n## Linear Hypotheses:\n##                               Estimate lwr     upr    \n## T1.vs.T2.in.D2 == 0            -8.000  -13.791  -2.208\n## T1.vs.control.in.placebo == 0  -0.301   -6.092   5.491\n</code></pre>\n\n<p>These result are <em>obviously</em> different from the ones obtained with univariate methods with no correction for multiple testing.</p>\n\n<pre><code class=\"r\">mod.boik\n</code></pre>\n\n<pre><code>## \n## Call:\n## lm(formula = edr ~ therapy * medF, data = Boik)\n## \n## Coefficients:\n##      (Intercept)         therapyT1         therapyT2            medFD1  \n##           50.200            -0.301            -4.501            -2.701  \n##           medFD2            medFD3  therapyT1:medFD1  therapyT2:medFD1  \n##           -4.201            -2.301            -8.998            -3.899  \n## therapyT1:medFD2  therapyT2:medFD2  therapyT1:medFD3  therapyT2:medFD3  \n##          -17.199            -4.998           -28.599           -10.699\n</code></pre>\n\n<pre><code class=\"r\">confint(mod.boik)[2, ]  # This is &#39;T1.vs.control.in.placebo&#39; default contrast (computed in summary.lm and confint.lm)\n</code></pre>\n\n<pre><code>##  2.5 % 97.5 % \n## -5.355  4.753\n</code></pre>\n\n<h2>Obtain non corrected for multiple testing  p-values and univariate confidence intervals with glht</h2>\n\n<p>There is unfortunately, no <strong>confint</strong> method associated with testFactor results. But you can reproduce univariate confidence intervals with <strong>confint( mod,calpha = univariate_calpha())</strong>method on glht objects obtained with <strong>test = adjusted(type = &quot;none&quot;)</strong></p>\n\n<pre><code class=\"r\">glht.2.s &lt;- summary(glht.2, test = adjusted(type = &quot;none&quot;))\nglht.2.s\n</code></pre>\n\n<pre><code>## \n##   Simultaneous Tests for General Linear Hypotheses\n## \n## Fit: lm(formula = edr ~ therapy * medF, data = Boik)\n## \n## Linear Hypotheses:\n##                               Estimate Std. Error t value Pr(&gt;|t|)   \n## T1.vs.T2.in.D2 == 0             -8.000      2.527   -3.17   0.0024 **\n## T1.vs.control.in.placebo == 0   -0.301      2.527   -0.12   0.9056   \n## ---\n## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 \n## (Adjusted p values reported -- none method)\n</code></pre>\n\n<pre><code class=\"r\">glht.2.s$test$coefficients\n</code></pre>\n\n<pre><code>##           T1.vs.T2.in.D2 T1.vs.control.in.placebo \n##                  -7.9998                  -0.3008\n</code></pre>\n\n<pre><code class=\"r\">ghlt2.confint.u &lt;- confint(glht.2.s, calpha = univariate_calpha())\nghlt2.confint.u$confint\n</code></pre>\n\n<pre><code>##                          Estimate     lwr    upr\n## T1.vs.T2.in.D2            -7.9998 -13.054 -2.946\n## T1.vs.control.in.placebo  -0.3008  -5.355  4.753\n## attr(,&quot;conf.level&quot;)\n## [1] 0.95\n## attr(,&quot;calpha&quot;)\n## [1] 2\n</code></pre>\n\n<pre><code class=\"r\">\nconfint(mod.boik)[2, ] == ghlt2.confint.u$confint[2, 2:3]\n</code></pre>\n\n<pre><code>##  2.5 % 97.5 % \n##   TRUE   TRUE\n</code></pre>\n\n<p>This <em>trick</em> is used  because <strong>confint</strong> method  is not dispatched with testFactor results.</p>\n\n<pre><code class=\"r\">fact.boik &lt;- testFactors(mod.boik, levels = list(therapy = c(&quot;T1&quot;, &quot;T2&quot;), medF = &quot;D2&quot;), \n    adjustment = &quot;none&quot;)\nconfint(fact.boik)\n</code></pre>\n\n<pre><code>## Error: no applicable method for &#39;vcov&#39; applied to an object of class\n## &quot;c(&#39;testFactors.lm&#39;, &#39;testFactors&#39;)&quot;\n</code></pre>\n","level":"","title":"","content":"<pre><code class=\"r\">library(multcomp)\nlibrary(car)\nlibrary(effects)\nlibrary(phia)\n</code></pre>\n\n<h1>Combine car, multcomp and phia to perform smarter linear modeling.</h1>\n\n<p>These examples have been largely inpired by Helios De Rosario-Martinez <helios.derosario at ibv.upv.es> <a href=\"http://cran.r-project.org/web/packages/phia/vignettes/phia.pdf\">vignette</a> from the <a href=\"http://cran.r-project.org/web/packages/phia/index.html\">phia</a>. I recommend as well as the reading of <a href=\"http://cran.r-project.org/web/packages/multcomp/\">mutlcomp</a> textbook: <a href=\"http://www.amazon.co.uk/gp/product/1584885742/\">Multiple Comparisons Using R</a> from Multiple Comparisons from Torsten Hothorn, Frank Bretz and Peter Westfall. The <a href=\"http://socserv.socsci.mcmaster.ca/jfox/Books/Companion/index.html%20ressource%20is%20obviously%20a%20place%20to%20be%20:-\">car</a>.</p>\n\n<p>.The Boik data set from <strong>phia</strong> is based on the hypothetical example used by R.J. Boik (1979) to explain the analysis of interaction contrasts. It represents the electrodermal response of 72 students complaining of hemophobia, treated with different fear reduction therapies and doses of antianxiety medication, in a balanced factorial design. The response variable <strong>edr</strong> is modeled with two factors <strong>therapy</strong>, with levels control, T1, and \nT2 and <strong>medication</strong>, with levels placebo, D1, D2, and D3 in interaction.</p>\n\n<h2>Introduction</h2>\n\n<pre><code class=\"r\">some(Boik)\n</code></pre>\n\n<pre><code>##    therapy medication   edr\n## 7  control         D1 45.59\n## 12 control         D1 44.75\n## 13 control         D2 47.64\n## 16 control         D2 44.86\n## 20 control         D3 50.92\n## 36      T1         D1 44.24\n## 44      T1         D3 11.61\n## 50      T2    placebo 40.25\n## 53      T2    placebo 45.22\n## 56      T2         D1 40.49\n</code></pre>\n\n<pre><code class=\"r\">table(Boik[, 1:2])\n</code></pre>\n\n<pre><code>##          medication\n## therapy   placebo D1 D2 D3\n##   control       6  6  6  6\n##   T1            6  6  6  6\n##   T2            6  6  6  6\n</code></pre>\n\n<p>I chose to tweak a bit this data set to avoid using the medication as an ordered factor to ease my interpretation \nof linear models outputs.</p>\n\n<pre><code class=\"r\">Boik$medF &lt;- factor(as.character(Boik$medication), levels = c(&quot;placebo&quot;, &quot;D1&quot;, &quot;D2&quot;, &quot;D3&quot;))\nlevels(Boik$medF)\n</code></pre>\n\n<pre><code>## [1] &quot;placebo&quot; &quot;D1&quot;      &quot;D2&quot;      &quot;D3&quot;\n</code></pre>\n\n<h2>Fit two models with interaction and main effects only</h2>\n\n<pre><code class=\"r\">mod.boik &lt;- lm(edr ~ therapy * medF, data = Boik)\nmod.boik.M &lt;- lm(edr ~ therapy + medF, data = Boik)\nsummary(mod.boik)\n</code></pre>\n\n<pre><code>## \n## Call:\n## lm(formula = edr ~ therapy * medF, data = Boik)\n## \n## Residuals:\n##     Min      1Q  Median      3Q     Max \n## -11.358  -1.857   0.307   2.717   7.714 \n## \n## Coefficients:\n##                  Estimate Std. Error t value Pr(&gt;|t|)    \n## (Intercept)        50.200      1.787   28.10  &lt; 2e-16 ***\n## therapyT1          -0.301      2.527   -0.12    0.906    \n## therapyT2          -4.501      2.527   -1.78    0.080 .  \n## medFD1             -2.701      2.527   -1.07    0.289    \n## medFD2             -4.201      2.527   -1.66    0.102    \n## medFD3             -2.301      2.527   -0.91    0.366    \n## therapyT1:medFD1   -8.998      3.573   -2.52    0.014 *  \n## therapyT2:medFD1   -3.899      3.573   -1.09    0.280    \n## therapyT1:medFD2  -17.199      3.573   -4.81  1.0e-05 ***\n## therapyT2:medFD2   -4.998      3.573   -1.40    0.167    \n## therapyT1:medFD3  -28.599      3.573   -8.00  4.8e-11 ***\n## therapyT2:medFD3  -10.699      3.573   -2.99    0.004 ** \n## ---\n## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 \n## \n## Residual standard error: 4.38 on 60 degrees of freedom\n## Multiple R-squared: 0.843,   Adjusted R-squared: 0.815 \n## F-statistic: 29.4 on 11 and 60 DF,  p-value: &lt;2e-16\n</code></pre>\n\n<pre><code class=\"r\">Anova(mod.boik)\n</code></pre>\n\n<pre><code>## Anova Table (Type II tests)\n## \n## Response: edr\n##              Sum Sq Df F value  Pr(&gt;F)    \n## therapy        2444  2    63.8 1.4e-15 ***\n## medF           2371  3    41.3 1.3e-14 ***\n## therapy:medF   1376  6    12.0 8.5e-09 ***\n## Residuals      1149 60                    \n## ---\n## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1\n</code></pre>\n\n<h2>Use allEffects(), and interactionMeans() to compute cells and marginal means</h2>\n\n<pre><code class=\"r\">boik.means &lt;- interactionMeans(mod.boik)\nboik.means\n</code></pre>\n\n<pre><code>##    therapy    medF adjusted mean\n## 1  control placebo          50.2\n## 2       T1 placebo          49.9\n## 3       T2 placebo          45.7\n## 4  control      D1          47.5\n## 5       T1      D1          38.2\n## 6       T2      D1          39.1\n## 7  control      D2          46.0\n## 8       T1      D2          28.5\n## 9       T2      D2          36.5\n## 10 control      D3          47.9\n## 11      T1      D3          19.0\n## 12      T2      D3          32.7\n</code></pre>\n\n<pre><code class=\"r\">interactionMeans(mod.boik, factors = &quot;therapy&quot;)\n</code></pre>\n\n<pre><code>##   therapy adjusted mean\n## 1 control          47.9\n## 2      T1          33.9\n## 3      T2          38.5\n</code></pre>\n\n<pre><code class=\"r\">\ninteractionMeans(mod.boik, factors = &quot;medF&quot;)\n</code></pre>\n\n<pre><code>##      medF adjusted mean\n## 1 placebo          48.6\n## 2      D1          41.6\n## 3      D2          37.0\n## 4      D3          33.2\n</code></pre>\n\n<p>Several type of interaction plots  are available to visualise the &#39;interaction effect&#39;</p>\n\n<pre><code class=\"r\">plot(boik.means, multiple = TRUE)\n\n\nplot(allEffects(mod.boik))\n</code></pre>\n\n<p><img src=\"assets/fig/unnamed-chunk-6.png\" alt=\"plot of chunk unnamed-chunk-6\"> </p>\n\n<h2>The phia package is remarkebly designed to compute  various contrasts of interests using testInteractions() function.</h2>\n\n<p>The columns medication1, . . . medication3 in the resulting table contain the value of the three\northogonal contrasts across the levels of medication, for each level of therapy (the only fixed factor\nin this example). In addition a F test (actually a global F test) is performed for each level of therapy</p>\n\n<pre><code class=\"r\">testInteractions(mod.boik, fixed = &quot;therapy&quot;, across = &quot;medF&quot;, adjustment = &quot;none&quot;)\n</code></pre>\n\n<pre><code>## F Test: \n## P-value adjustment method: none\n##           medF1 medF2 medF3 Df Sum of Sq     F  Pr(&gt;F)    \n## control     2.3  -0.4  -1.9  3        54  0.95    0.42    \n##      T1    30.9  19.2   9.5  3      3154 54.90 &lt; 2e-16 ***\n##      T2    13.0   6.4   3.8  3       539  9.38 3.6e-05 ***\n## Residuals                   60      1149                  \n## ---\n## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1\n</code></pre>\n\n<p>Behind the scene, <strong>testInteractions()</strong> calls <strong>testFactors()</strong>. The ones corresponding to the one above are detailed below.</p>\n\n<pre><code class=\"r\">con.therapy &lt;- testFactors(mod.boik, levels = list(therapy = c(&quot;control&quot;)), \n    terms.formula = ~medF, adjustment = &quot;none&quot;)\n</code></pre>\n\n<pre><code class=\"r\">testFactors(mod.boik, levels = list(therapy = c(&quot;T1&quot;)), terms.formula = ~medF, \n    adjustment = &quot;none&quot;)\ntestFactors(mod.boik, levels = list(therapy = c(&quot;T2&quot;)), terms.formula = ~medF, \n    adjustment = &quot;none&quot;)\n</code></pre>\n\n<p>The cont.therapy ob</p>\n\n<pre><code class=\"r\">con.therapy\n</code></pre>\n\n<pre><code>## \n## Call: blogify(model = &quot;.&quot;) \n## \n## Term (Intercept) \n## \n## Adjusted mean:\n##      \n## 47.9 \n## \n## Linear hypothesis test\n## \n## Hypothesis:\n## (Intercept)  + 0.25 medFD1  + 0.25 medFD2  + 0.25 medFD3 = 0\n## \n## Model 1: restricted model\n## Model 2: edr ~ therapy * medF\n## \n##   Res.Df   RSS Df Sum of Sq    F Pr(&gt;F)    \n## 1     61 56214                             \n## 2     60  1149  1     55065 2875 &lt;2e-16 ***\n## ---\n## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 \n## ------\n## \n## Term medF \n## \n## Adjusted mean at contrasts of medF:\n##   medF1   medF2   medF3 \n##  2.3006 -0.4008 -1.8999 \n## \n## Linear hypothesis test\n## \n## Hypothesis:\n## - medFD3 = 0\n## medFD1 - medFD3 = 0\n## medFD2 - medFD3 = 0\n## \n## Model 1: restricted model\n## Model 2: edr ~ therapy * medF\n## \n##   Res.Df  RSS Df Sum of Sq     F Pr(&gt;F)\n## 1     63 1203                          \n## 2     60 1149  3     54.38 0.947  0.424\n## ------\n</code></pre>\n\n<pre><code class=\"r\">names(con.therapy)\n</code></pre>\n\n<pre><code>## [1] &quot;call&quot;             &quot;model.call&quot;       &quot;levels&quot;          \n## [4] &quot;factor.contrasts&quot; &quot;covariates&quot;       &quot;terms&quot;\n</code></pre>\n\n<p>It contains notably the hypothesis matrix done for a <strong>global F test</strong> that test the non equality of the edr value for the designated therapy level across levels of medication. </p>\n\n<pre><code class=\"r\">con.therapy$terms$`(Intercept)`$adjusted.values\n</code></pre>\n\n<pre><code>##      [,1]\n## [1,] 47.9\n</code></pre>\n\n<pre><code class=\"r\">con.therapy$terms$medF$adjusted.values\n</code></pre>\n\n<pre><code>##          [,1]\n## medF1  2.3006\n## medF2 -0.4008\n## medF3 -1.8999\n</code></pre>\n\n<pre><code class=\"r\">con.therapy$terms$medF$hypothesis.matrix\n</code></pre>\n\n<pre><code>##       (Intercept) therapyT1 therapyT2 medFD1 medFD2 medFD3\n## medF1           0         0         0      0      0     -1\n## medF2           0         0         0      1      0     -1\n## medF3           0         0         0      0      1     -1\n##       therapyT1:medFD1 therapyT2:medFD1 therapyT1:medFD2 therapyT2:medFD2\n## medF1                0                0                0                0\n## medF2                0                0                0                0\n## medF3                0                0                0                0\n##       therapyT1:medFD3 therapyT2:medFD3\n## medF1                0                0\n## medF2                0                0\n## medF3                0                0\n</code></pre>\n\n<p>The default contrasts definition used in the testInteractions() and testFactors() are takken from their default.contrasts=c(&quot;contr.sum&quot;,&quot;contr.poly&quot;), which is usually not the ones that were used by default in R (see below and the <strong>mod.boik</strong> model).\nThis is very  <strong>important</strong> as it ensures that F tests and global F tests are meaningfull.</p>\n\n<pre><code class=\"r\">options(&quot;contrasts&quot;)\n</code></pre>\n\n<pre><code>## $contrasts\n##         unordered           ordered \n## &quot;contr.treatment&quot;      &quot;contr.poly&quot;\n</code></pre>\n\n<pre><code class=\"r\">contr.sum(levels(Boik$medF))\n</code></pre>\n\n<pre><code>##         [,1] [,2] [,3]\n## placebo    1    0    0\n## D1         0    1    0\n## D2         0    0    1\n## D3        -1   -1   -1\n</code></pre>\n\n<pre><code class=\"r\">contr.treatment(levels(Boik$medF))\n</code></pre>\n\n<pre><code>##         D1 D2 D3\n## placebo  0  0  0\n## D1       1  0  0\n## D2       0  1  0\n## D3       0  0  1\n</code></pre>\n\n<p>The therapy adjusted.values are computed using the folowing algebra.</p>\n\n<pre><code class=\"r\"># using the hypothesis matrix\ncon.therapy$terms$medF$hypothesis.matrix %*% coef(mod.boik)\n</code></pre>\n\n<pre><code>##          [,1]\n## medF1  2.3006\n## medF2 -0.4008\n## medF3 -1.8999\n</code></pre>\n\n<pre><code class=\"r\"># which correponds to a contrasts sum options\nt(contr.sum(levels(Boik$medF))[-c(1), ]) %*% coef(mod.boik)[c(4:6)]\n</code></pre>\n\n<pre><code>##         [,1]\n## [1,]  2.3006\n## [2,] -0.4008\n## [3,] -1.8999\n</code></pre>\n\n<pre><code class=\"r\"># the default contrast (the one used in the model and summary output) are\n# reprouced below\nt(contr.treatment(levels(Boik$medF))[-c(1), ]) %*% coef(mod.boik)[c(2:4)]\n</code></pre>\n\n<pre><code>##       [,1]\n## D1 -0.3008\n## D2 -4.5012\n## D3 -2.7014\n</code></pre>\n\n<h1>How to obtain the same results with different functions</h1>\n\n<p>Especially, how to reproduce classic univariates results.</p>\n\n<h2>Obtain Anova global F interaction test with <strong>linearHypothesis()</strong>.</h2>\n\n<pre><code class=\"r\">coefs &lt;- coefficients(mod.boik)\ncoefs\n</code></pre>\n\n<pre><code>##      (Intercept)        therapyT1        therapyT2           medFD1 \n##          50.2004          -0.3008          -4.5012          -2.7014 \n##           medFD2           medFD3 therapyT1:medFD1 therapyT2:medFD1 \n##          -4.2005          -2.3006          -8.9975          -3.8985 \n## therapyT1:medFD2 therapyT2:medFD2 therapyT1:medFD3 therapyT2:medFD3 \n##         -17.1985          -4.9984         -28.5994         -10.6990\n</code></pre>\n\n<pre><code class=\"r\">linearHypothesis(mod.boik, names(coefs)[7:12], verbose = TRUE)\n</code></pre>\n\n<pre><code>## \n## Hypothesis matrix:\n##                  (Intercept) therapyT1 therapyT2 medFD1 medFD2 medFD3\n## therapyT1:medFD1           0         0         0      0      0      0\n## therapyT2:medFD1           0         0         0      0      0      0\n## therapyT1:medFD2           0         0         0      0      0      0\n## therapyT2:medFD2           0         0         0      0      0      0\n## therapyT1:medFD3           0         0         0      0      0      0\n## therapyT2:medFD3           0         0         0      0      0      0\n##                  therapyT1:medFD1 therapyT2:medFD1 therapyT1:medFD2\n## therapyT1:medFD1                1                0                0\n## therapyT2:medFD1                0                1                0\n## therapyT1:medFD2                0                0                1\n## therapyT2:medFD2                0                0                0\n## therapyT1:medFD3                0                0                0\n## therapyT2:medFD3                0                0                0\n##                  therapyT2:medFD2 therapyT1:medFD3 therapyT2:medFD3\n## therapyT1:medFD1                0                0                0\n## therapyT2:medFD1                0                0                0\n## therapyT1:medFD2                0                0                0\n## therapyT2:medFD2                1                0                0\n## therapyT1:medFD3                0                1                0\n## therapyT2:medFD3                0                0                1\n## \n## Right-hand-side vector:\n## [1] 0 0 0 0 0 0\n## \n## Estimated linear function (hypothesis.matrix %*% coef - rhs)\n## therapyT1:medFD1 therapyT2:medFD1 therapyT1:medFD2 therapyT2:medFD2 \n##           -8.998           -3.899          -17.199           -4.998 \n## therapyT1:medFD3 therapyT2:medFD3 \n##          -28.599          -10.699\n</code></pre>\n\n<pre><code>## Linear hypothesis test\n## \n## Hypothesis:\n## therapyT1:medFD1 = 0\n## therapyT2:medFD1 = 0\n## therapyT1:medFD2 = 0\n## therapyT2:medFD2 = 0\n## therapyT1:medFD3 = 0\n## therapyT2:medFD3 = 0\n## \n## Model 1: restricted model\n## Model 2: edr ~ therapy * medF\n## \n##   Res.Df  RSS Df Sum of Sq  F  Pr(&gt;F)    \n## 1     66 2525                            \n## 2     60 1149  6      1376 12 8.5e-09 ***\n## ---\n## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1\n</code></pre>\n\n<h2>Obtain univariate linear model coefficients statistics done with <strong>summary()</strong> with <strong>testFactors()</strong></h2>\n\n<pre><code class=\"r\">summary(mod.boik)\n</code></pre>\n\n<pre><code>## \n## Call:\n## lm(formula = edr ~ therapy * medF, data = Boik)\n## \n## Residuals:\n##     Min      1Q  Median      3Q     Max \n## -11.358  -1.857   0.307   2.717   7.714 \n## \n## Coefficients:\n##                  Estimate Std. Error t value Pr(&gt;|t|)    \n## (Intercept)        50.200      1.787   28.10  &lt; 2e-16 ***\n## therapyT1          -0.301      2.527   -0.12    0.906    \n## therapyT2          -4.501      2.527   -1.78    0.080 .  \n## medFD1             -2.701      2.527   -1.07    0.289    \n## medFD2             -4.201      2.527   -1.66    0.102    \n## medFD3             -2.301      2.527   -0.91    0.366    \n## therapyT1:medFD1   -8.998      3.573   -2.52    0.014 *  \n## therapyT2:medFD1   -3.899      3.573   -1.09    0.280    \n## therapyT1:medFD2  -17.199      3.573   -4.81  1.0e-05 ***\n## therapyT2:medFD2   -4.998      3.573   -1.40    0.167    \n## therapyT1:medFD3  -28.599      3.573   -8.00  4.8e-11 ***\n## therapyT2:medFD3  -10.699      3.573   -2.99    0.004 ** \n## ---\n## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 \n## \n## Residual standard error: 4.38 on 60 degrees of freedom\n## Multiple R-squared: 0.843,   Adjusted R-squared: 0.815 \n## F-statistic: 29.4 on 11 and 60 DF,  p-value: &lt;2e-16\n</code></pre>\n\n<pre><code class=\"r\">testFactors(mod.boik, levels = list(therapy = c(&quot;T1&quot;, &quot;control&quot;), medF = &quot;placebo&quot;), \n    adjustment = &quot;none&quot;)$terms[[&quot;(Intercept)&quot;]]$test\n</code></pre>\n\n<pre><code>## Linear hypothesis test\n## \n## Hypothesis:\n## therapyT1 = 0\n## \n## Model 1: restricted model\n## Model 2: edr ~ therapy * medF\n## \n##   Res.Df  RSS Df Sum of Sq    F Pr(&gt;F)\n## 1     61 1149                         \n## 2     60 1149  1     0.272 0.01   0.91\n</code></pre>\n\n<pre><code class=\"r\">testFactors(mod.boik, levels = list(therapy = c(&quot;T2&quot;, &quot;control&quot;), medF = &quot;placebo&quot;), \n    adjustment = &quot;none&quot;)$terms[[&quot;(Intercept)&quot;]]$test\n</code></pre>\n\n<pre><code>## Linear hypothesis test\n## \n## Hypothesis:\n## therapyT2 = 0\n## \n## Model 1: restricted model\n## Model 2: edr ~ therapy * medF\n## \n##   Res.Df  RSS Df Sum of Sq    F Pr(&gt;F)  \n## 1     61 1210                           \n## 2     60 1149  1      60.8 3.17   0.08 .\n## ---\n## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1\n</code></pre>\n\n<pre><code class=\"r\">testFactors(mod.boik, levels = list(medF = c(&quot;D1&quot;, &quot;placebo&quot;), therapy = &quot;control&quot;), \n    adjustment = &quot;none&quot;)$terms[[&quot;(Intercept)&quot;]]$test\n</code></pre>\n\n<pre><code>## Linear hypothesis test\n## \n## Hypothesis:\n## medFD1 = 0\n## \n## Model 1: restricted model\n## Model 2: edr ~ therapy * medF\n## \n##   Res.Df  RSS Df Sum of Sq    F Pr(&gt;F)\n## 1     61 1171                         \n## 2     60 1149  1      21.9 1.14   0.29\n</code></pre>\n\n<pre><code class=\"r\">testFactors(mod.boik, levels = list(medF = c(&quot;D2&quot;, &quot;placebo&quot;), therapy = &quot;control&quot;), \n    adjustment = &quot;none&quot;)$terms[[&quot;(Intercept)&quot;]]$test\n</code></pre>\n\n<pre><code>## Linear hypothesis test\n## \n## Hypothesis:\n## medFD2 = 0\n## \n## Model 1: restricted model\n## Model 2: edr ~ therapy * medF\n## \n##   Res.Df  RSS Df Sum of Sq    F Pr(&gt;F)\n## 1     61 1202                         \n## 2     60 1149  1      52.9 2.76    0.1\n</code></pre>\n\n<pre><code class=\"r\"># D3 versus placebo in control group.\ntestFactors(mod.boik, levels = list(medF = c(&quot;D3&quot;, &quot;placebo&quot;), therapy = &quot;control&quot;), \n    adjustment = &quot;none&quot;)$terms[[&quot;(Intercept)&quot;]]$adjusted.values\n</code></pre>\n\n<pre><code>##        [,1]\n## [1,] -2.301\n</code></pre>\n\n<pre><code class=\"r\">testFactors(mod.boik, levels = list(medF = c(&quot;D3&quot;, &quot;placebo&quot;), therapy = &quot;control&quot;), \n    adjustment = &quot;none&quot;)$terms[[&quot;(Intercept)&quot;]]$test\n</code></pre>\n\n<pre><code>## Linear hypothesis test\n## \n## Hypothesis:\n## medFD3 = 0\n## \n## Model 1: restricted model\n## Model 2: edr ~ therapy * medF\n## \n##   Res.Df  RSS Df Sum of Sq    F Pr(&gt;F)\n## 1     61 1165                         \n## 2     60 1149  1      15.9 0.83   0.37\n</code></pre>\n\n<pre><code class=\"r\"># match the meanInteractions data.frame\nboik.means[10, 3] - boik.means[1, 3]\n</code></pre>\n\n<pre><code>## [1] -2.301\n</code></pre>\n\n<h2><strong>testInteractions()</strong> can compute pairwise contrasts very fluidly <strong>BUT</strong></h2>\n\n<p>First remember that the testInteraction must used orthonomal contrasts (default.contrasts=c(&quot;contr.sum&quot;,&quot;contr.poly&quot;)).\nBelow, despites the fact that all pairwise combinations were performed, the adjusted means don&#39;t correspond \nstraightforwardly  to the &#39;classic&#39; all pairwise group differences</p>\n\n<pre><code class=\"r\">testInteractions(mod.boik, pairwise = &quot;therapy&quot;, across = &quot;medF&quot;, adjustment = &quot;none&quot;)\n</code></pre>\n\n<pre><code>## F Test: \n## P-value adjustment method: none\n##            medF1 medF2 medF3 Df Sum of Sq     F  Pr(&gt;F)    \n## control-T1 -28.6 -19.6 -11.4  3      1332 23.19 4.3e-10 ***\n## control-T2 -10.7  -6.8  -5.7  3       176  3.06   0.035 *  \n##      T1-T2  17.9  12.8   5.7  3       557  9.69 2.6e-05 ***\n## Residuals                    60      1149                  \n## ---\n## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1\n</code></pre>\n\n<p>It you&#39;re in hurry, you could tweak the call, by changing the default contrasts, <strong>BUT THEN THE F GLOBAL TEST ARE NOT MEANINGFUL ANYMORE</strong>\nSo don&#39;t do that except if you know what you are doing.</p>\n\n<pre><code class=\"r\"># !!! THE F TEST IN EACH ROW ARE NOT MEANINGFUL\n# -----------------------------------------------------------------------------------------------\ntestInteractions(mod.boik, pairwise = &quot;therapy&quot;, across = &quot;medF&quot;, adjustment = &quot;none&quot;, \n    default.contrasts = c(&quot;contr.treatment&quot;, &quot;contr.poly&quot;))\n</code></pre>\n\n<pre><code>## Warning: Contrasts are not orthogonal for factor(s): therapy\n</code></pre>\n\n<pre><code>## Warning: Contrasts are not orthogonal for factor(s): therapy\n</code></pre>\n\n<pre><code>## Warning: Contrasts are not orthogonal for factor(s): therapy\n</code></pre>\n\n<pre><code>## F Test: \n## P-value adjustment method: none\n##            medF1 medF2 medF3 Df Sum of Sq    F Pr(&gt;F)    \n## control-T1   9.3  17.5  28.9  3      3684 64.1 &lt;2e-16 ***\n## control-T2   8.4   9.5  15.2  3      1176 20.5  3e-09 ***\n##      T1-T2  -0.9  -8.0 -13.7  3       757 13.2  1e-06 ***\n## Residuals                    60      1149                \n## ---\n## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1\n</code></pre>\n\n<pre><code class=\"r\">\ntestFactors(mod.boik, levels = list(therapy = c(&quot;T1&quot;, &quot;T2&quot;), medF = &quot;D1&quot;), adjustment = &quot;none&quot;)$terms[[&quot;(Intercept)&quot;]]$adjusted.values\n</code></pre>\n\n<pre><code>##         [,1]\n## [1,] -0.8987\n</code></pre>\n\n<pre><code class=\"r\">testFactors(mod.boik, levels = list(therapy = c(&quot;T1&quot;, &quot;T2&quot;), medF = &quot;D2&quot;), adjustment = &quot;none&quot;)$terms[[&quot;(Intercept)&quot;]]$adjusted.values\n</code></pre>\n\n<pre><code>##      [,1]\n## [1,]   -8\n</code></pre>\n\n<h2>testInteractions() and the <strong>custom</strong> argument.</h2>\n\n<p>First, as ususal testInteractions() makes calls to testFactors. Without any arguments specified, it does the folowing default comparisons.</p>\n\n<pre><code class=\"r\">testInteractions(mod.boik, adjustment = &quot;none&quot;)\n</code></pre>\n\n<pre><code>## F Test: \n## P-value adjustment method: none\n##                         Value Df Sum of Sq     F  Pr(&gt;F)    \n## control-T1 : placebo-D1  -9.0  1       121  6.34 0.01448 *  \n## control-T2 : placebo-D1  -3.9  1        23  1.19 0.27960    \n##      T1-T2 : placebo-D1   5.1  1        39  2.04 0.15874    \n## control-T1 : placebo-D2 -17.2  1       444 23.17 1.0e-05 ***\n## control-T2 : placebo-D2  -5.0  1        37  1.96 0.16699    \n##      T1-T2 : placebo-D2  12.2  1       223 11.66 0.00115 ** \n## control-T1 : placebo-D3 -28.6  1      1227 64.07 4.8e-11 ***\n## control-T2 : placebo-D3 -10.7  1       172  8.97 0.00399 ** \n##      T1-T2 : placebo-D3  17.9  1       481 25.10 5.1e-06 ***\n## control-T1 :      D1-D2  -8.2  1       101  5.27 0.02523 *  \n## control-T2 :      D1-D2  -1.1  1         2  0.09 0.75929    \n##      T1-T2 :      D1-D2   7.1  1        76  3.95 0.05145 .  \n## control-T1 :      D1-D3 -19.6  1       576 30.10 8.7e-07 ***\n## control-T2 :      D1-D3  -6.8  1        69  3.62 0.06181 .  \n##      T1-T2 :      D1-D3  12.8  1       246 12.84 0.00068 ***\n## control-T1 :      D2-D3 -11.4  1       195 10.18 0.00226 ** \n## control-T2 :      D2-D3  -5.7  1        49  2.55 0.11587    \n##      T1-T2 :      D2-D3   5.7  1        49  2.55 0.11590    \n## Residuals                     60      1149                  \n## ---\n## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1\n</code></pre>\n\n<pre><code class=\"r\">testFactors(mod.boik, levels = list(therapy = c(&quot;T1&quot;, &quot;T2&quot;), medF = c(&quot;D1&quot;, \n    &quot;D2&quot;)), adjustment = &quot;none&quot;)$terms[[&quot;(Intercept)&quot;]]\n</code></pre>\n\n<pre><code>## $numeric.variables\n## [1] &quot;(Intercept)&quot;\n## \n## $factor.variables\n## character(0)\n## \n## $hypothesis.matrix\n##      (Intercept) therapyT1 therapyT2 medFD1 medFD2 medFD3 therapyT1:medFD1\n## [1,]           0         0         0      0      0      0                1\n##      therapyT2:medFD1 therapyT1:medFD2 therapyT2:medFD2 therapyT1:medFD3\n## [1,]               -1               -1                1                0\n##      therapyT2:medFD3\n## [1,]                0\n## \n## $adjusted.values\n##       [,1]\n## [1,] 7.101\n## \n## $test\n## Linear hypothesis test\n## \n## Hypothesis:\n## therapyT1:medFD1 - therapyT2:medFD1 - therapyT1:medFD2  + therapyT2:medFD2 = 0\n## \n## Model 1: restricted model\n## Model 2: edr ~ therapy * medF\n## \n##   Res.Df  RSS Df Sum of Sq    F Pr(&gt;F)  \n## 1     61 1225                           \n## 2     60 1149  1      75.6 3.95  0.051 .\n## ---\n## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1\n</code></pre>\n\n<pre><code class=\"r\"># But We can compare the calculations and see how testInteraction calls\n# testFactors()\ntestInteractions(mod.boik, adjustment = &quot;none&quot;)[12, ]\n</code></pre>\n\n<pre><code>## F Test: \n## P-value adjustment method: none\n##                         Value Df Sum of Sq    F Pr(&gt;F)  \n##      T1-T2 :      D1-D2   7.1  1      75.6 3.95  0.051 .\n## ---\n## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1\n</code></pre>\n\n<pre><code class=\"r\">testFactors(mod.boik, levels = list(therapy = c(&quot;T1&quot;, &quot;T2&quot;), medF = c(&quot;D1&quot;, \n    &quot;D2&quot;)), adjustment = &quot;none&quot;)$terms[[&quot;(Intercept)&quot;]]$adjusted.values\n</code></pre>\n\n<pre><code>##       [,1]\n## [1,] 7.101\n</code></pre>\n\n<pre><code class=\"r\">testFactors(mod.boik, levels = list(therapy = c(&quot;T1&quot;, &quot;T2&quot;), medF = c(&quot;D1&quot;, \n    &quot;D2&quot;)), adjustment = &quot;none&quot;)$terms[[&quot;(Intercept)&quot;]]$test[&quot;Pr(&gt;F)&quot;]\n</code></pre>\n\n<pre><code>##   Pr(&gt;F)  \n## 1         \n## 2  0.051 .\n## ---\n## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1\n</code></pre>\n\n<p>We can build custom contrast matrices. The code is directly inspired from testFactors() one.</p>\n\n<pre><code class=\"r\">faclist &lt;- lapply(Boik[, 1:2], levels)\nfaclist\n</code></pre>\n\n<pre><code>## $therapy\n## [1] &quot;control&quot; &quot;T1&quot;      &quot;T2&quot;     \n## \n## $medication\n## [1] &quot;placebo&quot; &quot;D1&quot;      &quot;D2&quot;      &quot;D3&quot;\n</code></pre>\n\n<pre><code class=\"r\">facmat.sum &lt;- lapply(faclist, contr.sum)  # default contr.sum matrices used by testFactors()\nfacmat.sum\n</code></pre>\n\n<pre><code>## $therapy\n##         [,1] [,2]\n## control    1    0\n## T1         0    1\n## T2        -1   -1\n## \n## $medication\n##         [,1] [,2] [,3]\n## placebo    1    0    0\n## D1         0    1    0\n## D2         0    0    1\n## D3        -1   -1   -1\n</code></pre>\n\n<pre><code class=\"r\">T1.T2.vs.Placebo.D3 &lt;- list(therapy = facmat.sum$therapy[, 2, drop = F], medF = facmat.sum$medication[, \n    1, drop = F])\nT1.T2.vs.Placebo.D3\n</code></pre>\n\n<pre><code>## $therapy\n##         [,1]\n## control    0\n## T1         1\n## T2        -1\n## \n## $medF\n##         [,1]\n## placebo    1\n## D1         0\n## D2         0\n## D3        -1\n</code></pre>\n\n<pre><code class=\"r\">testInteractions(mod.boik, custom = T1.T2.vs.Placebo.D3, adjustment = &quot;none&quot;)\n</code></pre>\n\n<pre><code>## F Test: \n## P-value adjustment method: none\n##                  Value Df Sum of Sq    F  Pr(&gt;F)    \n## therapy1 : medF1  17.9  1       481 25.1 5.1e-06 ***\n## Residuals              60      1149                 \n## ---\n## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1\n</code></pre>\n\n<pre><code class=\"r\">testInteractions(mod.boik, custom = T1.T2.vs.Placebo.D3, adjustment = &quot;none&quot;)$Value\n</code></pre>\n\n<pre><code>## [1] 17.9   NA\n</code></pre>\n\n<pre><code class=\"r\">testInteractions(mod.boik, custom = T1.T2.vs.Placebo.D3, adjustment = &quot;none&quot;)[[&quot;Pr(&gt;F)&quot;]]\n</code></pre>\n\n<pre><code>## [1] 5.102e-06        NA\n</code></pre>\n\n<h2>Hypothesis matrix  (from testFactors() calls) can be reinjected  in the glht framework.</h2>\n\n<pre><code class=\"r\">K1 &lt;- summary(testFactors(mod.boik, levels = list(therapy = c(&quot;T1&quot;, &quot;T2&quot;), medF = &quot;D2&quot;), \n    adjustment = &quot;none&quot;))\nK2 &lt;- summary(testFactors(mod.boik, levels = list(therapy = c(&quot;T1&quot;, &quot;control&quot;), \n    medF = &quot;placebo&quot;), adjustment = &quot;none&quot;))  # This is a default contrast (compute in summary.lm and confint.lm)\nK &lt;- rbind(K1$hypothesis.matrix, lfinfct = K2$hypothesis.matrix)\nrow.names(K) &lt;- c(&quot;T1.vs.T2.in.D2&quot;, &quot;T1.vs.control.in.placebo&quot;)\nset.seed(1)\n# The contrast matrix extracted from the testFactors result can be used in\n# place\nset.seed(1)\nglht.2 &lt;- glht(mod.boik, linfct = as.matrix(K))\n# use glht to compute user defined contrasts with the benefit of joint\n# confidence interval estimates and multiple testing correction.\nsummary(glht.2)\n</code></pre>\n\n<pre><code>## \n##   Simultaneous Tests for General Linear Hypotheses\n## \n## Fit: lm(formula = edr ~ therapy * medF, data = Boik)\n## \n## Linear Hypotheses:\n##                               Estimate Std. Error t value Pr(&gt;|t|)   \n## T1.vs.T2.in.D2 == 0             -8.000      2.527   -3.17   0.0048 **\n## T1.vs.control.in.placebo == 0   -0.301      2.527   -0.12   0.9910   \n## ---\n## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 \n## (Adjusted p values reported -- single-step method)\n</code></pre>\n\n<pre><code class=\"r\">confint(glht.2)\n</code></pre>\n\n<pre><code>## \n##   Simultaneous Confidence Intervals\n## \n## Fit: lm(formula = edr ~ therapy * medF, data = Boik)\n## \n## Quantile = 2.292\n## 95% family-wise confidence level\n##  \n## \n## Linear Hypotheses:\n##                               Estimate lwr     upr    \n## T1.vs.T2.in.D2 == 0            -8.000  -13.791  -2.208\n## T1.vs.control.in.placebo == 0  -0.301   -6.092   5.491\n</code></pre>\n\n<p>These result are <em>obviously</em> different from the ones obtained with univariate methods with no correction for multiple testing.</p>\n\n<pre><code class=\"r\">mod.boik\n</code></pre>\n\n<pre><code>## \n## Call:\n## lm(formula = edr ~ therapy * medF, data = Boik)\n## \n## Coefficients:\n##      (Intercept)         therapyT1         therapyT2            medFD1  \n##           50.200            -0.301            -4.501            -2.701  \n##           medFD2            medFD3  therapyT1:medFD1  therapyT2:medFD1  \n##           -4.201            -2.301            -8.998            -3.899  \n## therapyT1:medFD2  therapyT2:medFD2  therapyT1:medFD3  therapyT2:medFD3  \n##          -17.199            -4.998           -28.599           -10.699\n</code></pre>\n\n<pre><code class=\"r\">confint(mod.boik)[2, ]  # This is &#39;T1.vs.control.in.placebo&#39; default contrast (computed in summary.lm and confint.lm)\n</code></pre>\n\n<pre><code>##  2.5 % 97.5 % \n## -5.355  4.753\n</code></pre>\n\n<h2>Obtain non corrected for multiple testing  p-values and univariate confidence intervals with glht</h2>\n\n<p>There is unfortunately, no <strong>confint</strong> method associated with testFactor results. But you can reproduce univariate confidence intervals with <strong>confint( mod,calpha = univariate_calpha())</strong>method on glht objects obtained with <strong>test = adjusted(type = &quot;none&quot;)</strong></p>\n\n<pre><code class=\"r\">glht.2.s &lt;- summary(glht.2, test = adjusted(type = &quot;none&quot;))\nglht.2.s\n</code></pre>\n\n<pre><code>## \n##   Simultaneous Tests for General Linear Hypotheses\n## \n## Fit: lm(formula = edr ~ therapy * medF, data = Boik)\n## \n## Linear Hypotheses:\n##                               Estimate Std. Error t value Pr(&gt;|t|)   \n## T1.vs.T2.in.D2 == 0             -8.000      2.527   -3.17   0.0024 **\n## T1.vs.control.in.placebo == 0   -0.301      2.527   -0.12   0.9056   \n## ---\n## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 \n## (Adjusted p values reported -- none method)\n</code></pre>\n\n<pre><code class=\"r\">glht.2.s$test$coefficients\n</code></pre>\n\n<pre><code>##           T1.vs.T2.in.D2 T1.vs.control.in.placebo \n##                  -7.9998                  -0.3008\n</code></pre>\n\n<pre><code class=\"r\">ghlt2.confint.u &lt;- confint(glht.2.s, calpha = univariate_calpha())\nghlt2.confint.u$confint\n</code></pre>\n\n<pre><code>##                          Estimate     lwr    upr\n## T1.vs.T2.in.D2            -7.9998 -13.054 -2.946\n## T1.vs.control.in.placebo  -0.3008  -5.355  4.753\n## attr(,&quot;conf.level&quot;)\n## [1] 0.95\n## attr(,&quot;calpha&quot;)\n## [1] 2\n</code></pre>\n\n<pre><code class=\"r\">\nconfint(mod.boik)[2, ] == ghlt2.confint.u$confint[2, 2:3]\n</code></pre>\n\n<pre><code>##  2.5 % 97.5 % \n##   TRUE   TRUE\n</code></pre>\n\n<p>This <em>trick</em> is used  because <strong>confint</strong> method  is not dispatched with testFactor results.</p>\n\n<pre><code class=\"r\">fact.boik &lt;- testFactors(mod.boik, levels = list(therapy = c(&quot;T1&quot;, &quot;T2&quot;), medF = &quot;D2&quot;), \n    adjustment = &quot;none&quot;)\nconfint(fact.boik)\n</code></pre>\n\n<pre><code>## Error: no applicable method for &#39;vcov&#39; applied to an object of class\n## &quot;c(&#39;testFactors.lm&#39;, &#39;testFactors&#39;)&quot;\n</code></pre>\n","num":1,"id":"slide-1","raw":"--- \n\n\n\n```{r,  eval=TRUE, results='hide', warning=FALSE, message=FALSE}\nlibrary(multcomp)\nlibrary(car)\nlibrary(effects)\nlibrary(phia)\n```\n\nCombine car, multcomp and phia to perform smarter linear modeling.\n=====================================\nThese examples have been largely inpired by Helios De Rosario-Martinez <helios.derosario at ibv.upv.es> [vignette](http://cran.r-project.org/web/packages/phia/vignettes/phia.pdf) from the [phia](http://cran.r-project.org/web/packages/phia/index.html). I recommend as well as the reading of [mutlcomp](http://cran.r-project.org/web/packages/multcomp/) textbook: [Multiple Comparisons Using R](http://www.amazon.co.uk/gp/product/1584885742/) from Multiple Comparisons from Torsten Hothorn, Frank Bretz and Peter Westfall. The [car](http://socserv.socsci.mcmaster.ca/jfox/Books/Companion/index.html ressource is obviously a place to be :-).\n\n\n.The Boik data set from **phia** is based on the hypothetical example used by R.J. Boik (1979) to explain the analysis of interaction contrasts. It represents the electrodermal response of 72 students complaining of hemophobia, treated with different fear reduction therapies and doses of antianxiety medication, in a balanced factorial design. The response variable **edr** is modeled with two factors **therapy**, with levels control, T1, and \nT2 and **medication**, with levels placebo, D1, D2, and D3 in interaction.\n\nIntroduction\n-------------------------\n```{r, tidy.opts=list(keep.blank.line=FALSE, width.cutoff=400)}\nsome(Boik)\ntable(Boik[,1:2])\n```\nI chose to tweak a bit this data set to avoid using the medication as an ordered factor to ease my interpretation \nof linear models outputs.\n\n```{r, tidy.opts=list(keep.blank.line=FALSE, width.cutoff=400)}\nBoik$medF <- factor(as.character(Boik$medication), levels=c('placebo', 'D1', 'D2', 'D3'))\nlevels(Boik$medF)\n```\n\nFit two models with interaction and main effects only\n-------------------------\n```{r, tidy.opts=list(keep.blank.line=FALSE, width.cutoff=400)}\nmod.boik   <- lm(edr ~ therapy*medF, data=Boik)\nmod.boik.M <- lm(edr ~ therapy + medF, data=Boik)\nsummary(mod.boik)\nAnova(mod.boik)\n```\n\n\nUse allEffects(), and interactionMeans() to compute cells and marginal means\n-------------------------\n\n```{r}\nboik.means <-interactionMeans(mod.boik)\nboik.means\ninteractionMeans(mod.boik, factors=\"therapy\")\n\ninteractionMeans(mod.boik,  factors=\"medF\")\n\n```\nSeveral type of interaction plots  are available to visualise the 'interaction effect'\n```{r}\nplot(boik.means, multiple=TRUE)\n\n\nplot(allEffects(mod.boik))\n```\n\n\nThe phia package is remarkebly designed to compute  various contrasts of interests using testInteractions() function.\n-------------------------\n\nThe columns medication1, . . . medication3 in the resulting table contain the value of the three\northogonal contrasts across the levels of medication, for each level of therapy (the only fixed factor\nin this example). In addition a F test (actually a global F test) is performed for each level of therapy\n\n\n```{r}\ntestInteractions(mod.boik, fixed=\"therapy\", across=\"medF\", adjustment='none')\n\n```\nBehind the scene, **testInteractions()** calls **testFactors()**. The ones corresponding to the one above are detailed below.\n```{r}\ncon.therapy <- testFactors(mod.boik, levels=list(therapy=c('control')), terms.formula=~medF,adjustment='none' )\n```\n```{r, results='hide', warning=FALSE, message=FALSE}\ntestFactors(mod.boik, levels=list(therapy=c('T1')), terms.formula=~medF, adjustment='none')\ntestFactors(mod.boik, levels=list(therapy=c('T2')), terms.formula=~medF, adjustment='none')\n```\nThe cont.therapy ob\n```{r}\ncon.therapy\nnames(con.therapy)\n```\nIt contains notably the hypothesis matrix done for a **global F test** that test the non equality of the edr value for the designated therapy level across levels of medication. \n```{r}\ncon.therapy$terms$`(Intercept)`$adjusted.values\ncon.therapy$terms$medF$adjusted.values\ncon.therapy$terms$medF$hypothesis.matrix\n```\n\nThe default contrasts definition used in the testInteractions() and testFactors() are takken from their default.contrasts=c(\"contr.sum\",\"contr.poly\"), which is usually not the ones that were used by default in R (see below and the **mod.boik** model).\nThis is very  **important** as it ensures that F tests and global F tests are meaningfull.\n```{r}\noptions('contrasts')\ncontr.sum(levels(Boik$medF))\ncontr.treatment(levels(Boik$medF))\n```\n\nThe therapy adjusted.values are computed using the folowing algebra.\n```{r}\n# using the hypothesis matrix\ncon.therapy$terms$medF$hypothesis.matrix %*% coef(mod.boik) \n# which correponds to a contrasts sum options\nt(contr.sum(levels(Boik$medF))[-c(1),]) %*% coef(mod.boik)[c(4:6)]\n# the default contrast (the one used in the model and summary output) are reprouced below\nt(contr.treatment(levels(Boik$medF))[-c(1),]) %*% coef(mod.boik)[c(2:4)]\n```\n\n\nHow to obtain the same results with different functions\n======================================================================================================================================\nEspecially, how to reproduce classic univariates results.\n\n\nObtain Anova global F interaction test with **linearHypothesis()**.\n-------------------------\n```{r}\ncoefs <- coefficients(mod.boik)\ncoefs\nlinearHypothesis(mod.boik, names(coefs)[7:12], verbose=TRUE)\n```\n\nObtain univariate linear model coefficients statistics done with **summary()** with **testFactors()**\n-------------------------\n```{r}\nsummary(mod.boik)\ntestFactors(mod.boik, levels=list(therapy=c('T1', 'control'), medF='placebo'), adjustment='none')$terms[['(Intercept)']]$test\ntestFactors(mod.boik, levels=list(therapy=c('T2', 'control'), medF='placebo'), adjustment='none')$terms[['(Intercept)']]$test\ntestFactors(mod.boik, levels=list(medF=c('D1', 'placebo'), therapy='control'), adjustment='none')$terms[['(Intercept)']]$test\ntestFactors(mod.boik, levels=list(medF=c('D2', 'placebo'), therapy='control'), adjustment='none')$terms[['(Intercept)']]$test\n# D3 versus placebo in control group.\ntestFactors(mod.boik, levels=list(medF=c('D3', 'placebo'), therapy='control'), adjustment='none')$terms[['(Intercept)']]$adjusted.values\ntestFactors(mod.boik, levels=list(medF=c('D3', 'placebo'), therapy='control'), adjustment='none')$terms[['(Intercept)']]$test\n# match the meanInteractions data.frame\nboik.means[10, 3] - boik.means[1, 3] \n```\n\n**testInteractions()** can compute pairwise contrasts very fluidly **BUT**\n-------------------------\nFirst remember that the testInteraction must used orthonomal contrasts (default.contrasts=c(\"contr.sum\",\"contr.poly\")).\nBelow, despites the fact that all pairwise combinations were performed, the adjusted means don't correspond \nstraightforwardly  to the 'classic' all pairwise group differences\n```{r}\ntestInteractions(mod.boik, pairwise=\"therapy\", across=\"medF\", adjustment='none')\n```\nIt you're in hurry, you could tweak the call, by changing the default contrasts, **BUT THEN THE F GLOBAL TEST ARE NOT MEANINGFUL ANYMORE**\nSo don't do that except if you know what you are doing.\n```{r}\n#  !!! THE F TEST IN EACH ROW ARE NOT MEANINGFUL -----------------------------------------------------------------------------------------------\ntestInteractions(mod.boik, pairwise=\"therapy\", across=\"medF\",  adjustment='none', default.contrasts=c(\"contr.treatment\",\"contr.poly\"))\n\ntestFactors(mod.boik, levels=list(therapy=c('T1', 'T2'), medF='D1'), adjustment='none')$terms[['(Intercept)']]$adjusted.values\ntestFactors(mod.boik, levels=list(therapy=c('T1', 'T2'), medF='D2'), adjustment='none')$terms[['(Intercept)']]$adjusted.values\n\n```\ntestInteractions() and the **custom** argument.\n-------------------------\nFirst, as ususal testInteractions() makes calls to testFactors. Without any arguments specified, it does the folowing default comparisons.\n```{r}\ntestInteractions(mod.boik, adjustment='none')\ntestFactors(mod.boik, levels=list(therapy=c('T1', 'T2'), medF=c('D1', 'D2')), adjustment='none')$terms[['(Intercept)']]\n# But We can compare the calculations and see how testInteraction calls testFactors()\ntestInteractions(mod.boik, adjustment='none')[12,]\ntestFactors(mod.boik, levels=list(therapy=c('T1', 'T2'), medF=c('D1', 'D2')), adjustment='none')$terms[['(Intercept)']]$adjusted.values\ntestFactors(mod.boik, levels=list(therapy=c('T1', 'T2'), medF=c('D1', 'D2')), adjustment='none')$terms[['(Intercept)']]$test[\"Pr(>F)\"]\n```\nWe can build custom contrast matrices. The code is directly inspired from testFactors() one.\n```{r}\nfaclist <- lapply(Boik[,1:2], levels)\nfaclist\nfacmat.sum  <- lapply(faclist, contr.sum) # default contr.sum matrices used by testFactors()\nfacmat.sum\nT1.T2.vs.Placebo.D3 <- list(therapy=facmat.sum$therapy[,2, drop=F], medF=facmat.sum$medication[,1, drop=F])\nT1.T2.vs.Placebo.D3\ntestInteractions(mod.boik, custom=T1.T2.vs.Placebo.D3, adjustment='none')\ntestInteractions(mod.boik, custom=T1.T2.vs.Placebo.D3, adjustment='none')$Value\ntestInteractions(mod.boik, custom=T1.T2.vs.Placebo.D3, adjustment='none')[[\"Pr(>F)\"]]\n```\nHypothesis matrix  (from testFactors() calls) can be reinjected  in the glht framework.\n-------------------------\n```{r}\nK1 <- summary(testFactors(mod.boik, levels=list(therapy=c('T1', 'T2'), medF='D2'), adjustment='none'))\nK2 <- summary(testFactors(mod.boik, levels=list(therapy=c('T1', 'control'), medF='placebo'), adjustment='none')) # This is a default contrast (compute in summary.lm and confint.lm)\nK  <- rbind(K1$hypothesis.matrix, lfinfct=K2$hypothesis.matrix)\nrow.names(K) <- c('T1.vs.T2.in.D2', 'T1.vs.control.in.placebo')\nset.seed(1)\n# The contrast matrix extracted from the testFactors result can be used in place\nset.seed(1)\nglht.2   <- glht(mod.boik, linfct=as.matrix(K))\n# use glht to compute user defined contrasts with the benefit of joint confidence interval estimates and multiple testing correction.\nsummary(glht.2)\nconfint(glht.2)\n```\nThese result are *obviously* different from the ones obtained with univariate methods with no correction for multiple testing.\n```{r}\nmod.boik\nconfint(mod.boik)[2,] # This is 'T1.vs.control.in.placebo' default contrast (computed in summary.lm and confint.lm)\n```\n\nObtain non corrected for multiple testing  p-values and univariate confidence intervals with glht\n-------------------------------------------\nThere is unfortunately, no **confint** method associated with testFactor results. But you can reproduce univariate confidence intervals with **confint( mod,calpha = univariate_calpha())**method on glht objects obtained with **test = adjusted(type = \"none\")**\n```{r}\nglht.2.s <- summary(glht.2, test = adjusted(type = \"none\") )\nglht.2.s \nglht.2.s$test$coefficients\nghlt2.confint.u <- confint(glht.2.s, calpha = univariate_calpha() )\nghlt2.confint.u$confint\n\nconfint(mod.boik)[2,] == ghlt2.confint.u$confint[2,2:3]\n\n```\nThis *trick* is used  because **confint** method  is not dispatched with testFactor results.\n```{r}\nfact.boik <- testFactors(mod.boik, levels=list(therapy=c('T1', 'T2'), medF='D2'), adjustment='none')\nconfint(fact.boik)\n```\n\n\n\n\n\n\n"}],"standalone":false,"file":"interaction_terms_analysis_phia.Rmd","filename":"interaction_terms_analysis_phia","link":"interaction_terms_analysis_phia.html","raw":"---\ntitle: Combine car, multcomp and phia to perform smarter linear modeling\nauthor: Marc Lamarine\nlicense: GPL (>= 2)\ntags: linear model, univariate \nsummary: How to combine functions of several linear modelling packages and benefit from all\ndate: 2013-05-27\n---\n\n\n\n```{r,  eval=TRUE, results='hide', warning=FALSE, message=FALSE}\nlibrary(multcomp)\nlibrary(car)\nlibrary(effects)\nlibrary(phia)\n```\n\nCombine car, multcomp and phia to perform smarter linear modeling.\n=====================================\nThese examples have been largely inpired by Helios De Rosario-Martinez <helios.derosario at ibv.upv.es> [vignette](http://cran.r-project.org/web/packages/phia/vignettes/phia.pdf) from the [phia](http://cran.r-project.org/web/packages/phia/index.html). I recommend as well as the reading of [mutlcomp](http://cran.r-project.org/web/packages/multcomp/) textbook: [Multiple Comparisons Using R](http://www.amazon.co.uk/gp/product/1584885742/) from Multiple Comparisons from Torsten Hothorn, Frank Bretz and Peter Westfall. The [car](http://socserv.socsci.mcmaster.ca/jfox/Books/Companion/index.html ressource is obviously a place to be :-).\n\n\n.The Boik data set from **phia** is based on the hypothetical example used by R.J. Boik (1979) to explain the analysis of interaction contrasts. It represents the electrodermal response of 72 students complaining of hemophobia, treated with different fear reduction therapies and doses of antianxiety medication, in a balanced factorial design. The response variable **edr** is modeled with two factors **therapy**, with levels control, T1, and \nT2 and **medication**, with levels placebo, D1, D2, and D3 in interaction.\n\nIntroduction\n-------------------------\n```{r, tidy.opts=list(keep.blank.line=FALSE, width.cutoff=400)}\nsome(Boik)\ntable(Boik[,1:2])\n```\nI chose to tweak a bit this data set to avoid using the medication as an ordered factor to ease my interpretation \nof linear models outputs.\n\n```{r, tidy.opts=list(keep.blank.line=FALSE, width.cutoff=400)}\nBoik$medF <- factor(as.character(Boik$medication), levels=c('placebo', 'D1', 'D2', 'D3'))\nlevels(Boik$medF)\n```\n\nFit two models with interaction and main effects only\n-------------------------\n```{r, tidy.opts=list(keep.blank.line=FALSE, width.cutoff=400)}\nmod.boik   <- lm(edr ~ therapy*medF, data=Boik)\nmod.boik.M <- lm(edr ~ therapy + medF, data=Boik)\nsummary(mod.boik)\nAnova(mod.boik)\n```\n\n\nUse allEffects(), and interactionMeans() to compute cells and marginal means\n-------------------------\n\n```{r}\nboik.means <-interactionMeans(mod.boik)\nboik.means\ninteractionMeans(mod.boik, factors=\"therapy\")\n\ninteractionMeans(mod.boik,  factors=\"medF\")\n\n```\nSeveral type of interaction plots  are available to visualise the 'interaction effect'\n```{r}\nplot(boik.means, multiple=TRUE)\n\n\nplot(allEffects(mod.boik))\n```\n\n\nThe phia package is remarkebly designed to compute  various contrasts of interests using testInteractions() function.\n-------------------------\n\nThe columns medication1, . . . medication3 in the resulting table contain the value of the three\northogonal contrasts across the levels of medication, for each level of therapy (the only fixed factor\nin this example). In addition a F test (actually a global F test) is performed for each level of therapy\n\n\n```{r}\ntestInteractions(mod.boik, fixed=\"therapy\", across=\"medF\", adjustment='none')\n\n```\nBehind the scene, **testInteractions()** calls **testFactors()**. The ones corresponding to the one above are detailed below.\n```{r}\ncon.therapy <- testFactors(mod.boik, levels=list(therapy=c('control')), terms.formula=~medF,adjustment='none' )\n```\n```{r, results='hide', warning=FALSE, message=FALSE}\ntestFactors(mod.boik, levels=list(therapy=c('T1')), terms.formula=~medF, adjustment='none')\ntestFactors(mod.boik, levels=list(therapy=c('T2')), terms.formula=~medF, adjustment='none')\n```\nThe cont.therapy ob\n```{r}\ncon.therapy\nnames(con.therapy)\n```\nIt contains notably the hypothesis matrix done for a **global F test** that test the non equality of the edr value for the designated therapy level across levels of medication. \n```{r}\ncon.therapy$terms$`(Intercept)`$adjusted.values\ncon.therapy$terms$medF$adjusted.values\ncon.therapy$terms$medF$hypothesis.matrix\n```\n\nThe default contrasts definition used in the testInteractions() and testFactors() are takken from their default.contrasts=c(\"contr.sum\",\"contr.poly\"), which is usually not the ones that were used by default in R (see below and the **mod.boik** model).\nThis is very  **important** as it ensures that F tests and global F tests are meaningfull.\n```{r}\noptions('contrasts')\ncontr.sum(levels(Boik$medF))\ncontr.treatment(levels(Boik$medF))\n```\n\nThe therapy adjusted.values are computed using the folowing algebra.\n```{r}\n# using the hypothesis matrix\ncon.therapy$terms$medF$hypothesis.matrix %*% coef(mod.boik) \n# which correponds to a contrasts sum options\nt(contr.sum(levels(Boik$medF))[-c(1),]) %*% coef(mod.boik)[c(4:6)]\n# the default contrast (the one used in the model and summary output) are reprouced below\nt(contr.treatment(levels(Boik$medF))[-c(1),]) %*% coef(mod.boik)[c(2:4)]\n```\n\n\nHow to obtain the same results with different functions\n======================================================================================================================================\nEspecially, how to reproduce classic univariates results.\n\n\nObtain Anova global F interaction test with **linearHypothesis()**.\n-------------------------\n```{r}\ncoefs <- coefficients(mod.boik)\ncoefs\nlinearHypothesis(mod.boik, names(coefs)[7:12], verbose=TRUE)\n```\n\nObtain univariate linear model coefficients statistics done with **summary()** with **testFactors()**\n-------------------------\n```{r}\nsummary(mod.boik)\ntestFactors(mod.boik, levels=list(therapy=c('T1', 'control'), medF='placebo'), adjustment='none')$terms[['(Intercept)']]$test\ntestFactors(mod.boik, levels=list(therapy=c('T2', 'control'), medF='placebo'), adjustment='none')$terms[['(Intercept)']]$test\ntestFactors(mod.boik, levels=list(medF=c('D1', 'placebo'), therapy='control'), adjustment='none')$terms[['(Intercept)']]$test\ntestFactors(mod.boik, levels=list(medF=c('D2', 'placebo'), therapy='control'), adjustment='none')$terms[['(Intercept)']]$test\n# D3 versus placebo in control group.\ntestFactors(mod.boik, levels=list(medF=c('D3', 'placebo'), therapy='control'), adjustment='none')$terms[['(Intercept)']]$adjusted.values\ntestFactors(mod.boik, levels=list(medF=c('D3', 'placebo'), therapy='control'), adjustment='none')$terms[['(Intercept)']]$test\n# match the meanInteractions data.frame\nboik.means[10, 3] - boik.means[1, 3] \n```\n\n**testInteractions()** can compute pairwise contrasts very fluidly **BUT**\n-------------------------\nFirst remember that the testInteraction must used orthonomal contrasts (default.contrasts=c(\"contr.sum\",\"contr.poly\")).\nBelow, despites the fact that all pairwise combinations were performed, the adjusted means don't correspond \nstraightforwardly  to the 'classic' all pairwise group differences\n```{r}\ntestInteractions(mod.boik, pairwise=\"therapy\", across=\"medF\", adjustment='none')\n```\nIt you're in hurry, you could tweak the call, by changing the default contrasts, **BUT THEN THE F GLOBAL TEST ARE NOT MEANINGFUL ANYMORE**\nSo don't do that except if you know what you are doing.\n```{r}\n#  !!! THE F TEST IN EACH ROW ARE NOT MEANINGFUL -----------------------------------------------------------------------------------------------\ntestInteractions(mod.boik, pairwise=\"therapy\", across=\"medF\",  adjustment='none', default.contrasts=c(\"contr.treatment\",\"contr.poly\"))\n\ntestFactors(mod.boik, levels=list(therapy=c('T1', 'T2'), medF='D1'), adjustment='none')$terms[['(Intercept)']]$adjusted.values\ntestFactors(mod.boik, levels=list(therapy=c('T1', 'T2'), medF='D2'), adjustment='none')$terms[['(Intercept)']]$adjusted.values\n\n```\ntestInteractions() and the **custom** argument.\n-------------------------\nFirst, as ususal testInteractions() makes calls to testFactors. Without any arguments specified, it does the folowing default comparisons.\n```{r}\ntestInteractions(mod.boik, adjustment='none')\ntestFactors(mod.boik, levels=list(therapy=c('T1', 'T2'), medF=c('D1', 'D2')), adjustment='none')$terms[['(Intercept)']]\n# But We can compare the calculations and see how testInteraction calls testFactors()\ntestInteractions(mod.boik, adjustment='none')[12,]\ntestFactors(mod.boik, levels=list(therapy=c('T1', 'T2'), medF=c('D1', 'D2')), adjustment='none')$terms[['(Intercept)']]$adjusted.values\ntestFactors(mod.boik, levels=list(therapy=c('T1', 'T2'), medF=c('D1', 'D2')), adjustment='none')$terms[['(Intercept)']]$test[\"Pr(>F)\"]\n```\nWe can build custom contrast matrices. The code is directly inspired from testFactors() one.\n```{r}\nfaclist <- lapply(Boik[,1:2], levels)\nfaclist\nfacmat.sum  <- lapply(faclist, contr.sum) # default contr.sum matrices used by testFactors()\nfacmat.sum\nT1.T2.vs.Placebo.D3 <- list(therapy=facmat.sum$therapy[,2, drop=F], medF=facmat.sum$medication[,1, drop=F])\nT1.T2.vs.Placebo.D3\ntestInteractions(mod.boik, custom=T1.T2.vs.Placebo.D3, adjustment='none')\ntestInteractions(mod.boik, custom=T1.T2.vs.Placebo.D3, adjustment='none')$Value\ntestInteractions(mod.boik, custom=T1.T2.vs.Placebo.D3, adjustment='none')[[\"Pr(>F)\"]]\n```\nHypothesis matrix  (from testFactors() calls) can be reinjected  in the glht framework.\n-------------------------\n```{r}\nK1 <- summary(testFactors(mod.boik, levels=list(therapy=c('T1', 'T2'), medF='D2'), adjustment='none'))\nK2 <- summary(testFactors(mod.boik, levels=list(therapy=c('T1', 'control'), medF='placebo'), adjustment='none')) # This is a default contrast (compute in summary.lm and confint.lm)\nK  <- rbind(K1$hypothesis.matrix, lfinfct=K2$hypothesis.matrix)\nrow.names(K) <- c('T1.vs.T2.in.D2', 'T1.vs.control.in.placebo')\nset.seed(1)\n# The contrast matrix extracted from the testFactors result can be used in place\nset.seed(1)\nglht.2   <- glht(mod.boik, linfct=as.matrix(K))\n# use glht to compute user defined contrasts with the benefit of joint confidence interval estimates and multiple testing correction.\nsummary(glht.2)\nconfint(glht.2)\n```\nThese result are *obviously* different from the ones obtained with univariate methods with no correction for multiple testing.\n```{r}\nmod.boik\nconfint(mod.boik)[2,] # This is 'T1.vs.control.in.placebo' default contrast (computed in summary.lm and confint.lm)\n```\n\nObtain non corrected for multiple testing  p-values and univariate confidence intervals with glht\n-------------------------------------------\nThere is unfortunately, no **confint** method associated with testFactor results. But you can reproduce univariate confidence intervals with **confint( mod,calpha = univariate_calpha())**method on glht objects obtained with **test = adjusted(type = \"none\")**\n```{r}\nglht.2.s <- summary(glht.2, test = adjusted(type = \"none\") )\nglht.2.s \nglht.2.s$test$coefficients\nghlt2.confint.u <- confint(glht.2.s, calpha = univariate_calpha() )\nghlt2.confint.u$confint\n\nconfint(mod.boik)[2,] == ghlt2.confint.u$confint[2,2:3]\n\n```\nThis *trick* is used  because **confint** method  is not dispatched with testFactor results.\n```{r}\nfact.boik <- testFactors(mod.boik, levels=list(therapy=c('T1', 'T2'), medF='D2'), adjustment='none')\nconfint(fact.boik)\n```\n\n\n\n\n\n\n"},{"url":{"assets":"../assets","lib":"../libraries"},"framework":"qb_rss","theme":"","highlighter":"prettify","hitheme":"twitter-bootstrap","copy_libraries":true,"mode":"selfcontained","widgets":[],"prettify":{"linenums":true},"title":"A dirty hack for importing packages that use Depends","author":"Karl Forner","license":"GPL (>= 2)","tags":"package namespace imports depends","summary":"A dirty hack for importing packages that use Depends","date":15852,"slides":[{"html":"<h2>Scope</h2>\n\n<p>This article is about R package development.</p>\n\n<h2>Motivation</h2>\n\n<p>As stated in the the <em>Writing R Extensions</em> manual and the <em>Software for Data Analysis</em> book (aka the R bible), packages should\nwhenever possible use <strong>Imports</strong> instead of <strong>Depends</strong>, to avoid name collision (masking) and ensure trustworthy computations. \nSee <a href=\"http://stackoverflow.com/questions/8637993/better-explanation-of-when-to-use-imports-depends\">this discussion on Stackoverflow</a>.</p>\n\n<h2>The problem</h2>\n\n<p>So after adopting best practices, and only using <strong>Imports</strong> in my packages, the problem is that some <em>imported</em> packages \ndo not follow those best practices and rely on <strong>Depends</strong> for their dependencies, and consequently will not find \ntheir dependencies unless hacked.  </p>\n\n<p>Say we are writing a package <strong>MyPkg</strong>, that uses some functions from a CRAN package <strong>A</strong>, which lists a CRAN \npackage <strong>B</strong> in its Depends.</p>\n\n<p><em>MyPkg::f</em></p>\n\n<pre><code>f &lt;- function() a()\n</code></pre>\n\n<p><em>A::a</em></p>\n\n<pre><code>a &lt;- function() b()\n</code></pre>\n\n<p><em>B::b</em>\nb &lt;- function() { ... }</p>\n\n<p>Executing <code>f()</code> will find the function <code>a</code>, explicitly imported from package A. But executing <code>a()</code> will die because \nfunction <code>b</code> can not be found.</p>\n\n<h2>analysis</h2>\n\n<p>Because B is listed in the Depends of package A, <code>b()</code> is normally found in the <em>search path</em>, where namespace <strong>B</strong> is attached. \nWhat can we do to work around this problem ?<br>\nSadly, there is nothing we can do at the  <strong>MyPkg</strong> package level, since the problem sits in the <strong>A</strong> namespace.\nWe could of course lists B in the <strong>MyPkg</strong> Depends, but that is precisely what we want to avoid.</p>\n\n<h2>the dirty hack solution</h2>\n\n<h3>the idea</h3>\n\n<p>I suggest that you first have a look at this very good blog \n<a href=\"http://obeautifulcode.com/R/How-R-Searches-And-Finds-Stuff/\">How R Searches and Finds Stuff</a> if you need some \nclarification about namespaces and imports.  </p>\n\n<p>Here is a diagram of the current state of the problem:</p>\n\n<p><img src=\"assets/fig/unnamed-chunk-1.png\" alt=\"plot of chunk unnamed-chunk-1\"> </p>\n\n<p>We want the <code>a()</code> call, which is executed in namespace <strong>A</strong>, to find the <strong>b</strong> symbol in namespace <strong>B</strong>. \nTo achieve this, we will re-route the namespace <strong>A</strong> (actually its Imports namespace) to the <strong>B</strong> namespace:</p>\n\n<pre><code>nsa &lt;- getNamespace(&#39;A&#39;)                      # package A environment\nnsa_imp &lt;- parent.env(nsa)                    # package A Imports\nparent.env(nsa_imp) &lt;- getNamespace(&#39;B&#39;)      # re-route A Imports to package B\n</code></pre>\n\n<p>Now our namespaces should look like this:  </p>\n\n<p><img src=\"assets/fig/unnamed-chunk-2.png\" alt=\"plot of chunk unnamed-chunk-2\"> </p>\n\n<p>Notice that the link From A Imports to base has been re-routed towards package B (the arrow labelled &quot;New&quot;)</p>\n\n<h2>Example</h2>\n\n<p>The above code is not straightforward to test because you need to write a package.  </p>\n\n<p>Here is some reproducible code that illustrates how the hack works, so that you can simulate its mechanism\nright now by copy-pasting the following code in your R console.\nThis example uses package <strong>multcomp</strong> that <em>Depends</em> on <strong>mvtnorm</strong>. </p>\n\n<pre><code class=\"r\">## load multcomp package, and its imports, but do not attach them in the\n## search path\nl &lt;- loadNamespace(&quot;multcomp&quot;)  # assignment to avoid annoying print\n\namod &lt;- aov(breaks ~ wool + tension, data = warpbreaks)\nwht &lt;- multcomp::glht(amod, linfct = multcomp::mcp(tension = &quot;Tukey&quot;))\nci &lt;- confint(wht)  # mvtnorm::qmvt is not found, because mvtnorm is not attached to the search path\n\n# let&#39;s load the mvtnorm namespace\nl &lt;- loadNamespace(&quot;mvtnorm&quot;)\nci &lt;- confint(wht)  # mvtnorm::qmvt still not found, mvtnorm is loaded but not attached\n\n# hack hack hack: re-route package multcomp to mvtnorm\nns1 &lt;- getNamespace(&quot;multcomp&quot;)\nns1_imp &lt;- parent.env(ns1)\nparent.env(ns1_imp) &lt;- getNamespace(&quot;mvtnorm&quot;)\n\nci &lt;- confint(wht)  # now should work\nprint(ci)\n</code></pre>\n\n<pre><code>## \n##   Simultaneous Confidence Intervals\n## \n## Multiple Comparisons of Means: Tukey Contrasts\n## \n## \n## Fit: aov(formula = breaks ~ wool + tension, data = warpbreaks)\n## \n## Quantile = 2.415\n## 95% family-wise confidence level\n##  \n## \n## Linear Hypotheses:\n##            Estimate lwr     upr    \n## M - L == 0 -10.000  -19.354  -0.646\n## H - L == 0 -14.722  -24.076  -5.369\n## H - M == 0  -4.722  -14.076   4.631\n</code></pre>\n\n<h2>implementation of the hack in MyPkg</h2>\n\n<p>Just put the re-routing code in your MyPkg <strong>.onLoad</strong> function, defined usually in <code>R/zzz.R</code>:</p>\n\n<pre><code>.onLoad &lt;- function(libname, pkgname) {\n    nsa &lt;- getNamespace(&#39;A&#39;)\n    nsa_imp &lt;- parent.env(nsa)\n    parent.env(nsa_imp) &lt;- getNamespace(&#39;B&#39;)    \n}\n</code></pre>\n\n<h3>why dirty ?</h3>\n\n<p>First of all, it uses <code>parent.env&lt;-</code>, and according to the documentation:</p>\n\n<blockquote>\n<p>The replacement function parent.env&lt;- is extremely dangerous as it can be used to destructively change environments in ways &gt;that violate assumptions made by the internal C code. It may be removed in the near future.</p>\n</blockquote>\n\n<p>It is a pity because it can be extremely useful.</p>\n\n<h3>why a hack ?</h3>\n\n<p>Unfortunately it does not work in the general case. \nSuppose you need two packages A and D, that both depend on B and C, but with different rules:</p>\n\n<pre><code>A -&gt; B -&gt; C\nD -&gt; C -&gt; B\n</code></pre>\n\n<p>In that case, we would re-route A to B, then B to C. And this is incompatible with the way D is designed, resulting in\nwrong symbol picks if symbols with same name are both defined by B and C.</p>\n\n<h3>so what ?</h3>\n\n<p>We&#39;ll see in a future post a probably much better solution.</p>\n\n<p><em>Karl Forner @ Quartz Bio</em></p>\n","header":"<h2>Scope</h2>","level":"2","title":"Scope","content":"<p>This article is about R package development.</p>\n\n<h2>Motivation</h2>\n\n<p>As stated in the the <em>Writing R Extensions</em> manual and the <em>Software for Data Analysis</em> book (aka the R bible), packages should\nwhenever possible use <strong>Imports</strong> instead of <strong>Depends</strong>, to avoid name collision (masking) and ensure trustworthy computations. \nSee <a href=\"http://stackoverflow.com/questions/8637993/better-explanation-of-when-to-use-imports-depends\">this discussion on Stackoverflow</a>.</p>\n\n<h2>The problem</h2>\n\n<p>So after adopting best practices, and only using <strong>Imports</strong> in my packages, the problem is that some <em>imported</em> packages \ndo not follow those best practices and rely on <strong>Depends</strong> for their dependencies, and consequently will not find \ntheir dependencies unless hacked.  </p>\n\n<p>Say we are writing a package <strong>MyPkg</strong>, that uses some functions from a CRAN package <strong>A</strong>, which lists a CRAN \npackage <strong>B</strong> in its Depends.</p>\n\n<p><em>MyPkg::f</em></p>\n\n<pre><code>f &lt;- function() a()\n</code></pre>\n\n<p><em>A::a</em></p>\n\n<pre><code>a &lt;- function() b()\n</code></pre>\n\n<p><em>B::b</em>\nb &lt;- function() { ... }</p>\n\n<p>Executing <code>f()</code> will find the function <code>a</code>, explicitly imported from package A. But executing <code>a()</code> will die because \nfunction <code>b</code> can not be found.</p>\n\n<h2>analysis</h2>\n\n<p>Because B is listed in the Depends of package A, <code>b()</code> is normally found in the <em>search path</em>, where namespace <strong>B</strong> is attached. \nWhat can we do to work around this problem ?<br>\nSadly, there is nothing we can do at the  <strong>MyPkg</strong> package level, since the problem sits in the <strong>A</strong> namespace.\nWe could of course lists B in the <strong>MyPkg</strong> Depends, but that is precisely what we want to avoid.</p>\n\n<h2>the dirty hack solution</h2>\n\n<h3>the idea</h3>\n\n<p>I suggest that you first have a look at this very good blog \n<a href=\"http://obeautifulcode.com/R/How-R-Searches-And-Finds-Stuff/\">How R Searches and Finds Stuff</a> if you need some \nclarification about namespaces and imports.  </p>\n\n<p>Here is a diagram of the current state of the problem:</p>\n\n<p><img src=\"assets/fig/unnamed-chunk-1.png\" alt=\"plot of chunk unnamed-chunk-1\"> </p>\n\n<p>We want the <code>a()</code> call, which is executed in namespace <strong>A</strong>, to find the <strong>b</strong> symbol in namespace <strong>B</strong>. \nTo achieve this, we will re-route the namespace <strong>A</strong> (actually its Imports namespace) to the <strong>B</strong> namespace:</p>\n\n<pre><code>nsa &lt;- getNamespace(&#39;A&#39;)                      # package A environment\nnsa_imp &lt;- parent.env(nsa)                    # package A Imports\nparent.env(nsa_imp) &lt;- getNamespace(&#39;B&#39;)      # re-route A Imports to package B\n</code></pre>\n\n<p>Now our namespaces should look like this:  </p>\n\n<p><img src=\"assets/fig/unnamed-chunk-2.png\" alt=\"plot of chunk unnamed-chunk-2\"> </p>\n\n<p>Notice that the link From A Imports to base has been re-routed towards package B (the arrow labelled &quot;New&quot;)</p>\n\n<h2>Example</h2>\n\n<p>The above code is not straightforward to test because you need to write a package.  </p>\n\n<p>Here is some reproducible code that illustrates how the hack works, so that you can simulate its mechanism\nright now by copy-pasting the following code in your R console.\nThis example uses package <strong>multcomp</strong> that <em>Depends</em> on <strong>mvtnorm</strong>. </p>\n\n<pre><code class=\"r\">## load multcomp package, and its imports, but do not attach them in the\n## search path\nl &lt;- loadNamespace(&quot;multcomp&quot;)  # assignment to avoid annoying print\n\namod &lt;- aov(breaks ~ wool + tension, data = warpbreaks)\nwht &lt;- multcomp::glht(amod, linfct = multcomp::mcp(tension = &quot;Tukey&quot;))\nci &lt;- confint(wht)  # mvtnorm::qmvt is not found, because mvtnorm is not attached to the search path\n\n# let&#39;s load the mvtnorm namespace\nl &lt;- loadNamespace(&quot;mvtnorm&quot;)\nci &lt;- confint(wht)  # mvtnorm::qmvt still not found, mvtnorm is loaded but not attached\n\n# hack hack hack: re-route package multcomp to mvtnorm\nns1 &lt;- getNamespace(&quot;multcomp&quot;)\nns1_imp &lt;- parent.env(ns1)\nparent.env(ns1_imp) &lt;- getNamespace(&quot;mvtnorm&quot;)\n\nci &lt;- confint(wht)  # now should work\nprint(ci)\n</code></pre>\n\n<pre><code>## \n##   Simultaneous Confidence Intervals\n## \n## Multiple Comparisons of Means: Tukey Contrasts\n## \n## \n## Fit: aov(formula = breaks ~ wool + tension, data = warpbreaks)\n## \n## Quantile = 2.415\n## 95% family-wise confidence level\n##  \n## \n## Linear Hypotheses:\n##            Estimate lwr     upr    \n## M - L == 0 -10.000  -19.354  -0.646\n## H - L == 0 -14.722  -24.076  -5.369\n## H - M == 0  -4.722  -14.076   4.631\n</code></pre>\n\n<h2>implementation of the hack in MyPkg</h2>\n\n<p>Just put the re-routing code in your MyPkg <strong>.onLoad</strong> function, defined usually in <code>R/zzz.R</code>:</p>\n\n<pre><code>.onLoad &lt;- function(libname, pkgname) {\n    nsa &lt;- getNamespace(&#39;A&#39;)\n    nsa_imp &lt;- parent.env(nsa)\n    parent.env(nsa_imp) &lt;- getNamespace(&#39;B&#39;)    \n}\n</code></pre>\n\n<h3>why dirty ?</h3>\n\n<p>First of all, it uses <code>parent.env&lt;-</code>, and according to the documentation:</p>\n\n<blockquote>\n<p>The replacement function parent.env&lt;- is extremely dangerous as it can be used to destructively change environments in ways &gt;that violate assumptions made by the internal C code. It may be removed in the near future.</p>\n</blockquote>\n\n<p>It is a pity because it can be extremely useful.</p>\n\n<h3>why a hack ?</h3>\n\n<p>Unfortunately it does not work in the general case. \nSuppose you need two packages A and D, that both depend on B and C, but with different rules:</p>\n\n<pre><code>A -&gt; B -&gt; C\nD -&gt; C -&gt; B\n</code></pre>\n\n<p>In that case, we would re-route A to B, then B to C. And this is incompatible with the way D is designed, resulting in\nwrong symbol picks if symbols with same name are both defined by B and C.</p>\n\n<h3>so what ?</h3>\n\n<p>We&#39;ll see in a future post a probably much better solution.</p>\n\n<p><em>Karl Forner @ Quartz Bio</em></p>\n","num":1,"id":"slide-1","raw":"--- \n\n## Scope\n\nThis article is about R package development.\n\n## Motivation\n\nAs stated in the the _Writing R Extensions_ manual and the _Software for Data Analysis_ book (aka the R bible), packages should\nwhenever possible use **Imports** instead of **Depends**, to avoid name collision (masking) and ensure trustworthy computations. \nSee [this discussion on Stackoverflow](http://stackoverflow.com/questions/8637993/better-explanation-of-when-to-use-imports-depends).\n\n## The problem\n\nSo after adopting best practices, and only using **Imports** in my packages, the problem is that some _imported_ packages \ndo not follow those best practices and rely on **Depends** for their dependencies, and consequently will not find \ntheir dependencies unless hacked.  \n\nSay we are writing a package **MyPkg**, that uses some functions from a CRAN package **A**, which lists a CRAN \npackage **B** in its Depends.\n\n_MyPkg::f_\n```\nf <- function() a()\n```\n_A::a_\n```\na <- function() b()\n```\n\n_B::b_\nb <- function() { ... }\n\n\nExecuting `f()` will find the function `a`, explicitly imported from package A. But executing `a()` will die because \nfunction `b` can not be found.\n\n## analysis\n\nBecause B is listed in the Depends of package A, `b()` is normally found in the _search path_, where namespace **B** is attached. \nWhat can we do to work around this problem ?  \nSadly, there is nothing we can do at the  **MyPkg** package level, since the problem sits in the **A** namespace.\nWe could of course lists B in the **MyPkg** Depends, but that is precisely what we want to avoid.\n\n## the dirty hack solution\n\n### the idea\n\nI suggest that you first have a look at this very good blog \n[How R Searches and Finds Stuff](http://obeautifulcode.com/R/How-R-Searches-And-Finds-Stuff/) if you need some \nclarification about namespaces and imports.  \n\n\nHere is a diagram of the current state of the problem:\n\n```{r echo=FALSE}\nsuppressPackageStartupMessages(library(diagram))\npar(mar = c(1, 1, 2, 1))\n\nnames <- c( \"MyPkg:\\nf()\", \"A:\\nA()\", \"B\\nb()\", \"MyPkg.Imports\\nA::a()\", \"A.Imports\", \"B.Imports\", \"Base\")\nn  <- length(names)\nM <- matrix(nrow = n, ncol = n, byrow = TRUE, data = 0)\n\nM[4, 1] <- M[7, 4] <- M[5, 2] <- M[7, 5] <- M[6, 3] <- M[7, 6]  <- \"\"\ncoords <- coordinates(c(3, 3, 1))\nplotmat(M, pos = coords, curve = 0, name = names, lwd = 1, box.lwd = 2, cex.txt = 0.8, box.type = \"circle\", box.prop = 1.0)\nstraightarrow(from = coords[4, ]+0.05, to = coords[2, ]-0.05, lty = 2, lcol = 2)\nmtext(outer = TRUE, side = 3, line = -1.5, cex = 1.5, \"Namespaces before\")\n```\n\n\nWe want the `a()` call, which is executed in namespace **A**, to find the **b** symbol in namespace **B**. \nTo achieve this, we will re-route the namespace **A** (actually its Imports namespace) to the **B** namespace:\n```\nnsa <- getNamespace('A')                      # package A environment\nnsa_imp <- parent.env(nsa)                    # package A Imports\nparent.env(nsa_imp) <- getNamespace('B')      # re-route A Imports to package B\n```\n\nNow our namespaces should look like this:  \n\n```{r echo=FALSE}\n\npar(mar = c(1, 1, 2, 1))\n\nnames <- c( \"MyPkg:\\nf()\", \"A:\\nA()\", \"B\\nb()\", \"MyPkg.Imports\\nA::a()\", \"A.Imports\", \"B.Imports\", \"Base\")\nn  <- length(names)\nM <- matrix(nrow = n, ncol = n, byrow = TRUE, data = 0)\n\nM[4, 1] <- M[7, 4] <- M[5, 2] <- M[6, 3] <- M[7, 6]  <- \"\"\nM[3, 5] <- \"New\"\ncoords <- coordinates(c(3, 3, 1))\nplotmat(M, pos = coords, curve = 0, name = names, lwd = 1, box.lwd = 2, cex.txt = 0.8, box.type = \"circle\", box.prop = 1.0)\nstraightarrow(from = coords[4, ]+0.05, to = coords[2, ]-0.05, lty = 2, lcol = 2)\nmtext(outer = TRUE, side = 3, line = -1.5, cex = 1.5, \"Namespaces after re-rerouting\")\n```\n\nNotice that the link From A Imports to base has been re-routed towards package B (the arrow labelled \"New\")\n\n## Example\n\n\nThe above code is not straightforward to test because you need to write a package.  \n\nHere is some reproducible code that illustrates how the hack works, so that you can simulate its mechanism\nright now by copy-pasting the following code in your R console.\nThis example uses package **multcomp** that _Depends_ on **mvtnorm**. \n\n```{r}\n## load multcomp package, and its imports, but do not attach them in the search path\nl <- loadNamespace('multcomp') # assignment to avoid annoying print\n\namod <- aov(breaks ~ wool + tension, data = warpbreaks)\nwht <- multcomp::glht(amod, linfct = multcomp::mcp(tension = \"Tukey\"))\nci <- confint(wht) # mvtnorm::qmvt is not found, because mvtnorm is not attached to the search path\n\n# let's load the mvtnorm namespace \nl <- loadNamespace('mvtnorm')\nci <- confint(wht) # mvtnorm::qmvt still not found, mvtnorm is loaded but not attached\n\n# hack hack hack: re-route package multcomp to mvtnorm\nns1 <- getNamespace('multcomp')\nns1_imp <- parent.env(ns1)\nparent.env(ns1_imp) <- getNamespace('mvtnorm')\n\nci <- confint(wht) # now should work\nprint(ci)\n\n```\n\n## implementation of the hack in MyPkg\n\nJust put the re-routing code in your MyPkg **.onLoad** function, defined usually in `R/zzz.R`:\n\n```\n.onLoad <- function(libname, pkgname) {\n    nsa <- getNamespace('A')\n    nsa_imp <- parent.env(nsa)\n    parent.env(nsa_imp) <- getNamespace('B')    \n}\n```\n\n### why dirty ?\n\nFirst of all, it uses `parent.env<-`, and according to the documentation:\n>The replacement function parent.env<- is extremely dangerous as it can be used to destructively change environments in ways >that violate assumptions made by the internal C code. It may be removed in the near future.\n\nIt is a pity because it can be extremely useful.\n\n### why a hack ?\n\nUnfortunately it does not work in the general case. \nSuppose you need two packages A and D, that both depend on B and C, but with different rules:\n```\nA -> B -> C\nD -> C -> B\n```\nIn that case, we would re-route A to B, then B to C. And this is incompatible with the way D is designed, resulting in\nwrong symbol picks if symbols with same name are both defined by B and C.\n\n### so what ?\n\nWe'll see in a future post a probably much better solution.\n\n\n_Karl Forner @ Quartz Bio_\n\n"}],"standalone":false,"file":"package-depends-dirty-hack-solution.Rmd","filename":"package-depends-dirty-hack-solution","link":"package-depends-dirty-hack-solution.html","raw":"---\ntitle: A dirty hack for importing packages that use Depends\nauthor: Karl Forner\nlicense: GPL (>= 2)\ntags: package namespace imports depends\nsummary: A dirty hack for importing packages that use Depends\ndate: 2013-05-27\n---\n\n## Scope\n\nThis article is about R package development.\n\n## Motivation\n\nAs stated in the the _Writing R Extensions_ manual and the _Software for Data Analysis_ book (aka the R bible), packages should\nwhenever possible use **Imports** instead of **Depends**, to avoid name collision (masking) and ensure trustworthy computations. \nSee [this discussion on Stackoverflow](http://stackoverflow.com/questions/8637993/better-explanation-of-when-to-use-imports-depends).\n\n## The problem\n\nSo after adopting best practices, and only using **Imports** in my packages, the problem is that some _imported_ packages \ndo not follow those best practices and rely on **Depends** for their dependencies, and consequently will not find \ntheir dependencies unless hacked.  \n\nSay we are writing a package **MyPkg**, that uses some functions from a CRAN package **A**, which lists a CRAN \npackage **B** in its Depends.\n\n_MyPkg::f_\n```\nf <- function() a()\n```\n_A::a_\n```\na <- function() b()\n```\n\n_B::b_\nb <- function() { ... }\n\n\nExecuting `f()` will find the function `a`, explicitly imported from package A. But executing `a()` will die because \nfunction `b` can not be found.\n\n## analysis\n\nBecause B is listed in the Depends of package A, `b()` is normally found in the _search path_, where namespace **B** is attached. \nWhat can we do to work around this problem ?  \nSadly, there is nothing we can do at the  **MyPkg** package level, since the problem sits in the **A** namespace.\nWe could of course lists B in the **MyPkg** Depends, but that is precisely what we want to avoid.\n\n## the dirty hack solution\n\n### the idea\n\nI suggest that you first have a look at this very good blog \n[How R Searches and Finds Stuff](http://obeautifulcode.com/R/How-R-Searches-And-Finds-Stuff/) if you need some \nclarification about namespaces and imports.  \n\n\nHere is a diagram of the current state of the problem:\n\n```{r echo=FALSE}\nsuppressPackageStartupMessages(library(diagram))\npar(mar = c(1, 1, 2, 1))\n\nnames <- c( \"MyPkg:\\nf()\", \"A:\\nA()\", \"B\\nb()\", \"MyPkg.Imports\\nA::a()\", \"A.Imports\", \"B.Imports\", \"Base\")\nn  <- length(names)\nM <- matrix(nrow = n, ncol = n, byrow = TRUE, data = 0)\n\nM[4, 1] <- M[7, 4] <- M[5, 2] <- M[7, 5] <- M[6, 3] <- M[7, 6]  <- \"\"\ncoords <- coordinates(c(3, 3, 1))\nplotmat(M, pos = coords, curve = 0, name = names, lwd = 1, box.lwd = 2, cex.txt = 0.8, box.type = \"circle\", box.prop = 1.0)\nstraightarrow(from = coords[4, ]+0.05, to = coords[2, ]-0.05, lty = 2, lcol = 2)\nmtext(outer = TRUE, side = 3, line = -1.5, cex = 1.5, \"Namespaces before\")\n```\n\n\nWe want the `a()` call, which is executed in namespace **A**, to find the **b** symbol in namespace **B**. \nTo achieve this, we will re-route the namespace **A** (actually its Imports namespace) to the **B** namespace:\n```\nnsa <- getNamespace('A')                      # package A environment\nnsa_imp <- parent.env(nsa)                    # package A Imports\nparent.env(nsa_imp) <- getNamespace('B')      # re-route A Imports to package B\n```\n\nNow our namespaces should look like this:  \n\n```{r echo=FALSE}\n\npar(mar = c(1, 1, 2, 1))\n\nnames <- c( \"MyPkg:\\nf()\", \"A:\\nA()\", \"B\\nb()\", \"MyPkg.Imports\\nA::a()\", \"A.Imports\", \"B.Imports\", \"Base\")\nn  <- length(names)\nM <- matrix(nrow = n, ncol = n, byrow = TRUE, data = 0)\n\nM[4, 1] <- M[7, 4] <- M[5, 2] <- M[6, 3] <- M[7, 6]  <- \"\"\nM[3, 5] <- \"New\"\ncoords <- coordinates(c(3, 3, 1))\nplotmat(M, pos = coords, curve = 0, name = names, lwd = 1, box.lwd = 2, cex.txt = 0.8, box.type = \"circle\", box.prop = 1.0)\nstraightarrow(from = coords[4, ]+0.05, to = coords[2, ]-0.05, lty = 2, lcol = 2)\nmtext(outer = TRUE, side = 3, line = -1.5, cex = 1.5, \"Namespaces after re-rerouting\")\n```\n\nNotice that the link From A Imports to base has been re-routed towards package B (the arrow labelled \"New\")\n\n## Example\n\n\nThe above code is not straightforward to test because you need to write a package.  \n\nHere is some reproducible code that illustrates how the hack works, so that you can simulate its mechanism\nright now by copy-pasting the following code in your R console.\nThis example uses package **multcomp** that _Depends_ on **mvtnorm**. \n\n```{r}\n## load multcomp package, and its imports, but do not attach them in the search path\nl <- loadNamespace('multcomp') # assignment to avoid annoying print\n\namod <- aov(breaks ~ wool + tension, data = warpbreaks)\nwht <- multcomp::glht(amod, linfct = multcomp::mcp(tension = \"Tukey\"))\nci <- confint(wht) # mvtnorm::qmvt is not found, because mvtnorm is not attached to the search path\n\n# let's load the mvtnorm namespace \nl <- loadNamespace('mvtnorm')\nci <- confint(wht) # mvtnorm::qmvt still not found, mvtnorm is loaded but not attached\n\n# hack hack hack: re-route package multcomp to mvtnorm\nns1 <- getNamespace('multcomp')\nns1_imp <- parent.env(ns1)\nparent.env(ns1_imp) <- getNamespace('mvtnorm')\n\nci <- confint(wht) # now should work\nprint(ci)\n\n```\n\n## implementation of the hack in MyPkg\n\nJust put the re-routing code in your MyPkg **.onLoad** function, defined usually in `R/zzz.R`:\n\n```\n.onLoad <- function(libname, pkgname) {\n    nsa <- getNamespace('A')\n    nsa_imp <- parent.env(nsa)\n    parent.env(nsa_imp) <- getNamespace('B')    \n}\n```\n\n### why dirty ?\n\nFirst of all, it uses `parent.env<-`, and according to the documentation:\n>The replacement function parent.env<- is extremely dangerous as it can be used to destructively change environments in ways >that violate assumptions made by the internal C code. It may be removed in the near future.\n\nIt is a pity because it can be extremely useful.\n\n### why a hack ?\n\nUnfortunately it does not work in the general case. \nSuppose you need two packages A and D, that both depend on B and C, but with different rules:\n```\nA -> B -> C\nD -> C -> B\n```\nIn that case, we would re-route A to B, then B to C. And this is incompatible with the way D is designed, resulting in\nwrong symbol picks if symbols with same name are both defined by B and C.\n\n### so what ?\n\nWe'll see in a future post a probably much better solution.\n\n\n_Karl Forner @ Quartz Bio_\n\n"}],"tags":{"linear model, univariate":{"pages":[{"title":"Combine car, multcomp and phia to perform smarter linear modeling","file":"interaction_terms_analysis_phia.Rmd","date":15852,"link":"interaction_terms_analysis_phia.html"}],"name":"linear model, univariate","count":1},"package namespace imports depends":{"pages":[{"title":"A dirty hack for importing packages that use Depends","file":"package-depends-dirty-hack-solution.Rmd","date":15852,"link":"package-depends-dirty-hack-solution.html"}],"name":"package namespace imports depends","count":1},"all":[{"pages":[{"title":"Combine car, multcomp and phia to perform smarter linear modeling","file":"interaction_terms_analysis_phia.Rmd","date":15852,"link":"interaction_terms_analysis_phia.html"}],"name":"linear model, univariate","count":1},{"pages":[{"title":"A dirty hack for importing packages that use Depends","file":"package-depends-dirty-hack-solution.Rmd","date":15852,"link":"package-depends-dirty-hack-solution.html"}],"name":"package namespace imports depends","count":1}]},"page":{"url":{"assets":"../assets","lib":"../libraries","widgets":"../libraries/widgets","framework":"../libraries/frameworks/qb_rss","theme":"../libraries/frameworks/qb_rss/","highlighters":"../libraries/highlighters","layouts":["../libraries/frameworks/qb_rss/layouts","../assets/layouts"],"highlighter":"../libraries/highlighters/prettify"},"framework":"qb_rss","theme":"","highlighter":"prettify","hitheme":"twitter-bootstrap","copy_libraries":true,"mode":"selfcontained","widgets":[],"prettify":{"linenums":true},"title":"A dirty hack for importing packages that use Depends","author":"Karl Forner","license":"GPL (>= 2)","tags":"package namespace imports depends","summary":"A dirty hack for importing packages that use Depends","date":15852,"slides":[{"html":"<h2>Scope</h2>\n\n<p>This article is about R package development.</p>\n\n<h2>Motivation</h2>\n\n<p>As stated in the the <em>Writing R Extensions</em> manual and the <em>Software for Data Analysis</em> book (aka the R bible), packages should\nwhenever possible use <strong>Imports</strong> instead of <strong>Depends</strong>, to avoid name collision (masking) and ensure trustworthy computations. \nSee <a href=\"http://stackoverflow.com/questions/8637993/better-explanation-of-when-to-use-imports-depends\">this discussion on Stackoverflow</a>.</p>\n\n<h2>The problem</h2>\n\n<p>So after adopting best practices, and only using <strong>Imports</strong> in my packages, the problem is that some <em>imported</em> packages \ndo not follow those best practices and rely on <strong>Depends</strong> for their dependencies, and consequently will not find \ntheir dependencies unless hacked.  </p>\n\n<p>Say we are writing a package <strong>MyPkg</strong>, that uses some functions from a CRAN package <strong>A</strong>, which lists a CRAN \npackage <strong>B</strong> in its Depends.</p>\n\n<p><em>MyPkg::f</em></p>\n\n<pre><code>f &lt;- function() a()\n</code></pre>\n\n<p><em>A::a</em></p>\n\n<pre><code>a &lt;- function() b()\n</code></pre>\n\n<p><em>B::b</em>\nb &lt;- function() { ... }</p>\n\n<p>Executing <code>f()</code> will find the function <code>a</code>, explicitly imported from package A. But executing <code>a()</code> will die because \nfunction <code>b</code> can not be found.</p>\n\n<h2>analysis</h2>\n\n<p>Because B is listed in the Depends of package A, <code>b()</code> is normally found in the <em>search path</em>, where namespace <strong>B</strong> is attached. \nWhat can we do to work around this problem ?<br>\nSadly, there is nothing we can do at the  <strong>MyPkg</strong> package level, since the problem sits in the <strong>A</strong> namespace.\nWe could of course lists B in the <strong>MyPkg</strong> Depends, but that is precisely what we want to avoid.</p>\n\n<h2>the dirty hack solution</h2>\n\n<h3>the idea</h3>\n\n<p>I suggest that you first have a look at this very good blog \n<a href=\"http://obeautifulcode.com/R/How-R-Searches-And-Finds-Stuff/\">How R Searches and Finds Stuff</a> if you need some \nclarification about namespaces and imports.  </p>\n\n<p>Here is a diagram of the current state of the problem:</p>\n\n<p><img src=\"assets/fig/unnamed-chunk-1.png\" alt=\"plot of chunk unnamed-chunk-1\"> </p>\n\n<p>We want the <code>a()</code> call, which is executed in namespace <strong>A</strong>, to find the <strong>b</strong> symbol in namespace <strong>B</strong>. \nTo achieve this, we will re-route the namespace <strong>A</strong> (actually its Imports namespace) to the <strong>B</strong> namespace:</p>\n\n<pre><code>nsa &lt;- getNamespace(&#39;A&#39;)                      # package A environment\nnsa_imp &lt;- parent.env(nsa)                    # package A Imports\nparent.env(nsa_imp) &lt;- getNamespace(&#39;B&#39;)      # re-route A Imports to package B\n</code></pre>\n\n<p>Now our namespaces should look like this:  </p>\n\n<p><img src=\"assets/fig/unnamed-chunk-2.png\" alt=\"plot of chunk unnamed-chunk-2\"> </p>\n\n<p>Notice that the link From A Imports to base has been re-routed towards package B (the arrow labelled &quot;New&quot;)</p>\n\n<h2>Example</h2>\n\n<p>The above code is not straightforward to test because you need to write a package.  </p>\n\n<p>Here is some reproducible code that illustrates how the hack works, so that you can simulate its mechanism\nright now by copy-pasting the following code in your R console.\nThis example uses package <strong>multcomp</strong> that <em>Depends</em> on <strong>mvtnorm</strong>. </p>\n\n<pre><code class=\"r\">## load multcomp package, and its imports, but do not attach them in the\n## search path\nl &lt;- loadNamespace(&quot;multcomp&quot;)  # assignment to avoid annoying print\n\namod &lt;- aov(breaks ~ wool + tension, data = warpbreaks)\nwht &lt;- multcomp::glht(amod, linfct = multcomp::mcp(tension = &quot;Tukey&quot;))\nci &lt;- confint(wht)  # mvtnorm::qmvt is not found, because mvtnorm is not attached to the search path\n\n# let&#39;s load the mvtnorm namespace\nl &lt;- loadNamespace(&quot;mvtnorm&quot;)\nci &lt;- confint(wht)  # mvtnorm::qmvt still not found, mvtnorm is loaded but not attached\n\n# hack hack hack: re-route package multcomp to mvtnorm\nns1 &lt;- getNamespace(&quot;multcomp&quot;)\nns1_imp &lt;- parent.env(ns1)\nparent.env(ns1_imp) &lt;- getNamespace(&quot;mvtnorm&quot;)\n\nci &lt;- confint(wht)  # now should work\nprint(ci)\n</code></pre>\n\n<pre><code>## \n##   Simultaneous Confidence Intervals\n## \n## Multiple Comparisons of Means: Tukey Contrasts\n## \n## \n## Fit: aov(formula = breaks ~ wool + tension, data = warpbreaks)\n## \n## Quantile = 2.415\n## 95% family-wise confidence level\n##  \n## \n## Linear Hypotheses:\n##            Estimate lwr     upr    \n## M - L == 0 -10.000  -19.354  -0.646\n## H - L == 0 -14.722  -24.076  -5.369\n## H - M == 0  -4.722  -14.076   4.631\n</code></pre>\n\n<h2>implementation of the hack in MyPkg</h2>\n\n<p>Just put the re-routing code in your MyPkg <strong>.onLoad</strong> function, defined usually in <code>R/zzz.R</code>:</p>\n\n<pre><code>.onLoad &lt;- function(libname, pkgname) {\n    nsa &lt;- getNamespace(&#39;A&#39;)\n    nsa_imp &lt;- parent.env(nsa)\n    parent.env(nsa_imp) &lt;- getNamespace(&#39;B&#39;)    \n}\n</code></pre>\n\n<h3>why dirty ?</h3>\n\n<p>First of all, it uses <code>parent.env&lt;-</code>, and according to the documentation:</p>\n\n<blockquote>\n<p>The replacement function parent.env&lt;- is extremely dangerous as it can be used to destructively change environments in ways &gt;that violate assumptions made by the internal C code. It may be removed in the near future.</p>\n</blockquote>\n\n<p>It is a pity because it can be extremely useful.</p>\n\n<h3>why a hack ?</h3>\n\n<p>Unfortunately it does not work in the general case. \nSuppose you need two packages A and D, that both depend on B and C, but with different rules:</p>\n\n<pre><code>A -&gt; B -&gt; C\nD -&gt; C -&gt; B\n</code></pre>\n\n<p>In that case, we would re-route A to B, then B to C. And this is incompatible with the way D is designed, resulting in\nwrong symbol picks if symbols with same name are both defined by B and C.</p>\n\n<h3>so what ?</h3>\n\n<p>We&#39;ll see in a future post a probably much better solution.</p>\n\n<p><em>Karl Forner @ Quartz Bio</em></p>\n","header":"<h2>Scope</h2>","level":"2","title":"Scope","content":"<p>This article is about R package development.</p>\n\n<h2>Motivation</h2>\n\n<p>As stated in the the <em>Writing R Extensions</em> manual and the <em>Software for Data Analysis</em> book (aka the R bible), packages should\nwhenever possible use <strong>Imports</strong> instead of <strong>Depends</strong>, to avoid name collision (masking) and ensure trustworthy computations. \nSee <a href=\"http://stackoverflow.com/questions/8637993/better-explanation-of-when-to-use-imports-depends\">this discussion on Stackoverflow</a>.</p>\n\n<h2>The problem</h2>\n\n<p>So after adopting best practices, and only using <strong>Imports</strong> in my packages, the problem is that some <em>imported</em> packages \ndo not follow those best practices and rely on <strong>Depends</strong> for their dependencies, and consequently will not find \ntheir dependencies unless hacked.  </p>\n\n<p>Say we are writing a package <strong>MyPkg</strong>, that uses some functions from a CRAN package <strong>A</strong>, which lists a CRAN \npackage <strong>B</strong> in its Depends.</p>\n\n<p><em>MyPkg::f</em></p>\n\n<pre><code>f &lt;- function() a()\n</code></pre>\n\n<p><em>A::a</em></p>\n\n<pre><code>a &lt;- function() b()\n</code></pre>\n\n<p><em>B::b</em>\nb &lt;- function() { ... }</p>\n\n<p>Executing <code>f()</code> will find the function <code>a</code>, explicitly imported from package A. But executing <code>a()</code> will die because \nfunction <code>b</code> can not be found.</p>\n\n<h2>analysis</h2>\n\n<p>Because B is listed in the Depends of package A, <code>b()</code> is normally found in the <em>search path</em>, where namespace <strong>B</strong> is attached. \nWhat can we do to work around this problem ?<br>\nSadly, there is nothing we can do at the  <strong>MyPkg</strong> package level, since the problem sits in the <strong>A</strong> namespace.\nWe could of course lists B in the <strong>MyPkg</strong> Depends, but that is precisely what we want to avoid.</p>\n\n<h2>the dirty hack solution</h2>\n\n<h3>the idea</h3>\n\n<p>I suggest that you first have a look at this very good blog \n<a href=\"http://obeautifulcode.com/R/How-R-Searches-And-Finds-Stuff/\">How R Searches and Finds Stuff</a> if you need some \nclarification about namespaces and imports.  </p>\n\n<p>Here is a diagram of the current state of the problem:</p>\n\n<p><img src=\"assets/fig/unnamed-chunk-1.png\" alt=\"plot of chunk unnamed-chunk-1\"> </p>\n\n<p>We want the <code>a()</code> call, which is executed in namespace <strong>A</strong>, to find the <strong>b</strong> symbol in namespace <strong>B</strong>. \nTo achieve this, we will re-route the namespace <strong>A</strong> (actually its Imports namespace) to the <strong>B</strong> namespace:</p>\n\n<pre><code>nsa &lt;- getNamespace(&#39;A&#39;)                      # package A environment\nnsa_imp &lt;- parent.env(nsa)                    # package A Imports\nparent.env(nsa_imp) &lt;- getNamespace(&#39;B&#39;)      # re-route A Imports to package B\n</code></pre>\n\n<p>Now our namespaces should look like this:  </p>\n\n<p><img src=\"assets/fig/unnamed-chunk-2.png\" alt=\"plot of chunk unnamed-chunk-2\"> </p>\n\n<p>Notice that the link From A Imports to base has been re-routed towards package B (the arrow labelled &quot;New&quot;)</p>\n\n<h2>Example</h2>\n\n<p>The above code is not straightforward to test because you need to write a package.  </p>\n\n<p>Here is some reproducible code that illustrates how the hack works, so that you can simulate its mechanism\nright now by copy-pasting the following code in your R console.\nThis example uses package <strong>multcomp</strong> that <em>Depends</em> on <strong>mvtnorm</strong>. </p>\n\n<pre><code class=\"r\">## load multcomp package, and its imports, but do not attach them in the\n## search path\nl &lt;- loadNamespace(&quot;multcomp&quot;)  # assignment to avoid annoying print\n\namod &lt;- aov(breaks ~ wool + tension, data = warpbreaks)\nwht &lt;- multcomp::glht(amod, linfct = multcomp::mcp(tension = &quot;Tukey&quot;))\nci &lt;- confint(wht)  # mvtnorm::qmvt is not found, because mvtnorm is not attached to the search path\n\n# let&#39;s load the mvtnorm namespace\nl &lt;- loadNamespace(&quot;mvtnorm&quot;)\nci &lt;- confint(wht)  # mvtnorm::qmvt still not found, mvtnorm is loaded but not attached\n\n# hack hack hack: re-route package multcomp to mvtnorm\nns1 &lt;- getNamespace(&quot;multcomp&quot;)\nns1_imp &lt;- parent.env(ns1)\nparent.env(ns1_imp) &lt;- getNamespace(&quot;mvtnorm&quot;)\n\nci &lt;- confint(wht)  # now should work\nprint(ci)\n</code></pre>\n\n<pre><code>## \n##   Simultaneous Confidence Intervals\n## \n## Multiple Comparisons of Means: Tukey Contrasts\n## \n## \n## Fit: aov(formula = breaks ~ wool + tension, data = warpbreaks)\n## \n## Quantile = 2.415\n## 95% family-wise confidence level\n##  \n## \n## Linear Hypotheses:\n##            Estimate lwr     upr    \n## M - L == 0 -10.000  -19.354  -0.646\n## H - L == 0 -14.722  -24.076  -5.369\n## H - M == 0  -4.722  -14.076   4.631\n</code></pre>\n\n<h2>implementation of the hack in MyPkg</h2>\n\n<p>Just put the re-routing code in your MyPkg <strong>.onLoad</strong> function, defined usually in <code>R/zzz.R</code>:</p>\n\n<pre><code>.onLoad &lt;- function(libname, pkgname) {\n    nsa &lt;- getNamespace(&#39;A&#39;)\n    nsa_imp &lt;- parent.env(nsa)\n    parent.env(nsa_imp) &lt;- getNamespace(&#39;B&#39;)    \n}\n</code></pre>\n\n<h3>why dirty ?</h3>\n\n<p>First of all, it uses <code>parent.env&lt;-</code>, and according to the documentation:</p>\n\n<blockquote>\n<p>The replacement function parent.env&lt;- is extremely dangerous as it can be used to destructively change environments in ways &gt;that violate assumptions made by the internal C code. It may be removed in the near future.</p>\n</blockquote>\n\n<p>It is a pity because it can be extremely useful.</p>\n\n<h3>why a hack ?</h3>\n\n<p>Unfortunately it does not work in the general case. \nSuppose you need two packages A and D, that both depend on B and C, but with different rules:</p>\n\n<pre><code>A -&gt; B -&gt; C\nD -&gt; C -&gt; B\n</code></pre>\n\n<p>In that case, we would re-route A to B, then B to C. And this is incompatible with the way D is designed, resulting in\nwrong symbol picks if symbols with same name are both defined by B and C.</p>\n\n<h3>so what ?</h3>\n\n<p>We&#39;ll see in a future post a probably much better solution.</p>\n\n<p><em>Karl Forner @ Quartz Bio</em></p>\n","num":1,"id":"slide-1","raw":"--- \n\n## Scope\n\nThis article is about R package development.\n\n## Motivation\n\nAs stated in the the _Writing R Extensions_ manual and the _Software for Data Analysis_ book (aka the R bible), packages should\nwhenever possible use **Imports** instead of **Depends**, to avoid name collision (masking) and ensure trustworthy computations. \nSee [this discussion on Stackoverflow](http://stackoverflow.com/questions/8637993/better-explanation-of-when-to-use-imports-depends).\n\n## The problem\n\nSo after adopting best practices, and only using **Imports** in my packages, the problem is that some _imported_ packages \ndo not follow those best practices and rely on **Depends** for their dependencies, and consequently will not find \ntheir dependencies unless hacked.  \n\nSay we are writing a package **MyPkg**, that uses some functions from a CRAN package **A**, which lists a CRAN \npackage **B** in its Depends.\n\n_MyPkg::f_\n```\nf <- function() a()\n```\n_A::a_\n```\na <- function() b()\n```\n\n_B::b_\nb <- function() { ... }\n\n\nExecuting `f()` will find the function `a`, explicitly imported from package A. But executing `a()` will die because \nfunction `b` can not be found.\n\n## analysis\n\nBecause B is listed in the Depends of package A, `b()` is normally found in the _search path_, where namespace **B** is attached. \nWhat can we do to work around this problem ?  \nSadly, there is nothing we can do at the  **MyPkg** package level, since the problem sits in the **A** namespace.\nWe could of course lists B in the **MyPkg** Depends, but that is precisely what we want to avoid.\n\n## the dirty hack solution\n\n### the idea\n\nI suggest that you first have a look at this very good blog \n[How R Searches and Finds Stuff](http://obeautifulcode.com/R/How-R-Searches-And-Finds-Stuff/) if you need some \nclarification about namespaces and imports.  \n\n\nHere is a diagram of the current state of the problem:\n\n```{r echo=FALSE}\nsuppressPackageStartupMessages(library(diagram))\npar(mar = c(1, 1, 2, 1))\n\nnames <- c( \"MyPkg:\\nf()\", \"A:\\nA()\", \"B\\nb()\", \"MyPkg.Imports\\nA::a()\", \"A.Imports\", \"B.Imports\", \"Base\")\nn  <- length(names)\nM <- matrix(nrow = n, ncol = n, byrow = TRUE, data = 0)\n\nM[4, 1] <- M[7, 4] <- M[5, 2] <- M[7, 5] <- M[6, 3] <- M[7, 6]  <- \"\"\ncoords <- coordinates(c(3, 3, 1))\nplotmat(M, pos = coords, curve = 0, name = names, lwd = 1, box.lwd = 2, cex.txt = 0.8, box.type = \"circle\", box.prop = 1.0)\nstraightarrow(from = coords[4, ]+0.05, to = coords[2, ]-0.05, lty = 2, lcol = 2)\nmtext(outer = TRUE, side = 3, line = -1.5, cex = 1.5, \"Namespaces before\")\n```\n\n\nWe want the `a()` call, which is executed in namespace **A**, to find the **b** symbol in namespace **B**. \nTo achieve this, we will re-route the namespace **A** (actually its Imports namespace) to the **B** namespace:\n```\nnsa <- getNamespace('A')                      # package A environment\nnsa_imp <- parent.env(nsa)                    # package A Imports\nparent.env(nsa_imp) <- getNamespace('B')      # re-route A Imports to package B\n```\n\nNow our namespaces should look like this:  \n\n```{r echo=FALSE}\n\npar(mar = c(1, 1, 2, 1))\n\nnames <- c( \"MyPkg:\\nf()\", \"A:\\nA()\", \"B\\nb()\", \"MyPkg.Imports\\nA::a()\", \"A.Imports\", \"B.Imports\", \"Base\")\nn  <- length(names)\nM <- matrix(nrow = n, ncol = n, byrow = TRUE, data = 0)\n\nM[4, 1] <- M[7, 4] <- M[5, 2] <- M[6, 3] <- M[7, 6]  <- \"\"\nM[3, 5] <- \"New\"\ncoords <- coordinates(c(3, 3, 1))\nplotmat(M, pos = coords, curve = 0, name = names, lwd = 1, box.lwd = 2, cex.txt = 0.8, box.type = \"circle\", box.prop = 1.0)\nstraightarrow(from = coords[4, ]+0.05, to = coords[2, ]-0.05, lty = 2, lcol = 2)\nmtext(outer = TRUE, side = 3, line = -1.5, cex = 1.5, \"Namespaces after re-rerouting\")\n```\n\nNotice that the link From A Imports to base has been re-routed towards package B (the arrow labelled \"New\")\n\n## Example\n\n\nThe above code is not straightforward to test because you need to write a package.  \n\nHere is some reproducible code that illustrates how the hack works, so that you can simulate its mechanism\nright now by copy-pasting the following code in your R console.\nThis example uses package **multcomp** that _Depends_ on **mvtnorm**. \n\n```{r}\n## load multcomp package, and its imports, but do not attach them in the search path\nl <- loadNamespace('multcomp') # assignment to avoid annoying print\n\namod <- aov(breaks ~ wool + tension, data = warpbreaks)\nwht <- multcomp::glht(amod, linfct = multcomp::mcp(tension = \"Tukey\"))\nci <- confint(wht) # mvtnorm::qmvt is not found, because mvtnorm is not attached to the search path\n\n# let's load the mvtnorm namespace \nl <- loadNamespace('mvtnorm')\nci <- confint(wht) # mvtnorm::qmvt still not found, mvtnorm is loaded but not attached\n\n# hack hack hack: re-route package multcomp to mvtnorm\nns1 <- getNamespace('multcomp')\nns1_imp <- parent.env(ns1)\nparent.env(ns1_imp) <- getNamespace('mvtnorm')\n\nci <- confint(wht) # now should work\nprint(ci)\n\n```\n\n## implementation of the hack in MyPkg\n\nJust put the re-routing code in your MyPkg **.onLoad** function, defined usually in `R/zzz.R`:\n\n```\n.onLoad <- function(libname, pkgname) {\n    nsa <- getNamespace('A')\n    nsa_imp <- parent.env(nsa)\n    parent.env(nsa_imp) <- getNamespace('B')    \n}\n```\n\n### why dirty ?\n\nFirst of all, it uses `parent.env<-`, and according to the documentation:\n>The replacement function parent.env<- is extremely dangerous as it can be used to destructively change environments in ways >that violate assumptions made by the internal C code. It may be removed in the near future.\n\nIt is a pity because it can be extremely useful.\n\n### why a hack ?\n\nUnfortunately it does not work in the general case. \nSuppose you need two packages A and D, that both depend on B and C, but with different rules:\n```\nA -> B -> C\nD -> C -> B\n```\nIn that case, we would re-route A to B, then B to C. And this is incompatible with the way D is designed, resulting in\nwrong symbol picks if symbols with same name are both defined by B and C.\n\n### so what ?\n\nWe'll see in a future post a probably much better solution.\n\n\n_Karl Forner @ Quartz Bio_\n\n","rendered":"<h2>Scope</h2>\n<p>This article is about R package development.</p>\n\n<h2>Motivation</h2>\n\n<p>As stated in the the <em>Writing R Extensions</em> manual and the <em>Software for Data Analysis</em> book (aka the R bible), packages should\nwhenever possible use <strong>Imports</strong> instead of <strong>Depends</strong>, to avoid name collision (masking) and ensure trustworthy computations. \nSee <a href=\"http://stackoverflow.com/questions/8637993/better-explanation-of-when-to-use-imports-depends\">this discussion on Stackoverflow</a>.</p>\n\n<h2>The problem</h2>\n\n<p>So after adopting best practices, and only using <strong>Imports</strong> in my packages, the problem is that some <em>imported</em> packages \ndo not follow those best practices and rely on <strong>Depends</strong> for their dependencies, and consequently will not find \ntheir dependencies unless hacked.  </p>\n\n<p>Say we are writing a package <strong>MyPkg</strong>, that uses some functions from a CRAN package <strong>A</strong>, which lists a CRAN \npackage <strong>B</strong> in its Depends.</p>\n\n<p><em>MyPkg::f</em></p>\n\n<pre><code>f &lt;- function() a()\n</code></pre>\n\n<p><em>A::a</em></p>\n\n<pre><code>a &lt;- function() b()\n</code></pre>\n\n<p><em>B::b</em>\nb &lt;- function() { ... }</p>\n\n<p>Executing <code>f()</code> will find the function <code>a</code>, explicitly imported from package A. But executing <code>a()</code> will die because \nfunction <code>b</code> can not be found.</p>\n\n<h2>analysis</h2>\n\n<p>Because B is listed in the Depends of package A, <code>b()</code> is normally found in the <em>search path</em>, where namespace <strong>B</strong> is attached. \nWhat can we do to work around this problem ?<br>\nSadly, there is nothing we can do at the  <strong>MyPkg</strong> package level, since the problem sits in the <strong>A</strong> namespace.\nWe could of course lists B in the <strong>MyPkg</strong> Depends, but that is precisely what we want to avoid.</p>\n\n<h2>the dirty hack solution</h2>\n\n<h3>the idea</h3>\n\n<p>I suggest that you first have a look at this very good blog \n<a href=\"http://obeautifulcode.com/R/How-R-Searches-And-Finds-Stuff/\">How R Searches and Finds Stuff</a> if you need some \nclarification about namespaces and imports.  </p>\n\n<p>Here is a diagram of the current state of the problem:</p>\n\n<p><img src=\"assets/fig/unnamed-chunk-1.png\" alt=\"plot of chunk unnamed-chunk-1\"> </p>\n\n<p>We want the <code>a()</code> call, which is executed in namespace <strong>A</strong>, to find the <strong>b</strong> symbol in namespace <strong>B</strong>. \nTo achieve this, we will re-route the namespace <strong>A</strong> (actually its Imports namespace) to the <strong>B</strong> namespace:</p>\n\n<pre><code>nsa &lt;- getNamespace(&#39;A&#39;)                      # package A environment\nnsa_imp &lt;- parent.env(nsa)                    # package A Imports\nparent.env(nsa_imp) &lt;- getNamespace(&#39;B&#39;)      # re-route A Imports to package B\n</code></pre>\n\n<p>Now our namespaces should look like this:  </p>\n\n<p><img src=\"assets/fig/unnamed-chunk-2.png\" alt=\"plot of chunk unnamed-chunk-2\"> </p>\n\n<p>Notice that the link From A Imports to base has been re-routed towards package B (the arrow labelled &quot;New&quot;)</p>\n\n<h2>Example</h2>\n\n<p>The above code is not straightforward to test because you need to write a package.  </p>\n\n<p>Here is some reproducible code that illustrates how the hack works, so that you can simulate its mechanism\nright now by copy-pasting the following code in your R console.\nThis example uses package <strong>multcomp</strong> that <em>Depends</em> on <strong>mvtnorm</strong>. </p>\n\n<pre><code class=\"r\">## load multcomp package, and its imports, but do not attach them in the\n## search path\nl &lt;- loadNamespace(&quot;multcomp&quot;)  # assignment to avoid annoying print\n\namod &lt;- aov(breaks ~ wool + tension, data = warpbreaks)\nwht &lt;- multcomp::glht(amod, linfct = multcomp::mcp(tension = &quot;Tukey&quot;))\nci &lt;- confint(wht)  # mvtnorm::qmvt is not found, because mvtnorm is not attached to the search path\n\n# let&#39;s load the mvtnorm namespace\nl &lt;- loadNamespace(&quot;mvtnorm&quot;)\nci &lt;- confint(wht)  # mvtnorm::qmvt still not found, mvtnorm is loaded but not attached\n\n# hack hack hack: re-route package multcomp to mvtnorm\nns1 &lt;- getNamespace(&quot;multcomp&quot;)\nns1_imp &lt;- parent.env(ns1)\nparent.env(ns1_imp) &lt;- getNamespace(&quot;mvtnorm&quot;)\n\nci &lt;- confint(wht)  # now should work\nprint(ci)\n</code></pre>\n\n<pre><code>## \n##   Simultaneous Confidence Intervals\n## \n## Multiple Comparisons of Means: Tukey Contrasts\n## \n## \n## Fit: aov(formula = breaks ~ wool + tension, data = warpbreaks)\n## \n## Quantile = 2.415\n## 95% family-wise confidence level\n##  \n## \n## Linear Hypotheses:\n##            Estimate lwr     upr    \n## M - L == 0 -10.000  -19.354  -0.646\n## H - L == 0 -14.722  -24.076  -5.369\n## H - M == 0  -4.722  -14.076   4.631\n</code></pre>\n\n<h2>implementation of the hack in MyPkg</h2>\n\n<p>Just put the re-routing code in your MyPkg <strong>.onLoad</strong> function, defined usually in <code>R/zzz.R</code>:</p>\n\n<pre><code>.onLoad &lt;- function(libname, pkgname) {\n    nsa &lt;- getNamespace(&#39;A&#39;)\n    nsa_imp &lt;- parent.env(nsa)\n    parent.env(nsa_imp) &lt;- getNamespace(&#39;B&#39;)    \n}\n</code></pre>\n\n<h3>why dirty ?</h3>\n\n<p>First of all, it uses <code>parent.env&lt;-</code>, and according to the documentation:</p>\n\n<blockquote>\n<p>The replacement function parent.env&lt;- is extremely dangerous as it can be used to destructively change environments in ways &gt;that violate assumptions made by the internal C code. It may be removed in the near future.</p>\n</blockquote>\n\n<p>It is a pity because it can be extremely useful.</p>\n\n<h3>why a hack ?</h3>\n\n<p>Unfortunately it does not work in the general case. \nSuppose you need two packages A and D, that both depend on B and C, but with different rules:</p>\n\n<pre><code>A -&gt; B -&gt; C\nD -&gt; C -&gt; B\n</code></pre>\n\n<p>In that case, we would re-route A to B, then B to C. And this is incompatible with the way D is designed, resulting in\nwrong symbol picks if symbols with same name are both defined by B and C.</p>\n\n<h3>so what ?</h3>\n\n<p>We&#39;ll see in a future post a probably much better solution.</p>\n\n<p><em>Karl Forner @ Quartz Bio</em></p>\n"}],"standalone":false,"file":"package-depends-dirty-hack-solution.Rmd","filename":"package-depends-dirty-hack-solution","link":"package-depends-dirty-hack-solution.html","raw":"---\ntitle: A dirty hack for importing packages that use Depends\nauthor: Karl Forner\nlicense: GPL (>= 2)\ntags: package namespace imports depends\nsummary: A dirty hack for importing packages that use Depends\ndate: 2013-05-27\n---\n\n## Scope\n\nThis article is about R package development.\n\n## Motivation\n\nAs stated in the the _Writing R Extensions_ manual and the _Software for Data Analysis_ book (aka the R bible), packages should\nwhenever possible use **Imports** instead of **Depends**, to avoid name collision (masking) and ensure trustworthy computations. \nSee [this discussion on Stackoverflow](http://stackoverflow.com/questions/8637993/better-explanation-of-when-to-use-imports-depends).\n\n## The problem\n\nSo after adopting best practices, and only using **Imports** in my packages, the problem is that some _imported_ packages \ndo not follow those best practices and rely on **Depends** for their dependencies, and consequently will not find \ntheir dependencies unless hacked.  \n\nSay we are writing a package **MyPkg**, that uses some functions from a CRAN package **A**, which lists a CRAN \npackage **B** in its Depends.\n\n_MyPkg::f_\n```\nf <- function() a()\n```\n_A::a_\n```\na <- function() b()\n```\n\n_B::b_\nb <- function() { ... }\n\n\nExecuting `f()` will find the function `a`, explicitly imported from package A. But executing `a()` will die because \nfunction `b` can not be found.\n\n## analysis\n\nBecause B is listed in the Depends of package A, `b()` is normally found in the _search path_, where namespace **B** is attached. \nWhat can we do to work around this problem ?  \nSadly, there is nothing we can do at the  **MyPkg** package level, since the problem sits in the **A** namespace.\nWe could of course lists B in the **MyPkg** Depends, but that is precisely what we want to avoid.\n\n## the dirty hack solution\n\n### the idea\n\nI suggest that you first have a look at this very good blog \n[How R Searches and Finds Stuff](http://obeautifulcode.com/R/How-R-Searches-And-Finds-Stuff/) if you need some \nclarification about namespaces and imports.  \n\n\nHere is a diagram of the current state of the problem:\n\n```{r echo=FALSE}\nsuppressPackageStartupMessages(library(diagram))\npar(mar = c(1, 1, 2, 1))\n\nnames <- c( \"MyPkg:\\nf()\", \"A:\\nA()\", \"B\\nb()\", \"MyPkg.Imports\\nA::a()\", \"A.Imports\", \"B.Imports\", \"Base\")\nn  <- length(names)\nM <- matrix(nrow = n, ncol = n, byrow = TRUE, data = 0)\n\nM[4, 1] <- M[7, 4] <- M[5, 2] <- M[7, 5] <- M[6, 3] <- M[7, 6]  <- \"\"\ncoords <- coordinates(c(3, 3, 1))\nplotmat(M, pos = coords, curve = 0, name = names, lwd = 1, box.lwd = 2, cex.txt = 0.8, box.type = \"circle\", box.prop = 1.0)\nstraightarrow(from = coords[4, ]+0.05, to = coords[2, ]-0.05, lty = 2, lcol = 2)\nmtext(outer = TRUE, side = 3, line = -1.5, cex = 1.5, \"Namespaces before\")\n```\n\n\nWe want the `a()` call, which is executed in namespace **A**, to find the **b** symbol in namespace **B**. \nTo achieve this, we will re-route the namespace **A** (actually its Imports namespace) to the **B** namespace:\n```\nnsa <- getNamespace('A')                      # package A environment\nnsa_imp <- parent.env(nsa)                    # package A Imports\nparent.env(nsa_imp) <- getNamespace('B')      # re-route A Imports to package B\n```\n\nNow our namespaces should look like this:  \n\n```{r echo=FALSE}\n\npar(mar = c(1, 1, 2, 1))\n\nnames <- c( \"MyPkg:\\nf()\", \"A:\\nA()\", \"B\\nb()\", \"MyPkg.Imports\\nA::a()\", \"A.Imports\", \"B.Imports\", \"Base\")\nn  <- length(names)\nM <- matrix(nrow = n, ncol = n, byrow = TRUE, data = 0)\n\nM[4, 1] <- M[7, 4] <- M[5, 2] <- M[6, 3] <- M[7, 6]  <- \"\"\nM[3, 5] <- \"New\"\ncoords <- coordinates(c(3, 3, 1))\nplotmat(M, pos = coords, curve = 0, name = names, lwd = 1, box.lwd = 2, cex.txt = 0.8, box.type = \"circle\", box.prop = 1.0)\nstraightarrow(from = coords[4, ]+0.05, to = coords[2, ]-0.05, lty = 2, lcol = 2)\nmtext(outer = TRUE, side = 3, line = -1.5, cex = 1.5, \"Namespaces after re-rerouting\")\n```\n\nNotice that the link From A Imports to base has been re-routed towards package B (the arrow labelled \"New\")\n\n## Example\n\n\nThe above code is not straightforward to test because you need to write a package.  \n\nHere is some reproducible code that illustrates how the hack works, so that you can simulate its mechanism\nright now by copy-pasting the following code in your R console.\nThis example uses package **multcomp** that _Depends_ on **mvtnorm**. \n\n```{r}\n## load multcomp package, and its imports, but do not attach them in the search path\nl <- loadNamespace('multcomp') # assignment to avoid annoying print\n\namod <- aov(breaks ~ wool + tension, data = warpbreaks)\nwht <- multcomp::glht(amod, linfct = multcomp::mcp(tension = \"Tukey\"))\nci <- confint(wht) # mvtnorm::qmvt is not found, because mvtnorm is not attached to the search path\n\n# let's load the mvtnorm namespace \nl <- loadNamespace('mvtnorm')\nci <- confint(wht) # mvtnorm::qmvt still not found, mvtnorm is loaded but not attached\n\n# hack hack hack: re-route package multcomp to mvtnorm\nns1 <- getNamespace('multcomp')\nns1_imp <- parent.env(ns1)\nparent.env(ns1_imp) <- getNamespace('mvtnorm')\n\nci <- confint(wht) # now should work\nprint(ci)\n\n```\n\n## implementation of the hack in MyPkg\n\nJust put the re-routing code in your MyPkg **.onLoad** function, defined usually in `R/zzz.R`:\n\n```\n.onLoad <- function(libname, pkgname) {\n    nsa <- getNamespace('A')\n    nsa_imp <- parent.env(nsa)\n    parent.env(nsa_imp) <- getNamespace('B')    \n}\n```\n\n### why dirty ?\n\nFirst of all, it uses `parent.env<-`, and according to the documentation:\n>The replacement function parent.env<- is extremely dangerous as it can be used to destructively change environments in ways >that violate assumptions made by the internal C code. It may be removed in the near future.\n\nIt is a pity because it can be extremely useful.\n\n### why a hack ?\n\nUnfortunately it does not work in the general case. \nSuppose you need two packages A and D, that both depend on B and C, but with different rules:\n```\nA -> B -> C\nD -> C -> B\n```\nIn that case, we would re-route A to B, then B to C. And this is incompatible with the way D is designed, resulting in\nwrong symbol picks if symbols with same name are both defined by B and C.\n\n### so what ?\n\nWe'll see in a future post a probably much better solution.\n\n\n_Karl Forner @ Quartz Bio_\n\n","stylesheets":"","assets":{"css":"","js":"","jshead":""},"content":"<h2>Scope</h2>\n<p>This article is about R package development.</p>\n\n<h2>Motivation</h2>\n\n<p>As stated in the the <em>Writing R Extensions</em> manual and the <em>Software for Data Analysis</em> book (aka the R bible), packages should\nwhenever possible use <strong>Imports</strong> instead of <strong>Depends</strong>, to avoid name collision (masking) and ensure trustworthy computations. \nSee <a href=\"http://stackoverflow.com/questions/8637993/better-explanation-of-when-to-use-imports-depends\">this discussion on Stackoverflow</a>.</p>\n\n<h2>The problem</h2>\n\n<p>So after adopting best practices, and only using <strong>Imports</strong> in my packages, the problem is that some <em>imported</em> packages \ndo not follow those best practices and rely on <strong>Depends</strong> for their dependencies, and consequently will not find \ntheir dependencies unless hacked.  </p>\n\n<p>Say we are writing a package <strong>MyPkg</strong>, that uses some functions from a CRAN package <strong>A</strong>, which lists a CRAN \npackage <strong>B</strong> in its Depends.</p>\n\n<p><em>MyPkg::f</em></p>\n\n<pre><code>f &lt;- function() a()\n</code></pre>\n\n<p><em>A::a</em></p>\n\n<pre><code>a &lt;- function() b()\n</code></pre>\n\n<p><em>B::b</em>\nb &lt;- function() { ... }</p>\n\n<p>Executing <code>f()</code> will find the function <code>a</code>, explicitly imported from package A. But executing <code>a()</code> will die because \nfunction <code>b</code> can not be found.</p>\n\n<h2>analysis</h2>\n\n<p>Because B is listed in the Depends of package A, <code>b()</code> is normally found in the <em>search path</em>, where namespace <strong>B</strong> is attached. \nWhat can we do to work around this problem ?<br>\nSadly, there is nothing we can do at the  <strong>MyPkg</strong> package level, since the problem sits in the <strong>A</strong> namespace.\nWe could of course lists B in the <strong>MyPkg</strong> Depends, but that is precisely what we want to avoid.</p>\n\n<h2>the dirty hack solution</h2>\n\n<h3>the idea</h3>\n\n<p>I suggest that you first have a look at this very good blog \n<a href=\"http://obeautifulcode.com/R/How-R-Searches-And-Finds-Stuff/\">How R Searches and Finds Stuff</a> if you need some \nclarification about namespaces and imports.  </p>\n\n<p>Here is a diagram of the current state of the problem:</p>\n\n<p><img src=\"assets/fig/unnamed-chunk-1.png\" alt=\"plot of chunk unnamed-chunk-1\"> </p>\n\n<p>We want the <code>a()</code> call, which is executed in namespace <strong>A</strong>, to find the <strong>b</strong> symbol in namespace <strong>B</strong>. \nTo achieve this, we will re-route the namespace <strong>A</strong> (actually its Imports namespace) to the <strong>B</strong> namespace:</p>\n\n<pre><code>nsa &lt;- getNamespace(&#39;A&#39;)                      # package A environment\nnsa_imp &lt;- parent.env(nsa)                    # package A Imports\nparent.env(nsa_imp) &lt;- getNamespace(&#39;B&#39;)      # re-route A Imports to package B\n</code></pre>\n\n<p>Now our namespaces should look like this:  </p>\n\n<p><img src=\"assets/fig/unnamed-chunk-2.png\" alt=\"plot of chunk unnamed-chunk-2\"> </p>\n\n<p>Notice that the link From A Imports to base has been re-routed towards package B (the arrow labelled &quot;New&quot;)</p>\n\n<h2>Example</h2>\n\n<p>The above code is not straightforward to test because you need to write a package.  </p>\n\n<p>Here is some reproducible code that illustrates how the hack works, so that you can simulate its mechanism\nright now by copy-pasting the following code in your R console.\nThis example uses package <strong>multcomp</strong> that <em>Depends</em> on <strong>mvtnorm</strong>. </p>\n\n<pre><code class=\"r\">## load multcomp package, and its imports, but do not attach them in the\n## search path\nl &lt;- loadNamespace(&quot;multcomp&quot;)  # assignment to avoid annoying print\n\namod &lt;- aov(breaks ~ wool + tension, data = warpbreaks)\nwht &lt;- multcomp::glht(amod, linfct = multcomp::mcp(tension = &quot;Tukey&quot;))\nci &lt;- confint(wht)  # mvtnorm::qmvt is not found, because mvtnorm is not attached to the search path\n\n# let&#39;s load the mvtnorm namespace\nl &lt;- loadNamespace(&quot;mvtnorm&quot;)\nci &lt;- confint(wht)  # mvtnorm::qmvt still not found, mvtnorm is loaded but not attached\n\n# hack hack hack: re-route package multcomp to mvtnorm\nns1 &lt;- getNamespace(&quot;multcomp&quot;)\nns1_imp &lt;- parent.env(ns1)\nparent.env(ns1_imp) &lt;- getNamespace(&quot;mvtnorm&quot;)\n\nci &lt;- confint(wht)  # now should work\nprint(ci)\n</code></pre>\n\n<pre><code>## \n##   Simultaneous Confidence Intervals\n## \n## Multiple Comparisons of Means: Tukey Contrasts\n## \n## \n## Fit: aov(formula = breaks ~ wool + tension, data = warpbreaks)\n## \n## Quantile = 2.415\n## 95% family-wise confidence level\n##  \n## \n## Linear Hypotheses:\n##            Estimate lwr     upr    \n## M - L == 0 -10.000  -19.354  -0.646\n## H - L == 0 -14.722  -24.076  -5.369\n## H - M == 0  -4.722  -14.076   4.631\n</code></pre>\n\n<h2>implementation of the hack in MyPkg</h2>\n\n<p>Just put the re-routing code in your MyPkg <strong>.onLoad</strong> function, defined usually in <code>R/zzz.R</code>:</p>\n\n<pre><code>.onLoad &lt;- function(libname, pkgname) {\n    nsa &lt;- getNamespace(&#39;A&#39;)\n    nsa_imp &lt;- parent.env(nsa)\n    parent.env(nsa_imp) &lt;- getNamespace(&#39;B&#39;)    \n}\n</code></pre>\n\n<h3>why dirty ?</h3>\n\n<p>First of all, it uses <code>parent.env&lt;-</code>, and according to the documentation:</p>\n\n<blockquote>\n<p>The replacement function parent.env&lt;- is extremely dangerous as it can be used to destructively change environments in ways &gt;that violate assumptions made by the internal C code. It may be removed in the near future.</p>\n</blockquote>\n\n<p>It is a pity because it can be extremely useful.</p>\n\n<h3>why a hack ?</h3>\n\n<p>Unfortunately it does not work in the general case. \nSuppose you need two packages A and D, that both depend on B and C, but with different rules:</p>\n\n<pre><code>A -&gt; B -&gt; C\nD -&gt; C -&gt; B\n</code></pre>\n\n<p>In that case, we would re-route A to B, then B to C. And this is incompatible with the way D is designed, resulting in\nwrong symbol picks if symbols with same name are both defined by B and C.</p>\n\n<h3>so what ?</h3>\n\n<p>We&#39;ll see in a future post a probably much better solution.</p>\n\n<p><em>Karl Forner @ Quartz Bio</em></p>\n"}}