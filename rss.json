{"site":{"title":"Karl's Blog","tagline":"Karl Blogging Test","background":"assets/img/bgr-numerique.jpg","feed_img":"img/rss.gif","owner":"Karl Forner","author":{"email":"karl.forner@gmail.com","github":"kforner","firstname":"Karl","lastname":"Forner"},"url":null,"rawurl":"/","navigation":[{"item":"Home","href":"index.html"},{"item":"About","href":"about.html"}],"google_search_engine_id":"016732723349564622635:1pee01gdpao","google_analytics_id":"UA-41262764-1"},"pages":[{"url":{"assets":"../assets","lib":"../libraries"},"framework":"qb_rss","theme":"","highlighter":"prettify","hitheme":"twitter-bootstrap","copy_libraries":true,"mode":"selfcontained","widgets":[],"prettify":{"linenums":true},"title":"A dirty hack solution for packages using Depends","author":"Karl Forner","license":"GPL (>= 2)","tags":"package namespace imports depends","summary":"A dirty hack solution for packages using Depends","date":15852,"slides":[{"html":"<h2>Motivation</h2>\n\n<p>As stated in the the &quot;Writing R Extensions&quot;, the Software for Data Analysis book (aka the R bible), packages should\nwhenever possible use <strong>Imports</strong> instead of <strong>Depends</strong>, to avoid name collision (masking) and ensure trustworthy computations. \nSee <a href=\"http://stackoverflow.com/questions/8637993/better-explanation-of-when-to-use-imports-depends\">this discussion on Stackoverflow</a>.</p>\n\n<h2>The problem</h2>\n\n<p>So after adopting best practices, and only using <strong>Imports</strong> in my packages, the problem is that some <em>imported</em> packages \ndo not follow those best practices and rely on <strong>Depends</strong> for their dependencies, and consequently will not find \ntheir dependencies unless hacked.  </p>\n\n<p>Say we are writing a package <strong>MyPkg</strong>, that uses some functions from a CRAN package <strong>A</strong>, which lists a CRAN \npackage <strong>B</strong> in its Depends.</p>\n\n<p><em>MyPkg::f</em></p>\n\n<pre><code>f &lt;- function() a()\n</code></pre>\n\n<p><em>A::a</em></p>\n\n<pre><code>a &lt;- function() b()\n</code></pre>\n\n<p>Executing <code>f()</code> will find the function <code>a</code>, explicitly imported from package A. But executing <code>a()</code> will die because \nfunction <code>b</code> can not be found.</p>\n\n<h2>analysis</h2>\n\n<p>Because B is in A Depends, <code>b()</code> is normally found in the search path, where namespace <strong>B</strong> is attached. \nWhat can we do to work around this problem ?<br>\nSadly, there is nothing we can do at the  <strong>MyPkg</strong> package level, since the problem sits in the <strong>A</strong> namespace.\nWe could of course lists B in the <strong>MyPkg</strong> Depends, but that is precisely what we want to avoid.</p>\n\n<h2>the dirty hack solution</h2>\n\n<h3>the idea</h3>\n\n<p>I suggest that you first have a look at this very good blog \n<a href=\"http://obeautifulcode.com/R/How-R-Searches-And-Finds-Stuff/\">How R Searches and Finds Stuff</a> if you need some \nclarification about namespaces and imports.  </p>\n\n<p>Here is a diagram of the current state of the problem:</p>\n\n<p><img src=\"assets/fig/unnamed-chunk-1.png\" alt=\"plot of chunk unnamed-chunk-1\"> </p>\n\n<p>We want the <code>a()</code> call, which is executed in namespace <strong>A</strong>, to find the <strong>b</strong> symbol in namespace <strong>B</strong>. \nTo achieve this, we will re-route the namespace <strong>A</strong> (actually its Imports namespace) to the <strong>B</strong> namespace:</p>\n\n<pre><code>nsa &lt;- getNamespace(&#39;A&#39;)\nnsa_imp &lt;- parent.env(nsa)\nparent.env(nsa_imp) &lt;- getNamespace(&#39;B&#39;)\n</code></pre>\n\n<p>Now our namespaces should look like this:  </p>\n\n<p><img src=\"assets/fig/unnamed-chunk-2.png\" alt=\"plot of chunk unnamed-chunk-2\"> </p>\n\n<h2>Example</h2>\n\n<p>The above code is not straightforward to test because you need to write a package.  </p>\n\n<p>Here is some reproducible code that illustrates how the hack works, using package <strong>multcomp</strong> that <em>Depends</em> on <strong>mvtnorm</strong></p>\n\n<pre><code class=\"r\">l &lt;- loadNamespace(&quot;multcomp&quot;)  # assignment to avoid annoying print\n\namod &lt;- aov(breaks ~ wool + tension, data = warpbreaks)\nwht &lt;- multcomp::glht(amod, linfct = multcomp::mcp(tension = &quot;Tukey&quot;))\nci &lt;- confint(wht)  # mvtnorm::qmvt is not found\n</code></pre>\n\n<pre><code>## Error: could not find function &quot;qmvt&quot;\n</code></pre>\n\n<pre><code class=\"r\">\n# let&#39;s load the mvtnorm namespace\nl &lt;- loadNamespace(&quot;mvtnorm&quot;)\nci &lt;- confint(wht)  # mvtnorm::qmvt still not found\n</code></pre>\n\n<pre><code>## Error: could not find function &quot;qmvt&quot;\n</code></pre>\n\n<pre><code class=\"r\">\n# hack hack hack\nns1 &lt;- getNamespace(&quot;multcomp&quot;)\nns1_imp &lt;- parent.env(ns1)\nparent.env(ns1_imp) &lt;- getNamespace(&quot;mvtnorm&quot;)\n\nci &lt;- confint(wht)  # now should work\nprint(ci)\n</code></pre>\n\n<pre><code>## \n##   Simultaneous Confidence Intervals\n## \n## Multiple Comparisons of Means: Tukey Contrasts\n## \n## \n## Fit: aov(formula = breaks ~ wool + tension, data = warpbreaks)\n## \n## Quantile = 2.416\n## 95% family-wise confidence level\n##  \n## \n## Linear Hypotheses:\n##            Estimate lwr     upr    \n## M - L == 0 -10.000  -19.354  -0.646\n## H - L == 0 -14.722  -24.076  -5.368\n## H - M == 0  -4.722  -14.076   4.632\n</code></pre>\n\n<h2>implementation of the hack in MyPkg</h2>\n\n<p>Just put the re-routing code in your MyPkg <strong>.onLoad</strong> function, defined usually in <code>R/zzz.R</code>:</p>\n\n<pre><code>.onLoad &lt;- function(libname, pkgname) {\n    nsa &lt;- getNamespace(&#39;A&#39;)\n    nsa_imp &lt;- parent.env(nsa)\n    parent.env(nsa_imp) &lt;- getNamespace(&#39;B&#39;)    \n}\n</code></pre>\n\n<h3>why dirty ?</h3>\n\n<p>First of all, it uses <code>parent.env&lt;-</code>, and according to the documentation:</p>\n\n<blockquote>\n<p>The replacement function parent.env&lt;- is extremely dangerous as it can be used to destructively change environments in ways &gt;that violate assumptions made by the internal C code. It may be removed in the near future.</p>\n</blockquote>\n\n<p>It is a pity because it can be extremely useful.</p>\n\n<h3>why a hack ?</h3>\n\n<p>Unfortunately it does not work in the general case. \nSuppose you need two packages A and D, that both depend on B and C, but with different rules:</p>\n\n<pre><code>A -&gt; B -&gt; C\nD -&gt; C -&gt; B\n</code></pre>\n\n<p>In that case, we would re-route A to B, then B to C. And this is incompatible with the way D is designed, resulting in\nwrong symbol picks if symbols with same name are both defined by B and C.</p>\n\n<h3>so what ?</h3>\n\n<p>We&#39;ll see in a future post a probably much better solution.</p>\n\n<p><em>Karl Forner @ Quartz Bio</em></p>\n","header":"<h2>Motivation</h2>","level":"2","title":"Motivation","content":"<p>As stated in the the &quot;Writing R Extensions&quot;, the Software for Data Analysis book (aka the R bible), packages should\nwhenever possible use <strong>Imports</strong> instead of <strong>Depends</strong>, to avoid name collision (masking) and ensure trustworthy computations. \nSee <a href=\"http://stackoverflow.com/questions/8637993/better-explanation-of-when-to-use-imports-depends\">this discussion on Stackoverflow</a>.</p>\n\n<h2>The problem</h2>\n\n<p>So after adopting best practices, and only using <strong>Imports</strong> in my packages, the problem is that some <em>imported</em> packages \ndo not follow those best practices and rely on <strong>Depends</strong> for their dependencies, and consequently will not find \ntheir dependencies unless hacked.  </p>\n\n<p>Say we are writing a package <strong>MyPkg</strong>, that uses some functions from a CRAN package <strong>A</strong>, which lists a CRAN \npackage <strong>B</strong> in its Depends.</p>\n\n<p><em>MyPkg::f</em></p>\n\n<pre><code>f &lt;- function() a()\n</code></pre>\n\n<p><em>A::a</em></p>\n\n<pre><code>a &lt;- function() b()\n</code></pre>\n\n<p>Executing <code>f()</code> will find the function <code>a</code>, explicitly imported from package A. But executing <code>a()</code> will die because \nfunction <code>b</code> can not be found.</p>\n\n<h2>analysis</h2>\n\n<p>Because B is in A Depends, <code>b()</code> is normally found in the search path, where namespace <strong>B</strong> is attached. \nWhat can we do to work around this problem ?<br>\nSadly, there is nothing we can do at the  <strong>MyPkg</strong> package level, since the problem sits in the <strong>A</strong> namespace.\nWe could of course lists B in the <strong>MyPkg</strong> Depends, but that is precisely what we want to avoid.</p>\n\n<h2>the dirty hack solution</h2>\n\n<h3>the idea</h3>\n\n<p>I suggest that you first have a look at this very good blog \n<a href=\"http://obeautifulcode.com/R/How-R-Searches-And-Finds-Stuff/\">How R Searches and Finds Stuff</a> if you need some \nclarification about namespaces and imports.  </p>\n\n<p>Here is a diagram of the current state of the problem:</p>\n\n<p><img src=\"assets/fig/unnamed-chunk-1.png\" alt=\"plot of chunk unnamed-chunk-1\"> </p>\n\n<p>We want the <code>a()</code> call, which is executed in namespace <strong>A</strong>, to find the <strong>b</strong> symbol in namespace <strong>B</strong>. \nTo achieve this, we will re-route the namespace <strong>A</strong> (actually its Imports namespace) to the <strong>B</strong> namespace:</p>\n\n<pre><code>nsa &lt;- getNamespace(&#39;A&#39;)\nnsa_imp &lt;- parent.env(nsa)\nparent.env(nsa_imp) &lt;- getNamespace(&#39;B&#39;)\n</code></pre>\n\n<p>Now our namespaces should look like this:  </p>\n\n<p><img src=\"assets/fig/unnamed-chunk-2.png\" alt=\"plot of chunk unnamed-chunk-2\"> </p>\n\n<h2>Example</h2>\n\n<p>The above code is not straightforward to test because you need to write a package.  </p>\n\n<p>Here is some reproducible code that illustrates how the hack works, using package <strong>multcomp</strong> that <em>Depends</em> on <strong>mvtnorm</strong></p>\n\n<pre><code class=\"r\">l &lt;- loadNamespace(&quot;multcomp&quot;)  # assignment to avoid annoying print\n\namod &lt;- aov(breaks ~ wool + tension, data = warpbreaks)\nwht &lt;- multcomp::glht(amod, linfct = multcomp::mcp(tension = &quot;Tukey&quot;))\nci &lt;- confint(wht)  # mvtnorm::qmvt is not found\n</code></pre>\n\n<pre><code>## Error: could not find function &quot;qmvt&quot;\n</code></pre>\n\n<pre><code class=\"r\">\n# let&#39;s load the mvtnorm namespace\nl &lt;- loadNamespace(&quot;mvtnorm&quot;)\nci &lt;- confint(wht)  # mvtnorm::qmvt still not found\n</code></pre>\n\n<pre><code>## Error: could not find function &quot;qmvt&quot;\n</code></pre>\n\n<pre><code class=\"r\">\n# hack hack hack\nns1 &lt;- getNamespace(&quot;multcomp&quot;)\nns1_imp &lt;- parent.env(ns1)\nparent.env(ns1_imp) &lt;- getNamespace(&quot;mvtnorm&quot;)\n\nci &lt;- confint(wht)  # now should work\nprint(ci)\n</code></pre>\n\n<pre><code>## \n##   Simultaneous Confidence Intervals\n## \n## Multiple Comparisons of Means: Tukey Contrasts\n## \n## \n## Fit: aov(formula = breaks ~ wool + tension, data = warpbreaks)\n## \n## Quantile = 2.416\n## 95% family-wise confidence level\n##  \n## \n## Linear Hypotheses:\n##            Estimate lwr     upr    \n## M - L == 0 -10.000  -19.354  -0.646\n## H - L == 0 -14.722  -24.076  -5.368\n## H - M == 0  -4.722  -14.076   4.632\n</code></pre>\n\n<h2>implementation of the hack in MyPkg</h2>\n\n<p>Just put the re-routing code in your MyPkg <strong>.onLoad</strong> function, defined usually in <code>R/zzz.R</code>:</p>\n\n<pre><code>.onLoad &lt;- function(libname, pkgname) {\n    nsa &lt;- getNamespace(&#39;A&#39;)\n    nsa_imp &lt;- parent.env(nsa)\n    parent.env(nsa_imp) &lt;- getNamespace(&#39;B&#39;)    \n}\n</code></pre>\n\n<h3>why dirty ?</h3>\n\n<p>First of all, it uses <code>parent.env&lt;-</code>, and according to the documentation:</p>\n\n<blockquote>\n<p>The replacement function parent.env&lt;- is extremely dangerous as it can be used to destructively change environments in ways &gt;that violate assumptions made by the internal C code. It may be removed in the near future.</p>\n</blockquote>\n\n<p>It is a pity because it can be extremely useful.</p>\n\n<h3>why a hack ?</h3>\n\n<p>Unfortunately it does not work in the general case. \nSuppose you need two packages A and D, that both depend on B and C, but with different rules:</p>\n\n<pre><code>A -&gt; B -&gt; C\nD -&gt; C -&gt; B\n</code></pre>\n\n<p>In that case, we would re-route A to B, then B to C. And this is incompatible with the way D is designed, resulting in\nwrong symbol picks if symbols with same name are both defined by B and C.</p>\n\n<h3>so what ?</h3>\n\n<p>We&#39;ll see in a future post a probably much better solution.</p>\n\n<p><em>Karl Forner @ Quartz Bio</em></p>\n","num":1,"id":"slide-1","raw":"--- \n\n## Motivation\n\nAs stated in the the \"Writing R Extensions\", the Software for Data Analysis book (aka the R bible), packages should\nwhenever possible use **Imports** instead of **Depends**, to avoid name collision (masking) and ensure trustworthy computations. \nSee [this discussion on Stackoverflow](http://stackoverflow.com/questions/8637993/better-explanation-of-when-to-use-imports-depends).\n\n## The problem\n\nSo after adopting best practices, and only using **Imports** in my packages, the problem is that some _imported_ packages \ndo not follow those best practices and rely on **Depends** for their dependencies, and consequently will not find \ntheir dependencies unless hacked.  \n\nSay we are writing a package **MyPkg**, that uses some functions from a CRAN package **A**, which lists a CRAN \npackage **B** in its Depends.\n\n_MyPkg::f_\n```\nf <- function() a()\n```\n_A::a_\n```\na <- function() b()\n```\n\nExecuting `f()` will find the function `a`, explicitly imported from package A. But executing `a()` will die because \nfunction `b` can not be found.\n\n## analysis\n\nBecause B is in A Depends, `b()` is normally found in the search path, where namespace **B** is attached. \nWhat can we do to work around this problem ?  \nSadly, there is nothing we can do at the  **MyPkg** package level, since the problem sits in the **A** namespace.\nWe could of course lists B in the **MyPkg** Depends, but that is precisely what we want to avoid.\n\n## the dirty hack solution\n\n### the idea\n\nI suggest that you first have a look at this very good blog \n[How R Searches and Finds Stuff](http://obeautifulcode.com/R/How-R-Searches-And-Finds-Stuff/) if you need some \nclarification about namespaces and imports.  \n\n\nHere is a diagram of the current state of the problem:\n\n```{r echo=FALSE}\nsuppressPackageStartupMessages(library(diagram))\npar(mar = c(1, 1, 2, 1))\n\nnames <- c( \"MyPkg:\\nf()\", \"A:\\nA()\", \"B\\nb()\", \"MyPkg.Imports\\nA::a()\", \"A.Imports\", \"B.Imports\", \"Base\")\nn  <- length(names)\nM <- matrix(nrow = n, ncol = n, byrow = TRUE, data = 0)\n\nM[4, 1] <- M[7, 4] <- M[5, 2] <- M[7, 5] <- M[6, 3] <- M[7, 6]  <- 1\ncoords <- coordinates(c(3, 3, 1))\nplotmat(M, pos = coords, curve = 0, name = names, lwd = 1, box.lwd = 2, cex.txt = 0.8, box.type = \"circle\", box.prop = 1.0)\ncurvedarrow(from = coords[1, ], to = coords[2, ], curve = +0.5, lty = 2, lcol = 2)\nmtext(outer = TRUE, side = 3, line = -1.5, cex = 1.5, \"Namespaces before\")\n```\n\n\nWe want the `a()` call, which is executed in namespace **A**, to find the **b** symbol in namespace **B**. \nTo achieve this, we will re-route the namespace **A** (actually its Imports namespace) to the **B** namespace:\n```\nnsa <- getNamespace('A')\nnsa_imp <- parent.env(nsa)\nparent.env(nsa_imp) <- getNamespace('B')\n```\n\nNow our namespaces should look like this:  \n\n```{r echo=FALSE}\n\npar(mar = c(1, 1, 2, 1))\n\nnames <- c( \"MyPkg:\\nf()\", \"A:\\nA()\", \"B\\nb()\", \"MyPkg.Imports\\nA::a()\", \"A.Imports\", \"B.Imports\", \"Base\")\nn  <- length(names)\nM <- matrix(nrow = n, ncol = n, byrow = TRUE, data = 0)\n\nM[4, 1] <- M[7, 4] <- M[5, 2] <- M[6, 3] <- M[7, 6]  <- 1\nM[3, 5] <- 1\ncoords <- coordinates(c(3, 3, 1))\nplotmat(M, pos = coords, curve = 0, name = names, lwd = 1, box.lwd = 2, cex.txt = 0.8, box.type = \"circle\", box.prop = 1.0)\ncurvedarrow(from = coords[1, ], to = coords[2, ], curve = +0.5, lty = 2, lcol = 2)\nmtext(outer = TRUE, side = 3, line = -1.5, cex = 1.5, \"Namespaces after re-rerouting\")\n```\n\n## Example\n\n\nThe above code is not straightforward to test because you need to write a package.  \n\nHere is some reproducible code that illustrates how the hack works, using package **multcomp** that _Depends_ on **mvtnorm**\n\n```{r}\nl <- loadNamespace('multcomp') # assignment to avoid annoying print\n\namod <- aov(breaks ~ wool + tension, data = warpbreaks)\nwht <- multcomp::glht(amod, linfct = multcomp::mcp(tension = \"Tukey\"))\nci <- confint(wht) # mvtnorm::qmvt is not found\n\n# let's load the mvtnorm namespace\nl <- loadNamespace('mvtnorm')\nci <- confint(wht) # mvtnorm::qmvt still not found\n\n# hack hack hack\nns1 <- getNamespace('multcomp')\nns1_imp <- parent.env(ns1)\nparent.env(ns1_imp) <- getNamespace('mvtnorm')\n\nci <- confint(wht) # now should work\nprint(ci)\n\n```\n\n## implementation of the hack in MyPkg\n\nJust put the re-routing code in your MyPkg **.onLoad** function, defined usually in `R/zzz.R`:\n\n```\n.onLoad <- function(libname, pkgname) {\n    nsa <- getNamespace('A')\n    nsa_imp <- parent.env(nsa)\n    parent.env(nsa_imp) <- getNamespace('B')    \n}\n```\n\n### why dirty ?\n\nFirst of all, it uses `parent.env<-`, and according to the documentation:\n>The replacement function parent.env<- is extremely dangerous as it can be used to destructively change environments in ways >that violate assumptions made by the internal C code. It may be removed in the near future.\n\nIt is a pity because it can be extremely useful.\n\n### why a hack ?\n\nUnfortunately it does not work in the general case. \nSuppose you need two packages A and D, that both depend on B and C, but with different rules:\n```\nA -> B -> C\nD -> C -> B\n```\nIn that case, we would re-route A to B, then B to C. And this is incompatible with the way D is designed, resulting in\nwrong symbol picks if symbols with same name are both defined by B and C.\n\n### so what ?\n\nWe'll see in a future post a probably much better solution.\n\n\n_Karl Forner @ Quartz Bio_\n\n"}],"standalone":false,"file":"package-depends-dirty-hack-solution.Rmd","filename":"package-depends-dirty-hack-solution","link":"package-depends-dirty-hack-solution.html","raw":"---\ntitle: A dirty hack solution for packages using Depends\nauthor: Karl Forner\nlicense: GPL (>= 2)\ntags: package namespace imports depends\nsummary: A dirty hack solution for packages using Depends\ndate: 2013-05-27\n---\n\n## Motivation\n\nAs stated in the the \"Writing R Extensions\", the Software for Data Analysis book (aka the R bible), packages should\nwhenever possible use **Imports** instead of **Depends**, to avoid name collision (masking) and ensure trustworthy computations. \nSee [this discussion on Stackoverflow](http://stackoverflow.com/questions/8637993/better-explanation-of-when-to-use-imports-depends).\n\n## The problem\n\nSo after adopting best practices, and only using **Imports** in my packages, the problem is that some _imported_ packages \ndo not follow those best practices and rely on **Depends** for their dependencies, and consequently will not find \ntheir dependencies unless hacked.  \n\nSay we are writing a package **MyPkg**, that uses some functions from a CRAN package **A**, which lists a CRAN \npackage **B** in its Depends.\n\n_MyPkg::f_\n```\nf <- function() a()\n```\n_A::a_\n```\na <- function() b()\n```\n\nExecuting `f()` will find the function `a`, explicitly imported from package A. But executing `a()` will die because \nfunction `b` can not be found.\n\n## analysis\n\nBecause B is in A Depends, `b()` is normally found in the search path, where namespace **B** is attached. \nWhat can we do to work around this problem ?  \nSadly, there is nothing we can do at the  **MyPkg** package level, since the problem sits in the **A** namespace.\nWe could of course lists B in the **MyPkg** Depends, but that is precisely what we want to avoid.\n\n## the dirty hack solution\n\n### the idea\n\nI suggest that you first have a look at this very good blog \n[How R Searches and Finds Stuff](http://obeautifulcode.com/R/How-R-Searches-And-Finds-Stuff/) if you need some \nclarification about namespaces and imports.  \n\n\nHere is a diagram of the current state of the problem:\n\n```{r echo=FALSE}\nsuppressPackageStartupMessages(library(diagram))\npar(mar = c(1, 1, 2, 1))\n\nnames <- c( \"MyPkg:\\nf()\", \"A:\\nA()\", \"B\\nb()\", \"MyPkg.Imports\\nA::a()\", \"A.Imports\", \"B.Imports\", \"Base\")\nn  <- length(names)\nM <- matrix(nrow = n, ncol = n, byrow = TRUE, data = 0)\n\nM[4, 1] <- M[7, 4] <- M[5, 2] <- M[7, 5] <- M[6, 3] <- M[7, 6]  <- 1\ncoords <- coordinates(c(3, 3, 1))\nplotmat(M, pos = coords, curve = 0, name = names, lwd = 1, box.lwd = 2, cex.txt = 0.8, box.type = \"circle\", box.prop = 1.0)\ncurvedarrow(from = coords[1, ], to = coords[2, ], curve = +0.5, lty = 2, lcol = 2)\nmtext(outer = TRUE, side = 3, line = -1.5, cex = 1.5, \"Namespaces before\")\n```\n\n\nWe want the `a()` call, which is executed in namespace **A**, to find the **b** symbol in namespace **B**. \nTo achieve this, we will re-route the namespace **A** (actually its Imports namespace) to the **B** namespace:\n```\nnsa <- getNamespace('A')\nnsa_imp <- parent.env(nsa)\nparent.env(nsa_imp) <- getNamespace('B')\n```\n\nNow our namespaces should look like this:  \n\n```{r echo=FALSE}\n\npar(mar = c(1, 1, 2, 1))\n\nnames <- c( \"MyPkg:\\nf()\", \"A:\\nA()\", \"B\\nb()\", \"MyPkg.Imports\\nA::a()\", \"A.Imports\", \"B.Imports\", \"Base\")\nn  <- length(names)\nM <- matrix(nrow = n, ncol = n, byrow = TRUE, data = 0)\n\nM[4, 1] <- M[7, 4] <- M[5, 2] <- M[6, 3] <- M[7, 6]  <- 1\nM[3, 5] <- 1\ncoords <- coordinates(c(3, 3, 1))\nplotmat(M, pos = coords, curve = 0, name = names, lwd = 1, box.lwd = 2, cex.txt = 0.8, box.type = \"circle\", box.prop = 1.0)\ncurvedarrow(from = coords[1, ], to = coords[2, ], curve = +0.5, lty = 2, lcol = 2)\nmtext(outer = TRUE, side = 3, line = -1.5, cex = 1.5, \"Namespaces after re-rerouting\")\n```\n\n## Example\n\n\nThe above code is not straightforward to test because you need to write a package.  \n\nHere is some reproducible code that illustrates how the hack works, using package **multcomp** that _Depends_ on **mvtnorm**\n\n```{r}\nl <- loadNamespace('multcomp') # assignment to avoid annoying print\n\namod <- aov(breaks ~ wool + tension, data = warpbreaks)\nwht <- multcomp::glht(amod, linfct = multcomp::mcp(tension = \"Tukey\"))\nci <- confint(wht) # mvtnorm::qmvt is not found\n\n# let's load the mvtnorm namespace\nl <- loadNamespace('mvtnorm')\nci <- confint(wht) # mvtnorm::qmvt still not found\n\n# hack hack hack\nns1 <- getNamespace('multcomp')\nns1_imp <- parent.env(ns1)\nparent.env(ns1_imp) <- getNamespace('mvtnorm')\n\nci <- confint(wht) # now should work\nprint(ci)\n\n```\n\n## implementation of the hack in MyPkg\n\nJust put the re-routing code in your MyPkg **.onLoad** function, defined usually in `R/zzz.R`:\n\n```\n.onLoad <- function(libname, pkgname) {\n    nsa <- getNamespace('A')\n    nsa_imp <- parent.env(nsa)\n    parent.env(nsa_imp) <- getNamespace('B')    \n}\n```\n\n### why dirty ?\n\nFirst of all, it uses `parent.env<-`, and according to the documentation:\n>The replacement function parent.env<- is extremely dangerous as it can be used to destructively change environments in ways >that violate assumptions made by the internal C code. It may be removed in the near future.\n\nIt is a pity because it can be extremely useful.\n\n### why a hack ?\n\nUnfortunately it does not work in the general case. \nSuppose you need two packages A and D, that both depend on B and C, but with different rules:\n```\nA -> B -> C\nD -> C -> B\n```\nIn that case, we would re-route A to B, then B to C. And this is incompatible with the way D is designed, resulting in\nwrong symbol picks if symbols with same name are both defined by B and C.\n\n### so what ?\n\nWe'll see in a future post a probably much better solution.\n\n\n_Karl Forner @ Quartz Bio_\n\n"}],"tags":{"package namespace imports depends":{"pages":[{"title":"A dirty hack solution for packages using Depends","file":"package-depends-dirty-hack-solution.Rmd","date":15852,"link":"package-depends-dirty-hack-solution.html"}],"name":"package namespace imports depends","count":1},"all":[{"pages":[{"title":"A dirty hack solution for packages using Depends","file":"package-depends-dirty-hack-solution.Rmd","date":15852,"link":"package-depends-dirty-hack-solution.html"}],"name":"package namespace imports depends","count":1}]},"page":{"url":{"assets":"../assets","lib":"../libraries","widgets":"../libraries/widgets","framework":"../libraries/frameworks/qb_rss","theme":"../libraries/frameworks/qb_rss/","highlighters":"../libraries/highlighters","layouts":["../libraries/frameworks/qb_rss/layouts","../assets/layouts"],"highlighter":"../libraries/highlighters/prettify"},"framework":"qb_rss","theme":"","highlighter":"prettify","hitheme":"twitter-bootstrap","copy_libraries":true,"mode":"selfcontained","widgets":[],"prettify":{"linenums":true},"title":"A dirty hack solution for packages using Depends","author":"Karl Forner","license":"GPL (>= 2)","tags":"package namespace imports depends","summary":"A dirty hack solution for packages using Depends","date":15852,"slides":[{"html":"<h2>Motivation</h2>\n\n<p>As stated in the the &quot;Writing R Extensions&quot;, the Software for Data Analysis book (aka the R bible), packages should\nwhenever possible use <strong>Imports</strong> instead of <strong>Depends</strong>, to avoid name collision (masking) and ensure trustworthy computations. \nSee <a href=\"http://stackoverflow.com/questions/8637993/better-explanation-of-when-to-use-imports-depends\">this discussion on Stackoverflow</a>.</p>\n\n<h2>The problem</h2>\n\n<p>So after adopting best practices, and only using <strong>Imports</strong> in my packages, the problem is that some <em>imported</em> packages \ndo not follow those best practices and rely on <strong>Depends</strong> for their dependencies, and consequently will not find \ntheir dependencies unless hacked.  </p>\n\n<p>Say we are writing a package <strong>MyPkg</strong>, that uses some functions from a CRAN package <strong>A</strong>, which lists a CRAN \npackage <strong>B</strong> in its Depends.</p>\n\n<p><em>MyPkg::f</em></p>\n\n<pre><code>f &lt;- function() a()\n</code></pre>\n\n<p><em>A::a</em></p>\n\n<pre><code>a &lt;- function() b()\n</code></pre>\n\n<p>Executing <code>f()</code> will find the function <code>a</code>, explicitly imported from package A. But executing <code>a()</code> will die because \nfunction <code>b</code> can not be found.</p>\n\n<h2>analysis</h2>\n\n<p>Because B is in A Depends, <code>b()</code> is normally found in the search path, where namespace <strong>B</strong> is attached. \nWhat can we do to work around this problem ?<br>\nSadly, there is nothing we can do at the  <strong>MyPkg</strong> package level, since the problem sits in the <strong>A</strong> namespace.\nWe could of course lists B in the <strong>MyPkg</strong> Depends, but that is precisely what we want to avoid.</p>\n\n<h2>the dirty hack solution</h2>\n\n<h3>the idea</h3>\n\n<p>I suggest that you first have a look at this very good blog \n<a href=\"http://obeautifulcode.com/R/How-R-Searches-And-Finds-Stuff/\">How R Searches and Finds Stuff</a> if you need some \nclarification about namespaces and imports.  </p>\n\n<p>Here is a diagram of the current state of the problem:</p>\n\n<p><img src=\"assets/fig/unnamed-chunk-1.png\" alt=\"plot of chunk unnamed-chunk-1\"> </p>\n\n<p>We want the <code>a()</code> call, which is executed in namespace <strong>A</strong>, to find the <strong>b</strong> symbol in namespace <strong>B</strong>. \nTo achieve this, we will re-route the namespace <strong>A</strong> (actually its Imports namespace) to the <strong>B</strong> namespace:</p>\n\n<pre><code>nsa &lt;- getNamespace(&#39;A&#39;)\nnsa_imp &lt;- parent.env(nsa)\nparent.env(nsa_imp) &lt;- getNamespace(&#39;B&#39;)\n</code></pre>\n\n<p>Now our namespaces should look like this:  </p>\n\n<p><img src=\"assets/fig/unnamed-chunk-2.png\" alt=\"plot of chunk unnamed-chunk-2\"> </p>\n\n<h2>Example</h2>\n\n<p>The above code is not straightforward to test because you need to write a package.  </p>\n\n<p>Here is some reproducible code that illustrates how the hack works, using package <strong>multcomp</strong> that <em>Depends</em> on <strong>mvtnorm</strong></p>\n\n<pre><code class=\"r\">l &lt;- loadNamespace(&quot;multcomp&quot;)  # assignment to avoid annoying print\n\namod &lt;- aov(breaks ~ wool + tension, data = warpbreaks)\nwht &lt;- multcomp::glht(amod, linfct = multcomp::mcp(tension = &quot;Tukey&quot;))\nci &lt;- confint(wht)  # mvtnorm::qmvt is not found\n</code></pre>\n\n<pre><code>## Error: could not find function &quot;qmvt&quot;\n</code></pre>\n\n<pre><code class=\"r\">\n# let&#39;s load the mvtnorm namespace\nl &lt;- loadNamespace(&quot;mvtnorm&quot;)\nci &lt;- confint(wht)  # mvtnorm::qmvt still not found\n</code></pre>\n\n<pre><code>## Error: could not find function &quot;qmvt&quot;\n</code></pre>\n\n<pre><code class=\"r\">\n# hack hack hack\nns1 &lt;- getNamespace(&quot;multcomp&quot;)\nns1_imp &lt;- parent.env(ns1)\nparent.env(ns1_imp) &lt;- getNamespace(&quot;mvtnorm&quot;)\n\nci &lt;- confint(wht)  # now should work\nprint(ci)\n</code></pre>\n\n<pre><code>## \n##   Simultaneous Confidence Intervals\n## \n## Multiple Comparisons of Means: Tukey Contrasts\n## \n## \n## Fit: aov(formula = breaks ~ wool + tension, data = warpbreaks)\n## \n## Quantile = 2.416\n## 95% family-wise confidence level\n##  \n## \n## Linear Hypotheses:\n##            Estimate lwr     upr    \n## M - L == 0 -10.000  -19.354  -0.646\n## H - L == 0 -14.722  -24.076  -5.368\n## H - M == 0  -4.722  -14.076   4.632\n</code></pre>\n\n<h2>implementation of the hack in MyPkg</h2>\n\n<p>Just put the re-routing code in your MyPkg <strong>.onLoad</strong> function, defined usually in <code>R/zzz.R</code>:</p>\n\n<pre><code>.onLoad &lt;- function(libname, pkgname) {\n    nsa &lt;- getNamespace(&#39;A&#39;)\n    nsa_imp &lt;- parent.env(nsa)\n    parent.env(nsa_imp) &lt;- getNamespace(&#39;B&#39;)    \n}\n</code></pre>\n\n<h3>why dirty ?</h3>\n\n<p>First of all, it uses <code>parent.env&lt;-</code>, and according to the documentation:</p>\n\n<blockquote>\n<p>The replacement function parent.env&lt;- is extremely dangerous as it can be used to destructively change environments in ways &gt;that violate assumptions made by the internal C code. It may be removed in the near future.</p>\n</blockquote>\n\n<p>It is a pity because it can be extremely useful.</p>\n\n<h3>why a hack ?</h3>\n\n<p>Unfortunately it does not work in the general case. \nSuppose you need two packages A and D, that both depend on B and C, but with different rules:</p>\n\n<pre><code>A -&gt; B -&gt; C\nD -&gt; C -&gt; B\n</code></pre>\n\n<p>In that case, we would re-route A to B, then B to C. And this is incompatible with the way D is designed, resulting in\nwrong symbol picks if symbols with same name are both defined by B and C.</p>\n\n<h3>so what ?</h3>\n\n<p>We&#39;ll see in a future post a probably much better solution.</p>\n\n<p><em>Karl Forner @ Quartz Bio</em></p>\n","header":"<h2>Motivation</h2>","level":"2","title":"Motivation","content":"<p>As stated in the the &quot;Writing R Extensions&quot;, the Software for Data Analysis book (aka the R bible), packages should\nwhenever possible use <strong>Imports</strong> instead of <strong>Depends</strong>, to avoid name collision (masking) and ensure trustworthy computations. \nSee <a href=\"http://stackoverflow.com/questions/8637993/better-explanation-of-when-to-use-imports-depends\">this discussion on Stackoverflow</a>.</p>\n\n<h2>The problem</h2>\n\n<p>So after adopting best practices, and only using <strong>Imports</strong> in my packages, the problem is that some <em>imported</em> packages \ndo not follow those best practices and rely on <strong>Depends</strong> for their dependencies, and consequently will not find \ntheir dependencies unless hacked.  </p>\n\n<p>Say we are writing a package <strong>MyPkg</strong>, that uses some functions from a CRAN package <strong>A</strong>, which lists a CRAN \npackage <strong>B</strong> in its Depends.</p>\n\n<p><em>MyPkg::f</em></p>\n\n<pre><code>f &lt;- function() a()\n</code></pre>\n\n<p><em>A::a</em></p>\n\n<pre><code>a &lt;- function() b()\n</code></pre>\n\n<p>Executing <code>f()</code> will find the function <code>a</code>, explicitly imported from package A. But executing <code>a()</code> will die because \nfunction <code>b</code> can not be found.</p>\n\n<h2>analysis</h2>\n\n<p>Because B is in A Depends, <code>b()</code> is normally found in the search path, where namespace <strong>B</strong> is attached. \nWhat can we do to work around this problem ?<br>\nSadly, there is nothing we can do at the  <strong>MyPkg</strong> package level, since the problem sits in the <strong>A</strong> namespace.\nWe could of course lists B in the <strong>MyPkg</strong> Depends, but that is precisely what we want to avoid.</p>\n\n<h2>the dirty hack solution</h2>\n\n<h3>the idea</h3>\n\n<p>I suggest that you first have a look at this very good blog \n<a href=\"http://obeautifulcode.com/R/How-R-Searches-And-Finds-Stuff/\">How R Searches and Finds Stuff</a> if you need some \nclarification about namespaces and imports.  </p>\n\n<p>Here is a diagram of the current state of the problem:</p>\n\n<p><img src=\"assets/fig/unnamed-chunk-1.png\" alt=\"plot of chunk unnamed-chunk-1\"> </p>\n\n<p>We want the <code>a()</code> call, which is executed in namespace <strong>A</strong>, to find the <strong>b</strong> symbol in namespace <strong>B</strong>. \nTo achieve this, we will re-route the namespace <strong>A</strong> (actually its Imports namespace) to the <strong>B</strong> namespace:</p>\n\n<pre><code>nsa &lt;- getNamespace(&#39;A&#39;)\nnsa_imp &lt;- parent.env(nsa)\nparent.env(nsa_imp) &lt;- getNamespace(&#39;B&#39;)\n</code></pre>\n\n<p>Now our namespaces should look like this:  </p>\n\n<p><img src=\"assets/fig/unnamed-chunk-2.png\" alt=\"plot of chunk unnamed-chunk-2\"> </p>\n\n<h2>Example</h2>\n\n<p>The above code is not straightforward to test because you need to write a package.  </p>\n\n<p>Here is some reproducible code that illustrates how the hack works, using package <strong>multcomp</strong> that <em>Depends</em> on <strong>mvtnorm</strong></p>\n\n<pre><code class=\"r\">l &lt;- loadNamespace(&quot;multcomp&quot;)  # assignment to avoid annoying print\n\namod &lt;- aov(breaks ~ wool + tension, data = warpbreaks)\nwht &lt;- multcomp::glht(amod, linfct = multcomp::mcp(tension = &quot;Tukey&quot;))\nci &lt;- confint(wht)  # mvtnorm::qmvt is not found\n</code></pre>\n\n<pre><code>## Error: could not find function &quot;qmvt&quot;\n</code></pre>\n\n<pre><code class=\"r\">\n# let&#39;s load the mvtnorm namespace\nl &lt;- loadNamespace(&quot;mvtnorm&quot;)\nci &lt;- confint(wht)  # mvtnorm::qmvt still not found\n</code></pre>\n\n<pre><code>## Error: could not find function &quot;qmvt&quot;\n</code></pre>\n\n<pre><code class=\"r\">\n# hack hack hack\nns1 &lt;- getNamespace(&quot;multcomp&quot;)\nns1_imp &lt;- parent.env(ns1)\nparent.env(ns1_imp) &lt;- getNamespace(&quot;mvtnorm&quot;)\n\nci &lt;- confint(wht)  # now should work\nprint(ci)\n</code></pre>\n\n<pre><code>## \n##   Simultaneous Confidence Intervals\n## \n## Multiple Comparisons of Means: Tukey Contrasts\n## \n## \n## Fit: aov(formula = breaks ~ wool + tension, data = warpbreaks)\n## \n## Quantile = 2.416\n## 95% family-wise confidence level\n##  \n## \n## Linear Hypotheses:\n##            Estimate lwr     upr    \n## M - L == 0 -10.000  -19.354  -0.646\n## H - L == 0 -14.722  -24.076  -5.368\n## H - M == 0  -4.722  -14.076   4.632\n</code></pre>\n\n<h2>implementation of the hack in MyPkg</h2>\n\n<p>Just put the re-routing code in your MyPkg <strong>.onLoad</strong> function, defined usually in <code>R/zzz.R</code>:</p>\n\n<pre><code>.onLoad &lt;- function(libname, pkgname) {\n    nsa &lt;- getNamespace(&#39;A&#39;)\n    nsa_imp &lt;- parent.env(nsa)\n    parent.env(nsa_imp) &lt;- getNamespace(&#39;B&#39;)    \n}\n</code></pre>\n\n<h3>why dirty ?</h3>\n\n<p>First of all, it uses <code>parent.env&lt;-</code>, and according to the documentation:</p>\n\n<blockquote>\n<p>The replacement function parent.env&lt;- is extremely dangerous as it can be used to destructively change environments in ways &gt;that violate assumptions made by the internal C code. It may be removed in the near future.</p>\n</blockquote>\n\n<p>It is a pity because it can be extremely useful.</p>\n\n<h3>why a hack ?</h3>\n\n<p>Unfortunately it does not work in the general case. \nSuppose you need two packages A and D, that both depend on B and C, but with different rules:</p>\n\n<pre><code>A -&gt; B -&gt; C\nD -&gt; C -&gt; B\n</code></pre>\n\n<p>In that case, we would re-route A to B, then B to C. And this is incompatible with the way D is designed, resulting in\nwrong symbol picks if symbols with same name are both defined by B and C.</p>\n\n<h3>so what ?</h3>\n\n<p>We&#39;ll see in a future post a probably much better solution.</p>\n\n<p><em>Karl Forner @ Quartz Bio</em></p>\n","num":1,"id":"slide-1","raw":"--- \n\n## Motivation\n\nAs stated in the the \"Writing R Extensions\", the Software for Data Analysis book (aka the R bible), packages should\nwhenever possible use **Imports** instead of **Depends**, to avoid name collision (masking) and ensure trustworthy computations. \nSee [this discussion on Stackoverflow](http://stackoverflow.com/questions/8637993/better-explanation-of-when-to-use-imports-depends).\n\n## The problem\n\nSo after adopting best practices, and only using **Imports** in my packages, the problem is that some _imported_ packages \ndo not follow those best practices and rely on **Depends** for their dependencies, and consequently will not find \ntheir dependencies unless hacked.  \n\nSay we are writing a package **MyPkg**, that uses some functions from a CRAN package **A**, which lists a CRAN \npackage **B** in its Depends.\n\n_MyPkg::f_\n```\nf <- function() a()\n```\n_A::a_\n```\na <- function() b()\n```\n\nExecuting `f()` will find the function `a`, explicitly imported from package A. But executing `a()` will die because \nfunction `b` can not be found.\n\n## analysis\n\nBecause B is in A Depends, `b()` is normally found in the search path, where namespace **B** is attached. \nWhat can we do to work around this problem ?  \nSadly, there is nothing we can do at the  **MyPkg** package level, since the problem sits in the **A** namespace.\nWe could of course lists B in the **MyPkg** Depends, but that is precisely what we want to avoid.\n\n## the dirty hack solution\n\n### the idea\n\nI suggest that you first have a look at this very good blog \n[How R Searches and Finds Stuff](http://obeautifulcode.com/R/How-R-Searches-And-Finds-Stuff/) if you need some \nclarification about namespaces and imports.  \n\n\nHere is a diagram of the current state of the problem:\n\n```{r echo=FALSE}\nsuppressPackageStartupMessages(library(diagram))\npar(mar = c(1, 1, 2, 1))\n\nnames <- c( \"MyPkg:\\nf()\", \"A:\\nA()\", \"B\\nb()\", \"MyPkg.Imports\\nA::a()\", \"A.Imports\", \"B.Imports\", \"Base\")\nn  <- length(names)\nM <- matrix(nrow = n, ncol = n, byrow = TRUE, data = 0)\n\nM[4, 1] <- M[7, 4] <- M[5, 2] <- M[7, 5] <- M[6, 3] <- M[7, 6]  <- 1\ncoords <- coordinates(c(3, 3, 1))\nplotmat(M, pos = coords, curve = 0, name = names, lwd = 1, box.lwd = 2, cex.txt = 0.8, box.type = \"circle\", box.prop = 1.0)\ncurvedarrow(from = coords[1, ], to = coords[2, ], curve = +0.5, lty = 2, lcol = 2)\nmtext(outer = TRUE, side = 3, line = -1.5, cex = 1.5, \"Namespaces before\")\n```\n\n\nWe want the `a()` call, which is executed in namespace **A**, to find the **b** symbol in namespace **B**. \nTo achieve this, we will re-route the namespace **A** (actually its Imports namespace) to the **B** namespace:\n```\nnsa <- getNamespace('A')\nnsa_imp <- parent.env(nsa)\nparent.env(nsa_imp) <- getNamespace('B')\n```\n\nNow our namespaces should look like this:  \n\n```{r echo=FALSE}\n\npar(mar = c(1, 1, 2, 1))\n\nnames <- c( \"MyPkg:\\nf()\", \"A:\\nA()\", \"B\\nb()\", \"MyPkg.Imports\\nA::a()\", \"A.Imports\", \"B.Imports\", \"Base\")\nn  <- length(names)\nM <- matrix(nrow = n, ncol = n, byrow = TRUE, data = 0)\n\nM[4, 1] <- M[7, 4] <- M[5, 2] <- M[6, 3] <- M[7, 6]  <- 1\nM[3, 5] <- 1\ncoords <- coordinates(c(3, 3, 1))\nplotmat(M, pos = coords, curve = 0, name = names, lwd = 1, box.lwd = 2, cex.txt = 0.8, box.type = \"circle\", box.prop = 1.0)\ncurvedarrow(from = coords[1, ], to = coords[2, ], curve = +0.5, lty = 2, lcol = 2)\nmtext(outer = TRUE, side = 3, line = -1.5, cex = 1.5, \"Namespaces after re-rerouting\")\n```\n\n## Example\n\n\nThe above code is not straightforward to test because you need to write a package.  \n\nHere is some reproducible code that illustrates how the hack works, using package **multcomp** that _Depends_ on **mvtnorm**\n\n```{r}\nl <- loadNamespace('multcomp') # assignment to avoid annoying print\n\namod <- aov(breaks ~ wool + tension, data = warpbreaks)\nwht <- multcomp::glht(amod, linfct = multcomp::mcp(tension = \"Tukey\"))\nci <- confint(wht) # mvtnorm::qmvt is not found\n\n# let's load the mvtnorm namespace\nl <- loadNamespace('mvtnorm')\nci <- confint(wht) # mvtnorm::qmvt still not found\n\n# hack hack hack\nns1 <- getNamespace('multcomp')\nns1_imp <- parent.env(ns1)\nparent.env(ns1_imp) <- getNamespace('mvtnorm')\n\nci <- confint(wht) # now should work\nprint(ci)\n\n```\n\n## implementation of the hack in MyPkg\n\nJust put the re-routing code in your MyPkg **.onLoad** function, defined usually in `R/zzz.R`:\n\n```\n.onLoad <- function(libname, pkgname) {\n    nsa <- getNamespace('A')\n    nsa_imp <- parent.env(nsa)\n    parent.env(nsa_imp) <- getNamespace('B')    \n}\n```\n\n### why dirty ?\n\nFirst of all, it uses `parent.env<-`, and according to the documentation:\n>The replacement function parent.env<- is extremely dangerous as it can be used to destructively change environments in ways >that violate assumptions made by the internal C code. It may be removed in the near future.\n\nIt is a pity because it can be extremely useful.\n\n### why a hack ?\n\nUnfortunately it does not work in the general case. \nSuppose you need two packages A and D, that both depend on B and C, but with different rules:\n```\nA -> B -> C\nD -> C -> B\n```\nIn that case, we would re-route A to B, then B to C. And this is incompatible with the way D is designed, resulting in\nwrong symbol picks if symbols with same name are both defined by B and C.\n\n### so what ?\n\nWe'll see in a future post a probably much better solution.\n\n\n_Karl Forner @ Quartz Bio_\n\n","rendered":"<h2>Motivation</h2>\n<p>As stated in the the &quot;Writing R Extensions&quot;, the Software for Data Analysis book (aka the R bible), packages should\nwhenever possible use <strong>Imports</strong> instead of <strong>Depends</strong>, to avoid name collision (masking) and ensure trustworthy computations. \nSee <a href=\"http://stackoverflow.com/questions/8637993/better-explanation-of-when-to-use-imports-depends\">this discussion on Stackoverflow</a>.</p>\n\n<h2>The problem</h2>\n\n<p>So after adopting best practices, and only using <strong>Imports</strong> in my packages, the problem is that some <em>imported</em> packages \ndo not follow those best practices and rely on <strong>Depends</strong> for their dependencies, and consequently will not find \ntheir dependencies unless hacked.  </p>\n\n<p>Say we are writing a package <strong>MyPkg</strong>, that uses some functions from a CRAN package <strong>A</strong>, which lists a CRAN \npackage <strong>B</strong> in its Depends.</p>\n\n<p><em>MyPkg::f</em></p>\n\n<pre><code>f &lt;- function() a()\n</code></pre>\n\n<p><em>A::a</em></p>\n\n<pre><code>a &lt;- function() b()\n</code></pre>\n\n<p>Executing <code>f()</code> will find the function <code>a</code>, explicitly imported from package A. But executing <code>a()</code> will die because \nfunction <code>b</code> can not be found.</p>\n\n<h2>analysis</h2>\n\n<p>Because B is in A Depends, <code>b()</code> is normally found in the search path, where namespace <strong>B</strong> is attached. \nWhat can we do to work around this problem ?<br>\nSadly, there is nothing we can do at the  <strong>MyPkg</strong> package level, since the problem sits in the <strong>A</strong> namespace.\nWe could of course lists B in the <strong>MyPkg</strong> Depends, but that is precisely what we want to avoid.</p>\n\n<h2>the dirty hack solution</h2>\n\n<h3>the idea</h3>\n\n<p>I suggest that you first have a look at this very good blog \n<a href=\"http://obeautifulcode.com/R/How-R-Searches-And-Finds-Stuff/\">How R Searches and Finds Stuff</a> if you need some \nclarification about namespaces and imports.  </p>\n\n<p>Here is a diagram of the current state of the problem:</p>\n\n<p><img src=\"assets/fig/unnamed-chunk-1.png\" alt=\"plot of chunk unnamed-chunk-1\"> </p>\n\n<p>We want the <code>a()</code> call, which is executed in namespace <strong>A</strong>, to find the <strong>b</strong> symbol in namespace <strong>B</strong>. \nTo achieve this, we will re-route the namespace <strong>A</strong> (actually its Imports namespace) to the <strong>B</strong> namespace:</p>\n\n<pre><code>nsa &lt;- getNamespace(&#39;A&#39;)\nnsa_imp &lt;- parent.env(nsa)\nparent.env(nsa_imp) &lt;- getNamespace(&#39;B&#39;)\n</code></pre>\n\n<p>Now our namespaces should look like this:  </p>\n\n<p><img src=\"assets/fig/unnamed-chunk-2.png\" alt=\"plot of chunk unnamed-chunk-2\"> </p>\n\n<h2>Example</h2>\n\n<p>The above code is not straightforward to test because you need to write a package.  </p>\n\n<p>Here is some reproducible code that illustrates how the hack works, using package <strong>multcomp</strong> that <em>Depends</em> on <strong>mvtnorm</strong></p>\n\n<pre><code class=\"r\">l &lt;- loadNamespace(&quot;multcomp&quot;)  # assignment to avoid annoying print\n\namod &lt;- aov(breaks ~ wool + tension, data = warpbreaks)\nwht &lt;- multcomp::glht(amod, linfct = multcomp::mcp(tension = &quot;Tukey&quot;))\nci &lt;- confint(wht)  # mvtnorm::qmvt is not found\n</code></pre>\n\n<pre><code>## Error: could not find function &quot;qmvt&quot;\n</code></pre>\n\n<pre><code class=\"r\">\n# let&#39;s load the mvtnorm namespace\nl &lt;- loadNamespace(&quot;mvtnorm&quot;)\nci &lt;- confint(wht)  # mvtnorm::qmvt still not found\n</code></pre>\n\n<pre><code>## Error: could not find function &quot;qmvt&quot;\n</code></pre>\n\n<pre><code class=\"r\">\n# hack hack hack\nns1 &lt;- getNamespace(&quot;multcomp&quot;)\nns1_imp &lt;- parent.env(ns1)\nparent.env(ns1_imp) &lt;- getNamespace(&quot;mvtnorm&quot;)\n\nci &lt;- confint(wht)  # now should work\nprint(ci)\n</code></pre>\n\n<pre><code>## \n##   Simultaneous Confidence Intervals\n## \n## Multiple Comparisons of Means: Tukey Contrasts\n## \n## \n## Fit: aov(formula = breaks ~ wool + tension, data = warpbreaks)\n## \n## Quantile = 2.416\n## 95% family-wise confidence level\n##  \n## \n## Linear Hypotheses:\n##            Estimate lwr     upr    \n## M - L == 0 -10.000  -19.354  -0.646\n## H - L == 0 -14.722  -24.076  -5.368\n## H - M == 0  -4.722  -14.076   4.632\n</code></pre>\n\n<h2>implementation of the hack in MyPkg</h2>\n\n<p>Just put the re-routing code in your MyPkg <strong>.onLoad</strong> function, defined usually in <code>R/zzz.R</code>:</p>\n\n<pre><code>.onLoad &lt;- function(libname, pkgname) {\n    nsa &lt;- getNamespace(&#39;A&#39;)\n    nsa_imp &lt;- parent.env(nsa)\n    parent.env(nsa_imp) &lt;- getNamespace(&#39;B&#39;)    \n}\n</code></pre>\n\n<h3>why dirty ?</h3>\n\n<p>First of all, it uses <code>parent.env&lt;-</code>, and according to the documentation:</p>\n\n<blockquote>\n<p>The replacement function parent.env&lt;- is extremely dangerous as it can be used to destructively change environments in ways &gt;that violate assumptions made by the internal C code. It may be removed in the near future.</p>\n</blockquote>\n\n<p>It is a pity because it can be extremely useful.</p>\n\n<h3>why a hack ?</h3>\n\n<p>Unfortunately it does not work in the general case. \nSuppose you need two packages A and D, that both depend on B and C, but with different rules:</p>\n\n<pre><code>A -&gt; B -&gt; C\nD -&gt; C -&gt; B\n</code></pre>\n\n<p>In that case, we would re-route A to B, then B to C. And this is incompatible with the way D is designed, resulting in\nwrong symbol picks if symbols with same name are both defined by B and C.</p>\n\n<h3>so what ?</h3>\n\n<p>We&#39;ll see in a future post a probably much better solution.</p>\n\n<p><em>Karl Forner @ Quartz Bio</em></p>\n"}],"standalone":false,"file":"package-depends-dirty-hack-solution.Rmd","filename":"package-depends-dirty-hack-solution","link":"package-depends-dirty-hack-solution.html","raw":"---\ntitle: A dirty hack solution for packages using Depends\nauthor: Karl Forner\nlicense: GPL (>= 2)\ntags: package namespace imports depends\nsummary: A dirty hack solution for packages using Depends\ndate: 2013-05-27\n---\n\n## Motivation\n\nAs stated in the the \"Writing R Extensions\", the Software for Data Analysis book (aka the R bible), packages should\nwhenever possible use **Imports** instead of **Depends**, to avoid name collision (masking) and ensure trustworthy computations. \nSee [this discussion on Stackoverflow](http://stackoverflow.com/questions/8637993/better-explanation-of-when-to-use-imports-depends).\n\n## The problem\n\nSo after adopting best practices, and only using **Imports** in my packages, the problem is that some _imported_ packages \ndo not follow those best practices and rely on **Depends** for their dependencies, and consequently will not find \ntheir dependencies unless hacked.  \n\nSay we are writing a package **MyPkg**, that uses some functions from a CRAN package **A**, which lists a CRAN \npackage **B** in its Depends.\n\n_MyPkg::f_\n```\nf <- function() a()\n```\n_A::a_\n```\na <- function() b()\n```\n\nExecuting `f()` will find the function `a`, explicitly imported from package A. But executing `a()` will die because \nfunction `b` can not be found.\n\n## analysis\n\nBecause B is in A Depends, `b()` is normally found in the search path, where namespace **B** is attached. \nWhat can we do to work around this problem ?  \nSadly, there is nothing we can do at the  **MyPkg** package level, since the problem sits in the **A** namespace.\nWe could of course lists B in the **MyPkg** Depends, but that is precisely what we want to avoid.\n\n## the dirty hack solution\n\n### the idea\n\nI suggest that you first have a look at this very good blog \n[How R Searches and Finds Stuff](http://obeautifulcode.com/R/How-R-Searches-And-Finds-Stuff/) if you need some \nclarification about namespaces and imports.  \n\n\nHere is a diagram of the current state of the problem:\n\n```{r echo=FALSE}\nsuppressPackageStartupMessages(library(diagram))\npar(mar = c(1, 1, 2, 1))\n\nnames <- c( \"MyPkg:\\nf()\", \"A:\\nA()\", \"B\\nb()\", \"MyPkg.Imports\\nA::a()\", \"A.Imports\", \"B.Imports\", \"Base\")\nn  <- length(names)\nM <- matrix(nrow = n, ncol = n, byrow = TRUE, data = 0)\n\nM[4, 1] <- M[7, 4] <- M[5, 2] <- M[7, 5] <- M[6, 3] <- M[7, 6]  <- 1\ncoords <- coordinates(c(3, 3, 1))\nplotmat(M, pos = coords, curve = 0, name = names, lwd = 1, box.lwd = 2, cex.txt = 0.8, box.type = \"circle\", box.prop = 1.0)\ncurvedarrow(from = coords[1, ], to = coords[2, ], curve = +0.5, lty = 2, lcol = 2)\nmtext(outer = TRUE, side = 3, line = -1.5, cex = 1.5, \"Namespaces before\")\n```\n\n\nWe want the `a()` call, which is executed in namespace **A**, to find the **b** symbol in namespace **B**. \nTo achieve this, we will re-route the namespace **A** (actually its Imports namespace) to the **B** namespace:\n```\nnsa <- getNamespace('A')\nnsa_imp <- parent.env(nsa)\nparent.env(nsa_imp) <- getNamespace('B')\n```\n\nNow our namespaces should look like this:  \n\n```{r echo=FALSE}\n\npar(mar = c(1, 1, 2, 1))\n\nnames <- c( \"MyPkg:\\nf()\", \"A:\\nA()\", \"B\\nb()\", \"MyPkg.Imports\\nA::a()\", \"A.Imports\", \"B.Imports\", \"Base\")\nn  <- length(names)\nM <- matrix(nrow = n, ncol = n, byrow = TRUE, data = 0)\n\nM[4, 1] <- M[7, 4] <- M[5, 2] <- M[6, 3] <- M[7, 6]  <- 1\nM[3, 5] <- 1\ncoords <- coordinates(c(3, 3, 1))\nplotmat(M, pos = coords, curve = 0, name = names, lwd = 1, box.lwd = 2, cex.txt = 0.8, box.type = \"circle\", box.prop = 1.0)\ncurvedarrow(from = coords[1, ], to = coords[2, ], curve = +0.5, lty = 2, lcol = 2)\nmtext(outer = TRUE, side = 3, line = -1.5, cex = 1.5, \"Namespaces after re-rerouting\")\n```\n\n## Example\n\n\nThe above code is not straightforward to test because you need to write a package.  \n\nHere is some reproducible code that illustrates how the hack works, using package **multcomp** that _Depends_ on **mvtnorm**\n\n```{r}\nl <- loadNamespace('multcomp') # assignment to avoid annoying print\n\namod <- aov(breaks ~ wool + tension, data = warpbreaks)\nwht <- multcomp::glht(amod, linfct = multcomp::mcp(tension = \"Tukey\"))\nci <- confint(wht) # mvtnorm::qmvt is not found\n\n# let's load the mvtnorm namespace\nl <- loadNamespace('mvtnorm')\nci <- confint(wht) # mvtnorm::qmvt still not found\n\n# hack hack hack\nns1 <- getNamespace('multcomp')\nns1_imp <- parent.env(ns1)\nparent.env(ns1_imp) <- getNamespace('mvtnorm')\n\nci <- confint(wht) # now should work\nprint(ci)\n\n```\n\n## implementation of the hack in MyPkg\n\nJust put the re-routing code in your MyPkg **.onLoad** function, defined usually in `R/zzz.R`:\n\n```\n.onLoad <- function(libname, pkgname) {\n    nsa <- getNamespace('A')\n    nsa_imp <- parent.env(nsa)\n    parent.env(nsa_imp) <- getNamespace('B')    \n}\n```\n\n### why dirty ?\n\nFirst of all, it uses `parent.env<-`, and according to the documentation:\n>The replacement function parent.env<- is extremely dangerous as it can be used to destructively change environments in ways >that violate assumptions made by the internal C code. It may be removed in the near future.\n\nIt is a pity because it can be extremely useful.\n\n### why a hack ?\n\nUnfortunately it does not work in the general case. \nSuppose you need two packages A and D, that both depend on B and C, but with different rules:\n```\nA -> B -> C\nD -> C -> B\n```\nIn that case, we would re-route A to B, then B to C. And this is incompatible with the way D is designed, resulting in\nwrong symbol picks if symbols with same name are both defined by B and C.\n\n### so what ?\n\nWe'll see in a future post a probably much better solution.\n\n\n_Karl Forner @ Quartz Bio_\n\n","stylesheets":"<link rel=\"stylesheet\" href = \"../assets/css/custom.css\">\n<link rel=\"stylesheet\" href = \"../assets/css/ribbons.css\">\n","assets":{"css":"","js":"","jshead":""},"content":"<h2>Motivation</h2>\n<p>As stated in the the &quot;Writing R Extensions&quot;, the Software for Data Analysis book (aka the R bible), packages should\nwhenever possible use <strong>Imports</strong> instead of <strong>Depends</strong>, to avoid name collision (masking) and ensure trustworthy computations. \nSee <a href=\"http://stackoverflow.com/questions/8637993/better-explanation-of-when-to-use-imports-depends\">this discussion on Stackoverflow</a>.</p>\n\n<h2>The problem</h2>\n\n<p>So after adopting best practices, and only using <strong>Imports</strong> in my packages, the problem is that some <em>imported</em> packages \ndo not follow those best practices and rely on <strong>Depends</strong> for their dependencies, and consequently will not find \ntheir dependencies unless hacked.  </p>\n\n<p>Say we are writing a package <strong>MyPkg</strong>, that uses some functions from a CRAN package <strong>A</strong>, which lists a CRAN \npackage <strong>B</strong> in its Depends.</p>\n\n<p><em>MyPkg::f</em></p>\n\n<pre><code>f &lt;- function() a()\n</code></pre>\n\n<p><em>A::a</em></p>\n\n<pre><code>a &lt;- function() b()\n</code></pre>\n\n<p>Executing <code>f()</code> will find the function <code>a</code>, explicitly imported from package A. But executing <code>a()</code> will die because \nfunction <code>b</code> can not be found.</p>\n\n<h2>analysis</h2>\n\n<p>Because B is in A Depends, <code>b()</code> is normally found in the search path, where namespace <strong>B</strong> is attached. \nWhat can we do to work around this problem ?<br>\nSadly, there is nothing we can do at the  <strong>MyPkg</strong> package level, since the problem sits in the <strong>A</strong> namespace.\nWe could of course lists B in the <strong>MyPkg</strong> Depends, but that is precisely what we want to avoid.</p>\n\n<h2>the dirty hack solution</h2>\n\n<h3>the idea</h3>\n\n<p>I suggest that you first have a look at this very good blog \n<a href=\"http://obeautifulcode.com/R/How-R-Searches-And-Finds-Stuff/\">How R Searches and Finds Stuff</a> if you need some \nclarification about namespaces and imports.  </p>\n\n<p>Here is a diagram of the current state of the problem:</p>\n\n<p><img src=\"assets/fig/unnamed-chunk-1.png\" alt=\"plot of chunk unnamed-chunk-1\"> </p>\n\n<p>We want the <code>a()</code> call, which is executed in namespace <strong>A</strong>, to find the <strong>b</strong> symbol in namespace <strong>B</strong>. \nTo achieve this, we will re-route the namespace <strong>A</strong> (actually its Imports namespace) to the <strong>B</strong> namespace:</p>\n\n<pre><code>nsa &lt;- getNamespace(&#39;A&#39;)\nnsa_imp &lt;- parent.env(nsa)\nparent.env(nsa_imp) &lt;- getNamespace(&#39;B&#39;)\n</code></pre>\n\n<p>Now our namespaces should look like this:  </p>\n\n<p><img src=\"assets/fig/unnamed-chunk-2.png\" alt=\"plot of chunk unnamed-chunk-2\"> </p>\n\n<h2>Example</h2>\n\n<p>The above code is not straightforward to test because you need to write a package.  </p>\n\n<p>Here is some reproducible code that illustrates how the hack works, using package <strong>multcomp</strong> that <em>Depends</em> on <strong>mvtnorm</strong></p>\n\n<pre><code class=\"r\">l &lt;- loadNamespace(&quot;multcomp&quot;)  # assignment to avoid annoying print\n\namod &lt;- aov(breaks ~ wool + tension, data = warpbreaks)\nwht &lt;- multcomp::glht(amod, linfct = multcomp::mcp(tension = &quot;Tukey&quot;))\nci &lt;- confint(wht)  # mvtnorm::qmvt is not found\n</code></pre>\n\n<pre><code>## Error: could not find function &quot;qmvt&quot;\n</code></pre>\n\n<pre><code class=\"r\">\n# let&#39;s load the mvtnorm namespace\nl &lt;- loadNamespace(&quot;mvtnorm&quot;)\nci &lt;- confint(wht)  # mvtnorm::qmvt still not found\n</code></pre>\n\n<pre><code>## Error: could not find function &quot;qmvt&quot;\n</code></pre>\n\n<pre><code class=\"r\">\n# hack hack hack\nns1 &lt;- getNamespace(&quot;multcomp&quot;)\nns1_imp &lt;- parent.env(ns1)\nparent.env(ns1_imp) &lt;- getNamespace(&quot;mvtnorm&quot;)\n\nci &lt;- confint(wht)  # now should work\nprint(ci)\n</code></pre>\n\n<pre><code>## \n##   Simultaneous Confidence Intervals\n## \n## Multiple Comparisons of Means: Tukey Contrasts\n## \n## \n## Fit: aov(formula = breaks ~ wool + tension, data = warpbreaks)\n## \n## Quantile = 2.416\n## 95% family-wise confidence level\n##  \n## \n## Linear Hypotheses:\n##            Estimate lwr     upr    \n## M - L == 0 -10.000  -19.354  -0.646\n## H - L == 0 -14.722  -24.076  -5.368\n## H - M == 0  -4.722  -14.076   4.632\n</code></pre>\n\n<h2>implementation of the hack in MyPkg</h2>\n\n<p>Just put the re-routing code in your MyPkg <strong>.onLoad</strong> function, defined usually in <code>R/zzz.R</code>:</p>\n\n<pre><code>.onLoad &lt;- function(libname, pkgname) {\n    nsa &lt;- getNamespace(&#39;A&#39;)\n    nsa_imp &lt;- parent.env(nsa)\n    parent.env(nsa_imp) &lt;- getNamespace(&#39;B&#39;)    \n}\n</code></pre>\n\n<h3>why dirty ?</h3>\n\n<p>First of all, it uses <code>parent.env&lt;-</code>, and according to the documentation:</p>\n\n<blockquote>\n<p>The replacement function parent.env&lt;- is extremely dangerous as it can be used to destructively change environments in ways &gt;that violate assumptions made by the internal C code. It may be removed in the near future.</p>\n</blockquote>\n\n<p>It is a pity because it can be extremely useful.</p>\n\n<h3>why a hack ?</h3>\n\n<p>Unfortunately it does not work in the general case. \nSuppose you need two packages A and D, that both depend on B and C, but with different rules:</p>\n\n<pre><code>A -&gt; B -&gt; C\nD -&gt; C -&gt; B\n</code></pre>\n\n<p>In that case, we would re-route A to B, then B to C. And this is incompatible with the way D is designed, resulting in\nwrong symbol picks if symbols with same name are both defined by B and C.</p>\n\n<h3>so what ?</h3>\n\n<p>We&#39;ll see in a future post a probably much better solution.</p>\n\n<p><em>Karl Forner @ Quartz Bio</em></p>\n"}}