{"site":{"title":"Karl's Blog","tagline":"Karl Blogging Test","background":"assets/img/bgr-numerique.jpg","owner":"Karl Forner","author":{"email":"karl.forner@gmail.com","github":"kforner","firstname":"Karl","lastname":"Forner"},"url":"/","rawurl":"/","navigation":[{"item":"Home","href":"index.html"},{"item":"About","href":"about.html"}],"google_search_engine_id":"016732723349564622635:1pee01gdpao"},"pages":[{"url":{"assets":"assets","lib":"libraries"},"framework":"qb_purus","theme":"","highlighter":"prettify","hitheme":"twitter-bootstrap","copy_libraries":true,"mode":"selfcontained","widgets":["disqus","search"],"github":{"user":"kforner","repo":"kforner.github.io"},"prettify":{"linenums":true},"title":"About","slides":[{"html":"<p>This is my test of <em>Poirot</em> as my R-related blogging system. </p>\n\n<h2>About Poirot</h2>\n\n<p><a href=\"http://github.com/ramnathv/blogify\">Poirot</a> is an elegant, blog aware, static site generator to create, manage and publish websites with reproducible content using <a href=\"http://www.r-project.org\">R Markdown</a>.</p>\n","level":"","title":"","content":"<p>This is my test of <em>Poirot</em> as my R-related blogging system. </p>\n\n<h2>About Poirot</h2>\n\n<p><a href=\"http://github.com/ramnathv/blogify\">Poirot</a> is an elegant, blog aware, static site generator to create, manage and publish websites with reproducible content using <a href=\"http://www.r-project.org\">R Markdown</a>.</p>\n","num":1,"id":"slide-1","raw":"---  \n\nThis is my test of *Poirot* as my R-related blogging system. \n\nAbout Poirot\n-------------------------\n\n[Poirot](http://github.com/ramnathv/blogify) is an elegant, blog aware, static site generator to create, manage and publish websites with reproducible content using [R Markdown](http://www.r-project.org)."},{"html":"<p><strong>Installing Poirot</strong></p>\n\n<p>Poirot is still under development and can be installed from github using <a href=\"http:github.com/hadley/devtools\">devtools</a>. You will also need to install the development versions of <a href=\"http://github.com/ramnathv/slidify\">slidify</a> and <a href=\"http://github.com/ramnathv/slidifyLibraries\">slidifyLibraries</a>.</p>\n\n<pre><code class=\"r\">require(devtools)\ninstall_github(&quot;poirot&quot;, &quot;ramnathv&quot;)\ninstall_github(&quot;slidify&quot;, &quot;ramnathv&quot;, ref = &quot;dev&quot;)\ninstall_github(&quot;slidifyLibraries&quot;, &quot;ramnathv&quot;)\n</code></pre>\n\n<p>Poirot uses <strong>markdown</strong> for text content, <strong>knitr</strong> for code chunks and <strong>mustache</strong> for templating. Poirot is highly extensible using widgets. As a publishing framework for data scientists, Poirot comes pre-equipped with support for math, visualization and tables.</p>\n\n<p><strong>Reproducing this Blog</strong></p>\n\n<p>Once you have installed Poirot, you can reproduce this blog by cloning this git repository, running <code>blogify</code>, opening a web server and navigating to <code>http://localhost:8080/posts</code> on your browser.</p>\n\n<pre><code class=\"bash\">$ git clone git@github.com:ramnathv/poirotBlog\n$ cd poirotBlog\n$ python -m SimpleHTTPServer 8080\n$ open localhost:8080/posts\n</code></pre>\n\n<p>You can generate your own posts by clearing out all files from the <code>posts</code> folder (except for <code>config.yml</code>), tweaking <code>site.yml</code> and <code>posts/config.yml</code> and running <code>blogify(&quot;posts&quot;)</code> from the root directory.</p>\n\n<p><strong>How to contribute</strong></p>\n\n<p>You can <a href=\"https://github.com/ramnathv/blogify\">fork the repository</a> on Github.</p>\n\n<p><strong>Copyright</strong></p>\n\n<p>All the content in this blog is licensed under <a href=\"http://creativecommons.org/licenses/by-nc-sa/3.0/\">CC BY-NC-SA 3.0</a>. This site is hosted on <a href=\"https://github.com\">GitHub</a> Pages and uses a modified version of <a href=\"https://github.com/mertemin/purus\">purus theme</a>.</p>\n","level":"","title":"","content":"<p><strong>Installing Poirot</strong></p>\n\n<p>Poirot is still under development and can be installed from github using <a href=\"http:github.com/hadley/devtools\">devtools</a>. You will also need to install the development versions of <a href=\"http://github.com/ramnathv/slidify\">slidify</a> and <a href=\"http://github.com/ramnathv/slidifyLibraries\">slidifyLibraries</a>.</p>\n\n<pre><code class=\"r\">require(devtools)\ninstall_github(&quot;poirot&quot;, &quot;ramnathv&quot;)\ninstall_github(&quot;slidify&quot;, &quot;ramnathv&quot;, ref = &quot;dev&quot;)\ninstall_github(&quot;slidifyLibraries&quot;, &quot;ramnathv&quot;)\n</code></pre>\n\n<p>Poirot uses <strong>markdown</strong> for text content, <strong>knitr</strong> for code chunks and <strong>mustache</strong> for templating. Poirot is highly extensible using widgets. As a publishing framework for data scientists, Poirot comes pre-equipped with support for math, visualization and tables.</p>\n\n<p><strong>Reproducing this Blog</strong></p>\n\n<p>Once you have installed Poirot, you can reproduce this blog by cloning this git repository, running <code>blogify</code>, opening a web server and navigating to <code>http://localhost:8080/posts</code> on your browser.</p>\n\n<pre><code class=\"bash\">$ git clone git@github.com:ramnathv/poirotBlog\n$ cd poirotBlog\n$ python -m SimpleHTTPServer 8080\n$ open localhost:8080/posts\n</code></pre>\n\n<p>You can generate your own posts by clearing out all files from the <code>posts</code> folder (except for <code>config.yml</code>), tweaking <code>site.yml</code> and <code>posts/config.yml</code> and running <code>blogify(&quot;posts&quot;)</code> from the root directory.</p>\n\n<p><strong>How to contribute</strong></p>\n\n<p>You can <a href=\"https://github.com/ramnathv/blogify\">fork the repository</a> on Github.</p>\n\n<p><strong>Copyright</strong></p>\n\n<p>All the content in this blog is licensed under <a href=\"http://creativecommons.org/licenses/by-nc-sa/3.0/\">CC BY-NC-SA 3.0</a>. This site is hosted on <a href=\"https://github.com\">GitHub</a> Pages and uses a modified version of <a href=\"https://github.com/mertemin/purus\">purus theme</a>.</p>\n","num":2,"id":"slide-2","raw":"--- \n\n**Installing Poirot**\n\nPoirot is still under development and can be installed from github using [devtools](http:github.com/hadley/devtools). You will also need to install the development versions of [slidify](http://github.com/ramnathv/slidify) and [slidifyLibraries](http://github.com/ramnathv/slidifyLibraries).\n\n```{r eval = F}\nrequire(devtools)\ninstall_github('poirot', 'ramnathv')\ninstall_github('slidify', 'ramnathv', ref = 'dev')\ninstall_github('slidifyLibraries', 'ramnathv')\n```\n\n\nPoirot uses **markdown** for text content, **knitr** for code chunks and **mustache** for templating. Poirot is highly extensible using widgets. As a publishing framework for data scientists, Poirot comes pre-equipped with support for math, visualization and tables.\n\n**Reproducing this Blog**\n\nOnce you have installed Poirot, you can reproduce this blog by cloning this git repository, running `blogify`, opening a web server and navigating to `http://localhost:8080/posts` on your browser.\n\n```bash\n$ git clone git@github.com:ramnathv/poirotBlog\n$ cd poirotBlog\n$ python -m SimpleHTTPServer 8080\n$ open localhost:8080/posts\n```\n\nYou can generate your own posts by clearing out all files from the `posts` folder (except for `config.yml`), tweaking `site.yml` and `posts/config.yml` and running `blogify(\"posts\")` from the root directory.\n\n**How to contribute**\n\nYou can [fork the repository](https://github.com/ramnathv/blogify) on Github.\n\n**Copyright**\n\nAll the content in this blog is licensed under [CC BY-NC-SA 3.0](http://creativecommons.org/licenses/by-nc-sa/3.0/). This site is hosted on [GitHub](https://github.com) Pages and uses a modified version of [purus theme](https://github.com/mertemin/purus).\n"}],"standalone":false,"file":"about.Rmd","filename":"about","link":"about.html","raw":"---\ntitle: About\nurl: {lib: libraries}\nhighlighter: prettify\nhitheme: twitter-bootstrap\nmode: selfcontained\n--- \n\nThis is my test of *Poirot* as my R-related blogging system. \n\nAbout Poirot\n-------------------------\n\n[Poirot](http://github.com/ramnathv/blogify) is an elegant, blog aware, static site generator to create, manage and publish websites with reproducible content using [R Markdown](http://www.r-project.org).\n\n---\n\n**Installing Poirot**\n\nPoirot is still under development and can be installed from github using [devtools](http:github.com/hadley/devtools). You will also need to install the development versions of [slidify](http://github.com/ramnathv/slidify) and [slidifyLibraries](http://github.com/ramnathv/slidifyLibraries).\n\n```{r eval = F}\nrequire(devtools)\ninstall_github('poirot', 'ramnathv')\ninstall_github('slidify', 'ramnathv', ref = 'dev')\ninstall_github('slidifyLibraries', 'ramnathv')\n```\n\n\nPoirot uses **markdown** for text content, **knitr** for code chunks and **mustache** for templating. Poirot is highly extensible using widgets. As a publishing framework for data scientists, Poirot comes pre-equipped with support for math, visualization and tables.\n\n**Reproducing this Blog**\n\nOnce you have installed Poirot, you can reproduce this blog by cloning this git repository, running `blogify`, opening a web server and navigating to `http://localhost:8080/posts` on your browser.\n\n```bash\n$ git clone git@github.com:ramnathv/poirotBlog\n$ cd poirotBlog\n$ python -m SimpleHTTPServer 8080\n$ open localhost:8080/posts\n```\n\nYou can generate your own posts by clearing out all files from the `posts` folder (except for `config.yml`), tweaking `site.yml` and `posts/config.yml` and running `blogify(\"posts\")` from the root directory.\n\n**How to contribute**\n\nYou can [fork the repository](https://github.com/ramnathv/blogify) on Github.\n\n**Copyright**\n\nAll the content in this blog is licensed under [CC BY-NC-SA 3.0](http://creativecommons.org/licenses/by-nc-sa/3.0/). This site is hosted on [GitHub](https://github.com) Pages and uses a modified version of [purus theme](https://github.com/mertemin/purus).\n"},{"url":{"assets":"assets"},"framework":"qb_purus","theme":"","highlighter":"prettify","hitheme":"twitter-bootstrap","copy_libraries":true,"mode":"selfcontained","widgets":["disqus","search"],"github":{"user":"kforner","repo":"kforner.github.io"},"prettify":{"linenums":true},"title":"Reproducible Blogging with R Markdown","slides":[{"html":"<style>\nul.posts {\n  margin-top: 15px;\n}\nul.posts li {\n  list-style: none\n}\nul.posts hr {\n  margin: 5px 5px;\n}\nul.posts span {\n  font-size: 12px;\n  color: #999;\n}\n</style>\n\n<ul class=\"posts\">\n{{# pages }}\n {{# date }}\n <li>\n  <span class='pull-right'>{{date}}</span> \n  <a href=\"{{site.url}}{{link}}\">{{{ title }}}</a>\n  <hr/>\n </li>\n {{/ date }}\n{{/ pages }}\n</ul>\n","level":"","title":"","content":"<style>\nul.posts {\n  margin-top: 15px;\n}\nul.posts li {\n  list-style: none\n}\nul.posts hr {\n  margin: 5px 5px;\n}\nul.posts span {\n  font-size: 12px;\n  color: #999;\n}\n</style>\n\n<ul class=\"posts\">\n{{# pages }}\n {{# date }}\n <li>\n  <span class='pull-right'>{{date}}</span> \n  <a href=\"{{site.url}}{{link}}\">{{{ title }}}</a>\n  <hr/>\n </li>\n {{/ date }}\n{{/ pages }}\n</ul>\n","num":1,"id":"slide-1","raw":"--- \n\n<style>\nul.posts {\n  margin-top: 15px;\n}\nul.posts li {\n  list-style: none\n}\nul.posts hr {\n  margin: 5px 5px;\n}\nul.posts span {\n  font-size: 12px;\n  color: #999;\n}\n</style>\n\n\n\n<ul class=\"posts\">\n{{# pages }}\n {{# date }}\n <li>\n  <span class='pull-right'>{{date}}</span> \n  <a href=\"{{site.url}}{{link}}\">{{{ title }}}</a>\n  <hr/>\n </li>\n {{/ date }}\n{{/ pages }}\n</ul>\n"}],"standalone":false,"file":"index.Rmd","filename":"index","link":"index.html","raw":"---\ntitle: Reproducible Blogging with R Markdown\n---\n\n<style>\nul.posts {\n  margin-top: 15px;\n}\nul.posts li {\n  list-style: none\n}\nul.posts hr {\n  margin: 5px 5px;\n}\nul.posts span {\n  font-size: 12px;\n  color: #999;\n}\n</style>\n\n\n\n<ul class=\"posts\">\n{{# pages }}\n {{# date }}\n <li>\n  <span class='pull-right'>{{date}}</span> \n  <a href=\"{{site.url}}{{link}}\">{{{ title }}}</a>\n  <hr/>\n </li>\n {{/ date }}\n{{/ pages }}\n</ul>\n"},{"url":{"assets":"../assets","lib":"../libraries"},"framework":"qb_purus","theme":"","highlighter":"prettify","hitheme":"twitter-bootstrap","copy_libraries":true,"mode":"selfcontained","widgets":"disqus","github":{"user":"ramnathv","repo":"poirot"},"prettify":{"linenums":true},"disqus":{"shortname":"kfornergithubio"},"title":"A dirty hack solution for packages using Depends","author":"Karl Forner","license":"GPL (>= 2)","tags":"package namespace imports depends","summary":"A dirty hack solution for packages using Depends","date":15852,"slides":[{"html":"<h2>Motivation</h2>\n\n<p>As stated in the the &quot;Writing R Extensions&quot;, the Software for Data Analysis book (aka the R bible), packages should\nwhenever possible use <strong>Imports</strong> instead of <strong>Depends</strong>, to avoid name collision (masking) and ensure trustworthy computations. \nSee <a href=\"http://stackoverflow.com/questions/8637993/better-explanation-of-when-to-use-imports-depends\">this discussion on Stackoverflow</a>.</p>\n\n<h2>The problem</h2>\n\n<p>So after adopting best practices, and only using <strong>Imports</strong> in my packages, the problem is that some <em>imported</em> packages \ndo not follow those best practices and rely on <strong>Depends</strong> for their dependencies, and consequently will not find \ntheir dependencies unless hacked.  </p>\n\n<p>Say we are writing a package <strong>MyPkg</strong>, that uses some functions from a CRAN package <strong>A</strong>, which lists a CRAN \npackage <strong>B</strong> in its Depends.</p>\n\n<p><em>MyPkg::f</em></p>\n\n<pre><code>f &lt;- function() a()\n</code></pre>\n\n<p><em>A::a</em></p>\n\n<pre><code>a &lt;- function() b()\n</code></pre>\n\n<p>Executing <code>f()</code> will find the function <code>a</code>, explicitly imported from package A. But executing <code>a()</code> will die because \nfunction <code>b</code> can not be found.</p>\n\n<h2>analysis</h2>\n\n<p>Because B is in A Depends, <code>b()</code> is normally found in the search path, where namespace <strong>B</strong> is attached. \nWhat can we do to work around this problem ?<br>\nSadly, there is nothing we can do at the  <strong>MyPkg</strong> package level, since the problem sits in the <strong>A</strong> namespace.\nWe could of course lists B in the <strong>MyPkg</strong> Depends, but that is precisely what we want to avoid.</p>\n\n<h2>the dirty hack solution</h2>\n\n<h3>the idea</h3>\n\n<p>I suggest that you first have a look at this very good blog \n<a href=\"http://obeautifulcode.com/R/How-R-Searches-And-Finds-Stuff/\">How R Searches and Finds Stuff</a> if you need some \nclarification about namespaces and imports.  </p>\n\n<p>Here is a diagram of the current state of the problem:</p>\n\n<p><img src=\"assets/fig/unnamed-chunk-1.png\" alt=\"plot of chunk unnamed-chunk-1\"> </p>\n\n<p>We want the <code>a()</code> call, which is executed in namespace <strong>A</strong>, to find the <strong>b</strong> symbol in namespace <strong>B</strong>. \nTo achieve this, we will re-route the namespace <strong>A</strong> (actually its Imports namespace) to the <strong>B</strong> namespace:</p>\n\n<pre><code>nsa &lt;- getNamespace(&#39;A&#39;)\nnsa_imp &lt;- parent.env(nsa)\nparent.env(nsa_imp) &lt;- getNamespace(&#39;B&#39;)\n</code></pre>\n\n<p>Now our namespaces should look like this:  </p>\n\n<p><img src=\"assets/fig/unnamed-chunk-2.png\" alt=\"plot of chunk unnamed-chunk-2\"> </p>\n\n<h2>Example</h2>\n\n<p>The above code is not straightforward to test because you need to write a package.  </p>\n\n<p>Here is some reproducible code that illustrates how the hack works, using package <strong>multcomp</strong> that <em>Depends</em> on <strong>mvtnorm</strong></p>\n\n<pre><code class=\"r\">l &lt;- loadNamespace(&quot;multcomp&quot;)  # assignment to avoid annoying print\n\namod &lt;- aov(breaks ~ wool + tension, data = warpbreaks)\nwht &lt;- multcomp::glht(amod, linfct = multcomp::mcp(tension = &quot;Tukey&quot;))\nci &lt;- confint(wht)  # mvtnorm::qmvt is not found\n</code></pre>\n\n<pre><code>## Error: could not find function &quot;qmvt&quot;\n</code></pre>\n\n<pre><code class=\"r\">\n# let&#39;s load the mvtnorm namespace\nl &lt;- loadNamespace(&quot;mvtnorm&quot;)\nci &lt;- confint(wht)  # mvtnorm::qmvt still not found\n</code></pre>\n\n<pre><code>## Error: could not find function &quot;qmvt&quot;\n</code></pre>\n\n<pre><code class=\"r\">\n# hack hack hack\nns1 &lt;- getNamespace(&quot;multcomp&quot;)\nns1_imp &lt;- parent.env(ns1)\nparent.env(ns1_imp) &lt;- getNamespace(&quot;mvtnorm&quot;)\n\nci &lt;- confint(wht)  # now should work\nprint(ci)\n</code></pre>\n\n<pre><code>## \n##   Simultaneous Confidence Intervals\n## \n## Multiple Comparisons of Means: Tukey Contrasts\n## \n## \n## Fit: aov(formula = breaks ~ wool + tension, data = warpbreaks)\n## \n## Quantile = 2.416\n## 95% family-wise confidence level\n##  \n## \n## Linear Hypotheses:\n##            Estimate lwr     upr    \n## M - L == 0 -10.000  -19.354  -0.646\n## H - L == 0 -14.722  -24.076  -5.368\n## H - M == 0  -4.722  -14.076   4.632\n</code></pre>\n\n<h2>implementation of the hack in MyPkg</h2>\n\n<p>Just put the re-routing code in your MyPkg <strong>.onLoad</strong> function, defined usually in <code>R/zzz.R</code>:</p>\n\n<pre><code>.onLoad &lt;- function(libname, pkgname) {\n    nsa &lt;- getNamespace(&#39;A&#39;)\n    nsa_imp &lt;- parent.env(nsa)\n    parent.env(nsa_imp) &lt;- getNamespace(&#39;B&#39;)    \n}\n</code></pre>\n\n<h3>why dirty ?</h3>\n\n<p>First of all, it uses <code>parent.env&lt;-</code>, and according to the documentation:</p>\n\n<blockquote>\n<p>The replacement function parent.env&lt;- is extremely dangerous as it can be used to destructively change environments in ways &gt;that violate assumptions made by the internal C code. It may be removed in the near future.</p>\n</blockquote>\n\n<p>It is a pity because it can be extremely useful.</p>\n\n<h3>why a hack ?</h3>\n\n<p>Unfortunately it does not work in the general case. \nSuppose you need two packages A and D, that both depend on B and C, but with different rules:</p>\n\n<pre><code>A -&gt; B -&gt; C\nD -&gt; C -&gt; B\n</code></pre>\n\n<p>In that case, we would re-route A to B, then B to C. And this is incompatible with the way D is designed, resulting in\nwrong symbol picks if symbols with same name are both defined by B and C.</p>\n\n<h3>so what ?</h3>\n\n<p>We&#39;ll see in a future post a probably much better solution.</p>\n\n<p><em>Karl Forner @ Quartz Bio</em></p>\n","header":"<h2>Motivation</h2>","level":"2","title":"Motivation","content":"<p>As stated in the the &quot;Writing R Extensions&quot;, the Software for Data Analysis book (aka the R bible), packages should\nwhenever possible use <strong>Imports</strong> instead of <strong>Depends</strong>, to avoid name collision (masking) and ensure trustworthy computations. \nSee <a href=\"http://stackoverflow.com/questions/8637993/better-explanation-of-when-to-use-imports-depends\">this discussion on Stackoverflow</a>.</p>\n\n<h2>The problem</h2>\n\n<p>So after adopting best practices, and only using <strong>Imports</strong> in my packages, the problem is that some <em>imported</em> packages \ndo not follow those best practices and rely on <strong>Depends</strong> for their dependencies, and consequently will not find \ntheir dependencies unless hacked.  </p>\n\n<p>Say we are writing a package <strong>MyPkg</strong>, that uses some functions from a CRAN package <strong>A</strong>, which lists a CRAN \npackage <strong>B</strong> in its Depends.</p>\n\n<p><em>MyPkg::f</em></p>\n\n<pre><code>f &lt;- function() a()\n</code></pre>\n\n<p><em>A::a</em></p>\n\n<pre><code>a &lt;- function() b()\n</code></pre>\n\n<p>Executing <code>f()</code> will find the function <code>a</code>, explicitly imported from package A. But executing <code>a()</code> will die because \nfunction <code>b</code> can not be found.</p>\n\n<h2>analysis</h2>\n\n<p>Because B is in A Depends, <code>b()</code> is normally found in the search path, where namespace <strong>B</strong> is attached. \nWhat can we do to work around this problem ?<br>\nSadly, there is nothing we can do at the  <strong>MyPkg</strong> package level, since the problem sits in the <strong>A</strong> namespace.\nWe could of course lists B in the <strong>MyPkg</strong> Depends, but that is precisely what we want to avoid.</p>\n\n<h2>the dirty hack solution</h2>\n\n<h3>the idea</h3>\n\n<p>I suggest that you first have a look at this very good blog \n<a href=\"http://obeautifulcode.com/R/How-R-Searches-And-Finds-Stuff/\">How R Searches and Finds Stuff</a> if you need some \nclarification about namespaces and imports.  </p>\n\n<p>Here is a diagram of the current state of the problem:</p>\n\n<p><img src=\"assets/fig/unnamed-chunk-1.png\" alt=\"plot of chunk unnamed-chunk-1\"> </p>\n\n<p>We want the <code>a()</code> call, which is executed in namespace <strong>A</strong>, to find the <strong>b</strong> symbol in namespace <strong>B</strong>. \nTo achieve this, we will re-route the namespace <strong>A</strong> (actually its Imports namespace) to the <strong>B</strong> namespace:</p>\n\n<pre><code>nsa &lt;- getNamespace(&#39;A&#39;)\nnsa_imp &lt;- parent.env(nsa)\nparent.env(nsa_imp) &lt;- getNamespace(&#39;B&#39;)\n</code></pre>\n\n<p>Now our namespaces should look like this:  </p>\n\n<p><img src=\"assets/fig/unnamed-chunk-2.png\" alt=\"plot of chunk unnamed-chunk-2\"> </p>\n\n<h2>Example</h2>\n\n<p>The above code is not straightforward to test because you need to write a package.  </p>\n\n<p>Here is some reproducible code that illustrates how the hack works, using package <strong>multcomp</strong> that <em>Depends</em> on <strong>mvtnorm</strong></p>\n\n<pre><code class=\"r\">l &lt;- loadNamespace(&quot;multcomp&quot;)  # assignment to avoid annoying print\n\namod &lt;- aov(breaks ~ wool + tension, data = warpbreaks)\nwht &lt;- multcomp::glht(amod, linfct = multcomp::mcp(tension = &quot;Tukey&quot;))\nci &lt;- confint(wht)  # mvtnorm::qmvt is not found\n</code></pre>\n\n<pre><code>## Error: could not find function &quot;qmvt&quot;\n</code></pre>\n\n<pre><code class=\"r\">\n# let&#39;s load the mvtnorm namespace\nl &lt;- loadNamespace(&quot;mvtnorm&quot;)\nci &lt;- confint(wht)  # mvtnorm::qmvt still not found\n</code></pre>\n\n<pre><code>## Error: could not find function &quot;qmvt&quot;\n</code></pre>\n\n<pre><code class=\"r\">\n# hack hack hack\nns1 &lt;- getNamespace(&quot;multcomp&quot;)\nns1_imp &lt;- parent.env(ns1)\nparent.env(ns1_imp) &lt;- getNamespace(&quot;mvtnorm&quot;)\n\nci &lt;- confint(wht)  # now should work\nprint(ci)\n</code></pre>\n\n<pre><code>## \n##   Simultaneous Confidence Intervals\n## \n## Multiple Comparisons of Means: Tukey Contrasts\n## \n## \n## Fit: aov(formula = breaks ~ wool + tension, data = warpbreaks)\n## \n## Quantile = 2.416\n## 95% family-wise confidence level\n##  \n## \n## Linear Hypotheses:\n##            Estimate lwr     upr    \n## M - L == 0 -10.000  -19.354  -0.646\n## H - L == 0 -14.722  -24.076  -5.368\n## H - M == 0  -4.722  -14.076   4.632\n</code></pre>\n\n<h2>implementation of the hack in MyPkg</h2>\n\n<p>Just put the re-routing code in your MyPkg <strong>.onLoad</strong> function, defined usually in <code>R/zzz.R</code>:</p>\n\n<pre><code>.onLoad &lt;- function(libname, pkgname) {\n    nsa &lt;- getNamespace(&#39;A&#39;)\n    nsa_imp &lt;- parent.env(nsa)\n    parent.env(nsa_imp) &lt;- getNamespace(&#39;B&#39;)    \n}\n</code></pre>\n\n<h3>why dirty ?</h3>\n\n<p>First of all, it uses <code>parent.env&lt;-</code>, and according to the documentation:</p>\n\n<blockquote>\n<p>The replacement function parent.env&lt;- is extremely dangerous as it can be used to destructively change environments in ways &gt;that violate assumptions made by the internal C code. It may be removed in the near future.</p>\n</blockquote>\n\n<p>It is a pity because it can be extremely useful.</p>\n\n<h3>why a hack ?</h3>\n\n<p>Unfortunately it does not work in the general case. \nSuppose you need two packages A and D, that both depend on B and C, but with different rules:</p>\n\n<pre><code>A -&gt; B -&gt; C\nD -&gt; C -&gt; B\n</code></pre>\n\n<p>In that case, we would re-route A to B, then B to C. And this is incompatible with the way D is designed, resulting in\nwrong symbol picks if symbols with same name are both defined by B and C.</p>\n\n<h3>so what ?</h3>\n\n<p>We&#39;ll see in a future post a probably much better solution.</p>\n\n<p><em>Karl Forner @ Quartz Bio</em></p>\n","num":1,"id":"slide-1","raw":"--- \n\n## Motivation\n\nAs stated in the the \"Writing R Extensions\", the Software for Data Analysis book (aka the R bible), packages should\nwhenever possible use **Imports** instead of **Depends**, to avoid name collision (masking) and ensure trustworthy computations. \nSee [this discussion on Stackoverflow](http://stackoverflow.com/questions/8637993/better-explanation-of-when-to-use-imports-depends).\n\n## The problem\n\nSo after adopting best practices, and only using **Imports** in my packages, the problem is that some _imported_ packages \ndo not follow those best practices and rely on **Depends** for their dependencies, and consequently will not find \ntheir dependencies unless hacked.  \n\nSay we are writing a package **MyPkg**, that uses some functions from a CRAN package **A**, which lists a CRAN \npackage **B** in its Depends.\n\n_MyPkg::f_\n```\nf <- function() a()\n```\n_A::a_\n```\na <- function() b()\n```\n\nExecuting `f()` will find the function `a`, explicitly imported from package A. But executing `a()` will die because \nfunction `b` can not be found.\n\n## analysis\n\nBecause B is in A Depends, `b()` is normally found in the search path, where namespace **B** is attached. \nWhat can we do to work around this problem ?  \nSadly, there is nothing we can do at the  **MyPkg** package level, since the problem sits in the **A** namespace.\nWe could of course lists B in the **MyPkg** Depends, but that is precisely what we want to avoid.\n\n## the dirty hack solution\n\n### the idea\n\nI suggest that you first have a look at this very good blog \n[How R Searches and Finds Stuff](http://obeautifulcode.com/R/How-R-Searches-And-Finds-Stuff/) if you need some \nclarification about namespaces and imports.  \n\n\nHere is a diagram of the current state of the problem:\n\n```{r echo=FALSE}\nsuppressPackageStartupMessages(library(diagram))\npar(mar = c(1, 1, 2, 1))\n\nnames <- c( \"MyPkg:\\nf()\", \"A:\\nA()\", \"B\\nb()\", \"MyPkg.Imports\\nA::a()\", \"A.Imports\", \"B.Imports\", \"Base\")\nn  <- length(names)\nM <- matrix(nrow = n, ncol = n, byrow = TRUE, data = 0)\n\nM[4, 1] <- M[7, 4] <- M[5, 2] <- M[7, 5] <- M[6, 3] <- M[7, 6]  <- 1\ncoords <- coordinates(c(3, 3, 1))\nplotmat(M, pos = coords, curve = 0, name = names, lwd = 1, box.lwd = 2, cex.txt = 0.8, box.type = \"circle\", box.prop = 1.0)\ncurvedarrow(from = coords[1, ], to = coords[2, ], curve = +0.5, lty = 2, lcol = 2)\nmtext(outer = TRUE, side = 3, line = -1.5, cex = 1.5, \"Namespaces before\")\n```\n\n\nWe want the `a()` call, which is executed in namespace **A**, to find the **b** symbol in namespace **B**. \nTo achieve this, we will re-route the namespace **A** (actually its Imports namespace) to the **B** namespace:\n```\nnsa <- getNamespace('A')\nnsa_imp <- parent.env(nsa)\nparent.env(nsa_imp) <- getNamespace('B')\n```\n\nNow our namespaces should look like this:  \n\n```{r echo=FALSE}\n\npar(mar = c(1, 1, 2, 1))\n\nnames <- c( \"MyPkg:\\nf()\", \"A:\\nA()\", \"B\\nb()\", \"MyPkg.Imports\\nA::a()\", \"A.Imports\", \"B.Imports\", \"Base\")\nn  <- length(names)\nM <- matrix(nrow = n, ncol = n, byrow = TRUE, data = 0)\n\nM[4, 1] <- M[7, 4] <- M[5, 2] <- M[6, 3] <- M[7, 6]  <- 1\nM[3, 5] <- 1\ncoords <- coordinates(c(3, 3, 1))\nplotmat(M, pos = coords, curve = 0, name = names, lwd = 1, box.lwd = 2, cex.txt = 0.8, box.type = \"circle\", box.prop = 1.0)\ncurvedarrow(from = coords[1, ], to = coords[2, ], curve = +0.5, lty = 2, lcol = 2)\nmtext(outer = TRUE, side = 3, line = -1.5, cex = 1.5, \"Namespaces after re-rerouting\")\n```\n\n## Example\n\n\nThe above code is not straightforward to test because you need to write a package.  \n\nHere is some reproducible code that illustrates how the hack works, using package **multcomp** that _Depends_ on **mvtnorm**\n\n```{r}\nl <- loadNamespace('multcomp') # assignment to avoid annoying print\n\namod <- aov(breaks ~ wool + tension, data = warpbreaks)\nwht <- multcomp::glht(amod, linfct = multcomp::mcp(tension = \"Tukey\"))\nci <- confint(wht) # mvtnorm::qmvt is not found\n\n# let's load the mvtnorm namespace\nl <- loadNamespace('mvtnorm')\nci <- confint(wht) # mvtnorm::qmvt still not found\n\n# hack hack hack\nns1 <- getNamespace('multcomp')\nns1_imp <- parent.env(ns1)\nparent.env(ns1_imp) <- getNamespace('mvtnorm')\n\nci <- confint(wht) # now should work\nprint(ci)\n\n```\n\n## implementation of the hack in MyPkg\n\nJust put the re-routing code in your MyPkg **.onLoad** function, defined usually in `R/zzz.R`:\n\n```\n.onLoad <- function(libname, pkgname) {\n    nsa <- getNamespace('A')\n    nsa_imp <- parent.env(nsa)\n    parent.env(nsa_imp) <- getNamespace('B')    \n}\n```\n\n### why dirty ?\n\nFirst of all, it uses `parent.env<-`, and according to the documentation:\n>The replacement function parent.env<- is extremely dangerous as it can be used to destructively change environments in ways >that violate assumptions made by the internal C code. It may be removed in the near future.\n\nIt is a pity because it can be extremely useful.\n\n### why a hack ?\n\nUnfortunately it does not work in the general case. \nSuppose you need two packages A and D, that both depend on B and C, but with different rules:\n```\nA -> B -> C\nD -> C -> B\n```\nIn that case, we would re-route A to B, then B to C. And this is incompatible with the way D is designed, resulting in\nwrong symbol picks if symbols with same name are both defined by B and C.\n\n### so what ?\n\nWe'll see in a future post a probably much better solution.\n\n\n_Karl Forner @ Quartz Bio_\n\n"}],"standalone":false,"file":"posts/package-depends-dirty-hack-solution.Rmd","filename":"package-depends-dirty-hack-solution","link":"posts/package-depends-dirty-hack-solution.html","raw":"---\ntitle: A dirty hack solution for packages using Depends\nauthor: Karl Forner\nlicense: GPL (>= 2)\ntags: package namespace imports depends\nsummary: A dirty hack solution for packages using Depends\ndate: 2013-05-27\n---\n\n## Motivation\n\nAs stated in the the \"Writing R Extensions\", the Software for Data Analysis book (aka the R bible), packages should\nwhenever possible use **Imports** instead of **Depends**, to avoid name collision (masking) and ensure trustworthy computations. \nSee [this discussion on Stackoverflow](http://stackoverflow.com/questions/8637993/better-explanation-of-when-to-use-imports-depends).\n\n## The problem\n\nSo after adopting best practices, and only using **Imports** in my packages, the problem is that some _imported_ packages \ndo not follow those best practices and rely on **Depends** for their dependencies, and consequently will not find \ntheir dependencies unless hacked.  \n\nSay we are writing a package **MyPkg**, that uses some functions from a CRAN package **A**, which lists a CRAN \npackage **B** in its Depends.\n\n_MyPkg::f_\n```\nf <- function() a()\n```\n_A::a_\n```\na <- function() b()\n```\n\nExecuting `f()` will find the function `a`, explicitly imported from package A. But executing `a()` will die because \nfunction `b` can not be found.\n\n## analysis\n\nBecause B is in A Depends, `b()` is normally found in the search path, where namespace **B** is attached. \nWhat can we do to work around this problem ?  \nSadly, there is nothing we can do at the  **MyPkg** package level, since the problem sits in the **A** namespace.\nWe could of course lists B in the **MyPkg** Depends, but that is precisely what we want to avoid.\n\n## the dirty hack solution\n\n### the idea\n\nI suggest that you first have a look at this very good blog \n[How R Searches and Finds Stuff](http://obeautifulcode.com/R/How-R-Searches-And-Finds-Stuff/) if you need some \nclarification about namespaces and imports.  \n\n\nHere is a diagram of the current state of the problem:\n\n```{r echo=FALSE}\nsuppressPackageStartupMessages(library(diagram))\npar(mar = c(1, 1, 2, 1))\n\nnames <- c( \"MyPkg:\\nf()\", \"A:\\nA()\", \"B\\nb()\", \"MyPkg.Imports\\nA::a()\", \"A.Imports\", \"B.Imports\", \"Base\")\nn  <- length(names)\nM <- matrix(nrow = n, ncol = n, byrow = TRUE, data = 0)\n\nM[4, 1] <- M[7, 4] <- M[5, 2] <- M[7, 5] <- M[6, 3] <- M[7, 6]  <- 1\ncoords <- coordinates(c(3, 3, 1))\nplotmat(M, pos = coords, curve = 0, name = names, lwd = 1, box.lwd = 2, cex.txt = 0.8, box.type = \"circle\", box.prop = 1.0)\ncurvedarrow(from = coords[1, ], to = coords[2, ], curve = +0.5, lty = 2, lcol = 2)\nmtext(outer = TRUE, side = 3, line = -1.5, cex = 1.5, \"Namespaces before\")\n```\n\n\nWe want the `a()` call, which is executed in namespace **A**, to find the **b** symbol in namespace **B**. \nTo achieve this, we will re-route the namespace **A** (actually its Imports namespace) to the **B** namespace:\n```\nnsa <- getNamespace('A')\nnsa_imp <- parent.env(nsa)\nparent.env(nsa_imp) <- getNamespace('B')\n```\n\nNow our namespaces should look like this:  \n\n```{r echo=FALSE}\n\npar(mar = c(1, 1, 2, 1))\n\nnames <- c( \"MyPkg:\\nf()\", \"A:\\nA()\", \"B\\nb()\", \"MyPkg.Imports\\nA::a()\", \"A.Imports\", \"B.Imports\", \"Base\")\nn  <- length(names)\nM <- matrix(nrow = n, ncol = n, byrow = TRUE, data = 0)\n\nM[4, 1] <- M[7, 4] <- M[5, 2] <- M[6, 3] <- M[7, 6]  <- 1\nM[3, 5] <- 1\ncoords <- coordinates(c(3, 3, 1))\nplotmat(M, pos = coords, curve = 0, name = names, lwd = 1, box.lwd = 2, cex.txt = 0.8, box.type = \"circle\", box.prop = 1.0)\ncurvedarrow(from = coords[1, ], to = coords[2, ], curve = +0.5, lty = 2, lcol = 2)\nmtext(outer = TRUE, side = 3, line = -1.5, cex = 1.5, \"Namespaces after re-rerouting\")\n```\n\n## Example\n\n\nThe above code is not straightforward to test because you need to write a package.  \n\nHere is some reproducible code that illustrates how the hack works, using package **multcomp** that _Depends_ on **mvtnorm**\n\n```{r}\nl <- loadNamespace('multcomp') # assignment to avoid annoying print\n\namod <- aov(breaks ~ wool + tension, data = warpbreaks)\nwht <- multcomp::glht(amod, linfct = multcomp::mcp(tension = \"Tukey\"))\nci <- confint(wht) # mvtnorm::qmvt is not found\n\n# let's load the mvtnorm namespace\nl <- loadNamespace('mvtnorm')\nci <- confint(wht) # mvtnorm::qmvt still not found\n\n# hack hack hack\nns1 <- getNamespace('multcomp')\nns1_imp <- parent.env(ns1)\nparent.env(ns1_imp) <- getNamespace('mvtnorm')\n\nci <- confint(wht) # now should work\nprint(ci)\n\n```\n\n## implementation of the hack in MyPkg\n\nJust put the re-routing code in your MyPkg **.onLoad** function, defined usually in `R/zzz.R`:\n\n```\n.onLoad <- function(libname, pkgname) {\n    nsa <- getNamespace('A')\n    nsa_imp <- parent.env(nsa)\n    parent.env(nsa_imp) <- getNamespace('B')    \n}\n```\n\n### why dirty ?\n\nFirst of all, it uses `parent.env<-`, and according to the documentation:\n>The replacement function parent.env<- is extremely dangerous as it can be used to destructively change environments in ways >that violate assumptions made by the internal C code. It may be removed in the near future.\n\nIt is a pity because it can be extremely useful.\n\n### why a hack ?\n\nUnfortunately it does not work in the general case. \nSuppose you need two packages A and D, that both depend on B and C, but with different rules:\n```\nA -> B -> C\nD -> C -> B\n```\nIn that case, we would re-route A to B, then B to C. And this is incompatible with the way D is designed, resulting in\nwrong symbol picks if symbols with same name are both defined by B and C.\n\n### so what ?\n\nWe'll see in a future post a probably much better solution.\n\n\n_Karl Forner @ Quartz Bio_\n\n"}],"tags":{"package namespace imports depends":{"pages":[{"title":"A dirty hack solution for packages using Depends","file":"posts/package-depends-dirty-hack-solution.Rmd","date":15852,"link":"posts/package-depends-dirty-hack-solution.html"}],"name":"package namespace imports depends","count":1},"all":[{"pages":[{"title":"A dirty hack solution for packages using Depends","file":"posts/package-depends-dirty-hack-solution.Rmd","date":15852,"link":"posts/package-depends-dirty-hack-solution.html"}],"name":"package namespace imports depends","count":1}]},"page":{"syte":{"github":"ramnathv"},"url":{"assets":"assets","lib":"libraries","widgets":"libraries/widgets","framework":"libraries/frameworks/qb_purus","theme":"libraries/frameworks/qb_purus/","highlighters":"libraries/highlighters","layouts":["libraries/frameworks/qb_purus/layouts","assets/layouts","libraries/widgets/disqus/layouts","libraries/widgets/search/layouts"],"highlighter":"libraries/highlighters/prettify"},"framework":"qb_purus","theme":"","highlighter":"prettify","hitheme":"twitter-bootstrap","copy_libraries":true,"mode":"selfcontained","widgets":["disqus","search"],"github":{"user":"kforner","repo":"kforner.github.io"},"prettify":{"linenums":true},"title":"Reproducible Blogging with R Markdown","slides":[{"html":"<style>\nul.posts {\n  margin-top: 15px;\n}\nul.posts li {\n  list-style: none\n}\nul.posts hr {\n  margin: 5px 5px;\n}\nul.posts span {\n  font-size: 12px;\n  color: #999;\n}\n</style>\n\n<ul class=\"posts\">\n{{# pages }}\n {{# date }}\n <li>\n  <span class='pull-right'>{{date}}</span> \n  <a href=\"{{site.url}}{{link}}\">{{{ title }}}</a>\n  <hr/>\n </li>\n {{/ date }}\n{{/ pages }}\n</ul>\n","level":"","title":"","content":"<style>\nul.posts {\n  margin-top: 15px;\n}\nul.posts li {\n  list-style: none\n}\nul.posts hr {\n  margin: 5px 5px;\n}\nul.posts span {\n  font-size: 12px;\n  color: #999;\n}\n</style>\n\n<ul class=\"posts\">\n{{# pages }}\n {{# date }}\n <li>\n  <span class='pull-right'>{{date}}</span> \n  <a href=\"{{site.url}}{{link}}\">{{{ title }}}</a>\n  <hr/>\n </li>\n {{/ date }}\n{{/ pages }}\n</ul>\n","num":1,"id":"slide-1","raw":"--- \n\n<style>\nul.posts {\n  margin-top: 15px;\n}\nul.posts li {\n  list-style: none\n}\nul.posts hr {\n  margin: 5px 5px;\n}\nul.posts span {\n  font-size: 12px;\n  color: #999;\n}\n</style>\n\n\n\n<ul class=\"posts\">\n{{# pages }}\n {{# date }}\n <li>\n  <span class='pull-right'>{{date}}</span> \n  <a href=\"{{site.url}}{{link}}\">{{{ title }}}</a>\n  <hr/>\n </li>\n {{/ date }}\n{{/ pages }}\n</ul>\n","rendered":"\n<style>\nul.posts {\n  margin-top: 15px;\n}\nul.posts li {\n  list-style: none\n}\nul.posts hr {\n  margin: 5px 5px;\n}\nul.posts span {\n  font-size: 12px;\n  color: #999;\n}\n</style>\n\n<ul class=\"posts\">\n   \n <li>\n  <span class='pull-right'>2013-05-27</span> \n  <a href=\"/posts/package-depends-dirty-hack-solution.html\">A dirty hack solution for packages using Depends</a>\n  <hr/>\n </li>\n\n</ul>\n"}],"standalone":false,"file":"index.Rmd","filename":"index","link":"index.html","raw":"---\ntitle: Reproducible Blogging with R Markdown\n---\n\n<style>\nul.posts {\n  margin-top: 15px;\n}\nul.posts li {\n  list-style: none\n}\nul.posts hr {\n  margin: 5px 5px;\n}\nul.posts span {\n  font-size: 12px;\n  color: #999;\n}\n</style>\n\n\n\n<ul class=\"posts\">\n{{# pages }}\n {{# date }}\n <li>\n  <span class='pull-right'>{{date}}</span> \n  <a href=\"{{site.url}}{{link}}\">{{{ title }}}</a>\n  <hr/>\n </li>\n {{/ date }}\n{{/ pages }}\n</ul>\n","stylesheets":"<link rel=\"stylesheet\" href = \"assets/css/custom.css\">\n<link rel=\"stylesheet\" href = \"assets/css/ribbons.css\">\n","assets":{"css":"<link rel=stylesheet href=\"./assets/css/custom.css\"></link>\n<link rel=stylesheet href=\"./assets/css/ribbons.css\"></link>\n","js":"","jshead":""},"content":"\n<style>\nul.posts {\n  margin-top: 15px;\n}\nul.posts li {\n  list-style: none\n}\nul.posts hr {\n  margin: 5px 5px;\n}\nul.posts span {\n  font-size: 12px;\n  color: #999;\n}\n</style>\n\n<ul class=\"posts\">\n   \n <li>\n  <span class='pull-right'>2013-05-27</span> \n  <a href=\"/posts/package-depends-dirty-hack-solution.html\">A dirty hack solution for packages using Depends</a>\n  <hr/>\n </li>\n\n</ul>\n"}}